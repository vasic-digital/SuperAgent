#!/bin/bash
# =============================================================================
# Start MCP Services
# =============================================================================
# This script starts all backend services required by MCP servers.
#
# Usage:
#   ./scripts/mcp/start-mcp-services.sh [options]
#
# Options:
#   --all         Start all services
#   --databases   Start only database services (redis, mongodb, postgres, mysql, elasticsearch)
#   --vectors     Start only vector database services (qdrant, chroma)
#   --minimal     Start minimal services (redis, postgres, qdrant)
#   --stop        Stop all services
#   --status      Show status of all services
#   --logs        Show logs of all services
# =============================================================================

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
COMPOSE_FILE="$PROJECT_ROOT/docker/mcp/docker-compose.mcp-services.yml"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Detect container runtime
detect_runtime() {
    if command -v podman-compose &> /dev/null; then
        COMPOSE_CMD="podman-compose"
        log_info "Using podman-compose"
    elif command -v docker-compose &> /dev/null; then
        COMPOSE_CMD="docker-compose"
        log_info "Using docker-compose"
    elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
        COMPOSE_CMD="docker compose"
        log_info "Using docker compose"
    else
        log_error "No container compose tool found. Install docker-compose or podman-compose."
        exit 1
    fi
}

# Load environment variables
load_env() {
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        log_info "Loading environment from .env"
        set -a
        source "$PROJECT_ROOT/.env"
        set +a
    fi

    if [[ -f "$PROJECT_ROOT/.env.mcp" ]]; then
        log_info "Loading MCP environment from .env.mcp"
        set -a
        source "$PROJECT_ROOT/.env.mcp"
        set +a
    fi
}

# Start services
start_services() {
    local services="$1"
    log_info "Starting MCP services: $services"

    cd "$PROJECT_ROOT"

    if [[ -z "$services" ]]; then
        $COMPOSE_CMD -f "$COMPOSE_FILE" up -d
    else
        $COMPOSE_CMD -f "$COMPOSE_FILE" up -d $services
    fi

    log_success "Services started"
}

# Stop services
stop_services() {
    log_info "Stopping all MCP services..."
    cd "$PROJECT_ROOT"
    $COMPOSE_CMD -f "$COMPOSE_FILE" down
    log_success "Services stopped"
}

# Show status
show_status() {
    log_info "MCP Services Status:"
    cd "$PROJECT_ROOT"
    $COMPOSE_CMD -f "$COMPOSE_FILE" ps
}

# Show logs
show_logs() {
    cd "$PROJECT_ROOT"
    $COMPOSE_CMD -f "$COMPOSE_FILE" logs -f
}

# Wait for services to be healthy
wait_for_services() {
    log_info "Waiting for services to be healthy..."

    local services=("mcp-redis:16379" "mcp-postgres:15432" "mcp-mongodb:27017" "mcp-qdrant:6333")
    local timeout=60
    local start_time=$(date +%s)

    for service_port in "${services[@]}"; do
        IFS=':' read -r service port <<< "$service_port"
        log_info "Waiting for $service on port $port..."

        while ! nc -z localhost "$port" 2>/dev/null; do
            local current_time=$(date +%s)
            local elapsed=$((current_time - start_time))

            if [[ $elapsed -ge $timeout ]]; then
                log_warning "$service not ready after ${timeout}s, continuing..."
                break
            fi

            sleep 1
        done

        if nc -z localhost "$port" 2>/dev/null; then
            log_success "$service is ready"
        fi
    done
}

# Generate environment file with service URLs
generate_env_file() {
    local env_file="$PROJECT_ROOT/.env.mcp.generated"

    log_info "Generating MCP environment file: $env_file"

    cat > "$env_file" << 'EOF'
# =============================================================================
# MCP Services Environment Variables (Auto-generated)
# =============================================================================
# This file is generated by scripts/mcp/start-mcp-services.sh
# Source this file before running HelixAgent to enable MCP services
#
# Usage: source .env.mcp.generated
# =============================================================================

# Redis MCP
REDIS_URL=redis://:helixagent123@localhost:16379
REDIS_HOST=localhost
REDIS_PORT=16379
REDIS_PASSWORD=helixagent123

# MongoDB MCP
MONGODB_URI=mongodb://helixagent:helixagent123@localhost:27017/helixagent?authSource=admin
MONGODB_HOST=localhost
MONGODB_PORT=27017
MONGODB_USER=helixagent
MONGODB_PASSWORD=helixagent123
MONGODB_DATABASE=helixagent

# PostgreSQL MCP
POSTGRES_URL=postgresql://helixagent:helixagent123@localhost:15432/helixagent_db
POSTGRES_HOST=localhost
POSTGRES_PORT=15432
POSTGRES_USER=helixagent
POSTGRES_PASSWORD=helixagent123
POSTGRES_DB=helixagent_db

# MySQL MCP
MYSQL_URL=mysql://helixagent:helixagent123@localhost:3306/helixagent
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_USER=helixagent
MYSQL_PASSWORD=helixagent123
MYSQL_DATABASE=helixagent

# Elasticsearch MCP
ELASTICSEARCH_URL=http://localhost:9200
ELASTICSEARCH_HOST=localhost
ELASTICSEARCH_PORT=9200

# Qdrant MCP (Vector DB)
QDRANT_URL=http://localhost:6333
QDRANT_HOST=localhost
QDRANT_PORT=6333

# Chroma MCP (Vector DB)
CHROMA_URL=http://localhost:8000
CHROMA_HOST=localhost
CHROMA_PORT=8000

# Minio (S3-compatible) for AWS MCP testing
AWS_ENDPOINT_URL=http://localhost:9000
AWS_ACCESS_KEY_ID=minioadmin
AWS_SECRET_ACCESS_KEY=minioadmin123
AWS_REGION=us-east-1

# Browserless (for Puppeteer/Playwright)
BROWSERLESS_URL=http://localhost:3333
PUPPETEER_BROWSER_WS_ENDPOINT=ws://localhost:3333

# Kubernetes (if using local cluster)
# KUBECONFIG=~/.kube/config
EOF

    log_success "Environment file generated: $env_file"
    log_info "Run: source $env_file"
}

# Main
main() {
    detect_runtime
    load_env

    case "${1:-}" in
        --all)
            start_services ""
            wait_for_services
            generate_env_file
            ;;
        --databases)
            start_services "mcp-redis mcp-mongodb mcp-postgres mcp-mysql mcp-elasticsearch"
            wait_for_services
            generate_env_file
            ;;
        --vectors)
            start_services "mcp-qdrant mcp-chroma"
            wait_for_services
            generate_env_file
            ;;
        --minimal)
            start_services "mcp-redis mcp-postgres mcp-qdrant"
            wait_for_services
            generate_env_file
            ;;
        --stop)
            stop_services
            ;;
        --status)
            show_status
            ;;
        --logs)
            show_logs
            ;;
        *)
            echo "Usage: $0 [--all|--databases|--vectors|--minimal|--stop|--status|--logs]"
            echo ""
            echo "Options:"
            echo "  --all         Start all MCP backend services"
            echo "  --databases   Start database services (redis, mongodb, postgres, mysql, elasticsearch)"
            echo "  --vectors     Start vector database services (qdrant, chroma)"
            echo "  --minimal     Start minimal services (redis, postgres, qdrant)"
            echo "  --stop        Stop all services"
            echo "  --status      Show service status"
            echo "  --logs        Show service logs"
            exit 1
            ;;
    esac
}

main "$@"

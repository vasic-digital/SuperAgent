// Package framework provides report generation for the challenges system.
package framework

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// MarkdownReporter generates Markdown reports from challenge results.
type MarkdownReporter struct {
	outputDir string
}

// NewMarkdownReporter creates a new Markdown reporter.
func NewMarkdownReporter(outputDir string) *MarkdownReporter {
	return &MarkdownReporter{outputDir: outputDir}
}

// GenerateReport creates a report for a single challenge result.
func (r *MarkdownReporter) GenerateReport(result *ChallengeResult) ([]byte, error) {
	var buf bytes.Buffer
	if err := r.WriteReport(&buf, result); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// WriteReport writes a report to the specified writer.
func (r *MarkdownReporter) WriteReport(w io.Writer, result *ChallengeResult) error {
	// Header
	fmt.Fprintf(w, "# Challenge Report: %s\n\n", result.ChallengeName)
	fmt.Fprintf(w, "**Challenge ID:** %s\n\n", result.ChallengeID)
	fmt.Fprintf(w, "**Generated:** %s\n\n", result.EndTime.Format(time.RFC3339))

	// Summary table
	fmt.Fprintln(w, "## Summary")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Metric | Value |")
	fmt.Fprintln(w, "|--------|-------|")
	fmt.Fprintf(w, "| Status | **%s** |\n", strings.ToUpper(result.Status))
	fmt.Fprintf(w, "| Start Time | %s |\n", result.StartTime.Format(time.RFC3339))
	fmt.Fprintf(w, "| End Time | %s |\n", result.EndTime.Format(time.RFC3339))
	fmt.Fprintf(w, "| Duration | %v |\n", result.Duration)

	if result.Error != "" {
		fmt.Fprintf(w, "| Error | %s |\n", result.Error)
	}

	// Metrics section
	if len(result.Metrics) > 0 {
		fmt.Fprintln(w)
		fmt.Fprintln(w, "## Metrics")
		fmt.Fprintln(w)
		fmt.Fprintln(w, "| Metric | Value | Unit |")
		fmt.Fprintln(w, "|--------|-------|------|")

		// Sort metrics by name
		var metricNames []string
		for name := range result.Metrics {
			metricNames = append(metricNames, name)
		}
		sort.Strings(metricNames)

		for _, name := range metricNames {
			m := result.Metrics[name]
			unit := m.Unit
			if unit == "" {
				unit = "-"
			}
			fmt.Fprintf(w, "| %s | %.2f | %s |\n", m.Name, m.Value, unit)
		}
	}

	// Assertions section
	if len(result.Assertions) > 0 {
		fmt.Fprintln(w)
		fmt.Fprintln(w, "## Assertions")
		fmt.Fprintln(w)
		fmt.Fprintln(w, "| Type | Target | Passed | Message |")
		fmt.Fprintln(w, "|------|--------|--------|---------|")

		passedCount := 0
		for _, a := range result.Assertions {
			passed := "No"
			if a.Passed {
				passed = "Yes"
				passedCount++
			}
			fmt.Fprintf(w, "| %s | %s | %s | %s |\n", a.Type, a.Target, passed, a.Message)
		}

		fmt.Fprintf(w, "\n**Pass Rate:** %d/%d (%.0f%%)\n",
			passedCount, len(result.Assertions),
			float64(passedCount)/float64(len(result.Assertions))*100)
	}

	// Outputs section
	if len(result.Outputs) > 0 {
		fmt.Fprintln(w)
		fmt.Fprintln(w, "## Output Files")
		fmt.Fprintln(w)
		fmt.Fprintln(w, "| Name | Path |")
		fmt.Fprintln(w, "|------|------|")

		for name, path := range result.Outputs {
			fmt.Fprintf(w, "| %s | `%s` |\n", name, path)
		}
	}

	// Logs section
	fmt.Fprintln(w)
	fmt.Fprintln(w, "## Log Files")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Log Type | Path |")
	fmt.Fprintln(w, "|----------|------|")
	fmt.Fprintf(w, "| Challenge Log | `%s` |\n", result.Logs.ChallengeLog)
	fmt.Fprintf(w, "| Output Log | `%s` |\n", result.Logs.OutputLog)
	if result.Logs.APIRequests != "" {
		fmt.Fprintf(w, "| API Requests | `%s` |\n", result.Logs.APIRequests)
	}
	if result.Logs.APIResponses != "" {
		fmt.Fprintf(w, "| API Responses | `%s` |\n", result.Logs.APIResponses)
	}

	// Footer
	fmt.Fprintln(w)
	fmt.Fprintln(w, "---")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "*Generated by HelixAgent Challenges*")

	return nil
}

// GenerateMasterSummary creates a summary of all challenge results.
func (r *MarkdownReporter) GenerateMasterSummary(results []*ChallengeResult) ([]byte, error) {
	var buf bytes.Buffer

	// Header
	fmt.Fprintln(&buf, "# HelixAgent Challenges - Master Summary")
	fmt.Fprintln(&buf)
	fmt.Fprintf(&buf, "**Generated:** %s\n\n", time.Now().Format(time.RFC3339))

	// Overview
	fmt.Fprintln(&buf, "## Overview")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "| Challenge | Status | Duration | Last Run |")
	fmt.Fprintln(&buf, "|-----------|--------|----------|----------|")

	passedCount := 0
	totalDuration := time.Duration(0)

	for _, result := range results {
		status := strings.ToUpper(result.Status)
		if result.Status == StatusPassed {
			passedCount++
		}
		totalDuration += result.Duration
		fmt.Fprintf(&buf, "| %s | %s | %v | %s |\n",
			result.ChallengeName,
			status,
			result.Duration,
			result.EndTime.Format("2006-01-02 15:04:05"))
	}

	// Summary stats
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "## Statistics")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "| Metric | Value |")
	fmt.Fprintln(&buf, "|--------|-------|")
	fmt.Fprintf(&buf, "| Total Challenges | %d |\n", len(results))
	fmt.Fprintf(&buf, "| Passed | %d |\n", passedCount)
	fmt.Fprintf(&buf, "| Failed | %d |\n", len(results)-passedCount)
	fmt.Fprintf(&buf, "| Pass Rate | %.0f%% |\n", float64(passedCount)/float64(len(results))*100)
	fmt.Fprintf(&buf, "| Total Duration | %v |\n", totalDuration)

	// Individual challenge details
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "## Challenge Details")
	fmt.Fprintln(&buf)

	for _, result := range results {
		fmt.Fprintf(&buf, "### %s\n\n", result.ChallengeName)
		fmt.Fprintf(&buf, "- **Status:** %s\n", strings.ToUpper(result.Status))
		fmt.Fprintf(&buf, "- **Duration:** %v\n", result.Duration)

		// Key metrics
		if len(result.Metrics) > 0 {
			fmt.Fprintln(&buf, "- **Key Metrics:**")
			for _, m := range result.Metrics {
				fmt.Fprintf(&buf, "  - %s: %.2f %s\n", m.Name, m.Value, m.Unit)
			}
		}

		// Assertion summary
		if len(result.Assertions) > 0 {
			passed := 0
			for _, a := range result.Assertions {
				if a.Passed {
					passed++
				}
			}
			fmt.Fprintf(&buf, "- **Assertions:** %d/%d passed\n", passed, len(result.Assertions))
		}

		if result.Error != "" {
			fmt.Fprintf(&buf, "- **Error:** %s\n", result.Error)
		}

		fmt.Fprintln(&buf)
	}

	// Footer
	fmt.Fprintln(&buf, "---")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "*Generated by HelixAgent Challenges*")

	return buf.Bytes(), nil
}

// SaveReport saves a report to a file.
func (r *MarkdownReporter) SaveReport(result *ChallengeResult, filename string) error {
	data, err := r.GenerateReport(result)
	if err != nil {
		return err
	}

	path := filepath.Join(r.outputDir, filename)
	return os.WriteFile(path, data, 0644)
}

// SaveMasterSummary saves the master summary to a file.
func (r *MarkdownReporter) SaveMasterSummary(results []*ChallengeResult, filename string) error {
	data, err := r.GenerateMasterSummary(results)
	if err != nil {
		return err
	}

	path := filepath.Join(r.outputDir, filename)
	return os.WriteFile(path, data, 0644)
}

// JSONReporter generates JSON reports.
type JSONReporter struct {
	outputDir string
	pretty    bool
}

// NewJSONReporter creates a new JSON reporter.
func NewJSONReporter(outputDir string, pretty bool) *JSONReporter {
	return &JSONReporter{outputDir: outputDir, pretty: pretty}
}

// GenerateReport creates a JSON report for a single challenge result.
func (r *JSONReporter) GenerateReport(result *ChallengeResult) ([]byte, error) {
	if r.pretty {
		return json.MarshalIndent(result, "", "  ")
	}
	return json.Marshal(result)
}

// GenerateMasterSummary creates a JSON summary of all challenge results.
func (r *JSONReporter) GenerateMasterSummary(results []*ChallengeResult) ([]byte, error) {
	summary := struct {
		GeneratedAt     time.Time          `json:"generated_at"`
		TotalChallenges int                `json:"total_challenges"`
		Passed          int                `json:"passed"`
		Failed          int                `json:"failed"`
		TotalDuration   time.Duration      `json:"total_duration"`
		Results         []*ChallengeResult `json:"results"`
	}{
		GeneratedAt:     time.Now(),
		TotalChallenges: len(results),
		Results:         results,
	}

	for _, r := range results {
		if r.Status == StatusPassed {
			summary.Passed++
		} else {
			summary.Failed++
		}
		summary.TotalDuration += r.Duration
	}

	if r.pretty {
		return json.MarshalIndent(summary, "", "  ")
	}
	return json.Marshal(summary)
}

// WriteReport writes a JSON report to the specified writer.
func (r *JSONReporter) WriteReport(w io.Writer, result *ChallengeResult) error {
	data, err := r.GenerateReport(result)
	if err != nil {
		return err
	}
	_, err = w.Write(data)
	return err
}

// SaveReport saves a JSON report to a file.
func (r *JSONReporter) SaveReport(result *ChallengeResult, filename string) error {
	data, err := r.GenerateReport(result)
	if err != nil {
		return err
	}

	path := filepath.Join(r.outputDir, filename)
	return os.WriteFile(path, data, 0644)
}

// MasterSummary represents an aggregated summary of all challenge runs.
type MasterSummary struct {
	ID                 string            `json:"id"`
	GeneratedAt        time.Time         `json:"generated_at"`
	Challenges         []ChallengeSummary `json:"challenges"`
	TotalChallenges    int               `json:"total_challenges"`
	PassedChallenges   int               `json:"passed_challenges"`
	FailedChallenges   int               `json:"failed_challenges"`
	TotalDuration      time.Duration     `json:"total_duration"`
	AveragePassRate    float64           `json:"average_pass_rate"`
	TopModels          []string          `json:"top_models,omitempty"`
	DebateGroupID      string            `json:"debate_group_id,omitempty"`
	APITestsRun        int               `json:"api_tests_run,omitempty"`
	APITestsPassed     int               `json:"api_tests_passed,omitempty"`
}

// ChallengeSummary represents a summary of a single challenge.
type ChallengeSummary struct {
	ChallengeID   ChallengeID   `json:"challenge_id"`
	ChallengeName string        `json:"challenge_name"`
	Status        string        `json:"status"`
	Duration      time.Duration `json:"duration"`
	AssertionsPassed int        `json:"assertions_passed"`
	AssertionsTotal  int        `json:"assertions_total"`
	ResultsPath   string        `json:"results_path"`
}

// BuildMasterSummary creates a master summary from challenge results.
func BuildMasterSummary(results []*ChallengeResult) *MasterSummary {
	summary := &MasterSummary{
		ID:          fmt.Sprintf("summary_%s", time.Now().Format("20060102_150405")),
		GeneratedAt: time.Now(),
		Challenges:  make([]ChallengeSummary, 0, len(results)),
	}

	for _, r := range results {
		assertionsPassed := 0
		for _, a := range r.Assertions {
			if a.Passed {
				assertionsPassed++
			}
		}

		cs := ChallengeSummary{
			ChallengeID:     r.ChallengeID,
			ChallengeName:   r.ChallengeName,
			Status:          r.Status,
			Duration:        r.Duration,
			AssertionsPassed: assertionsPassed,
			AssertionsTotal: len(r.Assertions),
		}

		summary.Challenges = append(summary.Challenges, cs)
		summary.TotalChallenges++
		summary.TotalDuration += r.Duration

		if r.Status == StatusPassed {
			summary.PassedChallenges++
		} else {
			summary.FailedChallenges++
		}
	}

	if summary.TotalChallenges > 0 {
		summary.AveragePassRate = float64(summary.PassedChallenges) / float64(summary.TotalChallenges)
	}

	return summary
}

// SaveMasterSummary saves the master summary to both JSON and Markdown files.
func SaveMasterSummary(summary *MasterSummary, outputDir string) error {
	// Ensure directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Save JSON version
	jsonPath := filepath.Join(outputDir, fmt.Sprintf("master_summary_%s.json", summary.GeneratedAt.Format("20060102_150405")))
	jsonData, err := json.MarshalIndent(summary, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal summary: %w", err)
	}
	if err := os.WriteFile(jsonPath, jsonData, 0644); err != nil {
		return fmt.Errorf("failed to write JSON summary: %w", err)
	}

	// Save Markdown version
	mdPath := filepath.Join(outputDir, fmt.Sprintf("master_summary_%s.md", summary.GeneratedAt.Format("20060102_150405")))
	mdContent := generateMasterSummaryMarkdown(summary)
	if err := os.WriteFile(mdPath, []byte(mdContent), 0644); err != nil {
		return fmt.Errorf("failed to write Markdown summary: %w", err)
	}

	// Update latest symlinks
	latestJSON := filepath.Join(outputDir, "latest_summary.json")
	latestMD := filepath.Join(outputDir, "latest_summary.md")

	_ = os.Remove(latestJSON)
	_ = os.Remove(latestMD)
	_ = os.Symlink(filepath.Base(jsonPath), latestJSON)
	_ = os.Symlink(filepath.Base(mdPath), latestMD)

	return nil
}

// generateMasterSummaryMarkdown creates markdown content from a master summary.
func generateMasterSummaryMarkdown(summary *MasterSummary) string {
	var sb strings.Builder

	sb.WriteString("# HelixAgent Challenges - Master Summary\n\n")
	sb.WriteString(fmt.Sprintf("**Summary ID:** %s\n\n", summary.ID))
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n\n", summary.GeneratedAt.Format(time.RFC3339)))

	// Overview table
	sb.WriteString("## Overview\n\n")
	sb.WriteString("| Challenge | Status | Duration | Assertions |\n")
	sb.WriteString("|-----------|--------|----------|------------|\n")

	for _, c := range summary.Challenges {
		status := strings.ToUpper(c.Status)
		assertions := fmt.Sprintf("%d/%d", c.AssertionsPassed, c.AssertionsTotal)
		sb.WriteString(fmt.Sprintf("| %s | %s | %v | %s |\n",
			c.ChallengeName, status, c.Duration, assertions))
	}

	// Statistics
	sb.WriteString("\n## Statistics\n\n")
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Total Challenges | %d |\n", summary.TotalChallenges))
	sb.WriteString(fmt.Sprintf("| Passed | %d |\n", summary.PassedChallenges))
	sb.WriteString(fmt.Sprintf("| Failed | %d |\n", summary.FailedChallenges))
	sb.WriteString(fmt.Sprintf("| Pass Rate | %.0f%% |\n", summary.AveragePassRate*100))
	sb.WriteString(fmt.Sprintf("| Total Duration | %v |\n", summary.TotalDuration))

	// Additional info
	if summary.DebateGroupID != "" {
		sb.WriteString(fmt.Sprintf("| Debate Group ID | %s |\n", summary.DebateGroupID))
	}
	if summary.APITestsRun > 0 {
		sb.WriteString(fmt.Sprintf("| API Tests | %d/%d passed |\n", summary.APITestsPassed, summary.APITestsRun))
	}
	if len(summary.TopModels) > 0 {
		sb.WriteString(fmt.Sprintf("| Top Models | %s |\n", strings.Join(summary.TopModels, ", ")))
	}

	sb.WriteString("\n---\n\n")
	sb.WriteString("*Generated by HelixAgent Challenges*\n")

	return sb.String()
}

// Historical tracking

// HistoricalEntry represents a single challenge run in history.
type HistoricalEntry struct {
	Timestamp       time.Time `json:"timestamp"`
	ChallengeID     string    `json:"challenge_id"`
	Status          string    `json:"status"`
	Duration        string    `json:"duration"`
	AssertionsPassed int      `json:"assertions_passed"`
	AssertionsTotal  int      `json:"assertions_total"`
	ResultsPath     string    `json:"results_path"`
}

// AppendToHistory adds an entry to the historical log.
func AppendToHistory(historyPath string, result *ChallengeResult, resultsPath string) error {
	assertionsPassed := 0
	for _, a := range result.Assertions {
		if a.Passed {
			assertionsPassed++
		}
	}

	entry := HistoricalEntry{
		Timestamp:       result.EndTime,
		ChallengeID:     string(result.ChallengeID),
		Status:          result.Status,
		Duration:        result.Duration.String(),
		AssertionsPassed: assertionsPassed,
		AssertionsTotal: len(result.Assertions),
		ResultsPath:     resultsPath,
	}

	data, err := json.Marshal(entry)
	if err != nil {
		return err
	}

	file, err := os.OpenFile(historyPath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()

	_, err = fmt.Fprintln(file, string(data))
	return err
}
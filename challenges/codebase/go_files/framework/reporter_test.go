package framework

import (
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func createTestResult() *ChallengeResult {
	return &ChallengeResult{
		ChallengeID:   "test_challenge",
		ChallengeName: "Test Challenge",
		Status:        StatusPassed,
		StartTime:     time.Date(2025, 1, 1, 10, 0, 0, 0, time.UTC),
		EndTime:       time.Date(2025, 1, 1, 10, 5, 0, 0, time.UTC),
		Duration:      5 * time.Minute,
		Assertions: []AssertionResult{
			{Type: "not_empty", Target: "response", Passed: true, Message: "Response is not empty"},
			{Type: "quality_score", Target: "response", Passed: true, Message: "Quality score met"},
			{Type: "not_mock", Target: "response", Passed: false, Message: "Response appears mocked"},
		},
		Metrics: map[string]MetricValue{
			"response_time": {Name: "Response Time", Value: 1500.0, Unit: "ms"},
			"quality_score": {Name: "Quality Score", Value: 0.85, Unit: ""},
		},
		Outputs: map[string]string{
			"response": "/tmp/response.json",
			"logs":     "/tmp/logs.txt",
		},
		Logs: LogPaths{
			ChallengeLog: "/tmp/challenge.log",
			OutputLog:    "/tmp/output.log",
			APIRequests:  "/tmp/api_requests.log",
			APIResponses: "/tmp/api_responses.log",
		},
	}
}

func TestMarkdownReporter_GenerateReport(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewMarkdownReporter(tmpDir)
	result := createTestResult()

	data, err := reporter.GenerateReport(result)
	if err != nil {
		t.Fatalf("GenerateReport failed: %v", err)
	}

	content := string(data)

	// Check header
	if !strings.Contains(content, "# Challenge Report: Test Challenge") {
		t.Error("Report should contain challenge name header")
	}

	// Check challenge ID
	if !strings.Contains(content, "test_challenge") {
		t.Error("Report should contain challenge ID")
	}

	// Check status
	if !strings.Contains(content, "PASSED") {
		t.Error("Report should contain status")
	}

	// Check metrics section
	if !strings.Contains(content, "## Metrics") {
		t.Error("Report should contain metrics section")
	}
	if !strings.Contains(content, "Response Time") {
		t.Error("Report should contain response time metric")
	}

	// Check assertions section
	if !strings.Contains(content, "## Assertions") {
		t.Error("Report should contain assertions section")
	}
	if !strings.Contains(content, "2/3") {
		t.Error("Report should show pass rate")
	}

	// Check output files section
	if !strings.Contains(content, "## Output Files") {
		t.Error("Report should contain output files section")
	}

	// Check log files section
	if !strings.Contains(content, "## Log Files") {
		t.Error("Report should contain log files section")
	}

	// Check footer
	if !strings.Contains(content, "Generated by SuperAgent Challenges") {
		t.Error("Report should contain footer")
	}
}

func TestMarkdownReporter_GenerateReport_WithError(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewMarkdownReporter(tmpDir)
	result := createTestResult()
	result.Status = StatusFailed
	result.Error = "Connection timeout"

	data, err := reporter.GenerateReport(result)
	if err != nil {
		t.Fatalf("GenerateReport failed: %v", err)
	}

	content := string(data)

	if !strings.Contains(content, "FAILED") {
		t.Error("Report should contain failed status")
	}
	if !strings.Contains(content, "Connection timeout") {
		t.Error("Report should contain error message")
	}
}

func TestMarkdownReporter_GenerateMasterSummary(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewMarkdownReporter(tmpDir)

	results := []*ChallengeResult{
		createTestResult(),
		{
			ChallengeID:   "second_challenge",
			ChallengeName: "Second Challenge",
			Status:        StatusFailed,
			StartTime:     time.Date(2025, 1, 1, 11, 0, 0, 0, time.UTC),
			EndTime:       time.Date(2025, 1, 1, 11, 2, 0, 0, time.UTC),
			Duration:      2 * time.Minute,
			Error:         "API error",
		},
	}

	data, err := reporter.GenerateMasterSummary(results)
	if err != nil {
		t.Fatalf("GenerateMasterSummary failed: %v", err)
	}

	content := string(data)

	// Check header
	if !strings.Contains(content, "# SuperAgent Challenges - Master Summary") {
		t.Error("Summary should contain header")
	}

	// Check overview
	if !strings.Contains(content, "## Overview") {
		t.Error("Summary should contain overview section")
	}

	// Check statistics
	if !strings.Contains(content, "## Statistics") {
		t.Error("Summary should contain statistics section")
	}
	if !strings.Contains(content, "Total Challenges | 2") {
		t.Error("Summary should show total challenges")
	}
	if !strings.Contains(content, "Passed | 1") {
		t.Error("Summary should show passed count")
	}
	if !strings.Contains(content, "Failed | 1") {
		t.Error("Summary should show failed count")
	}
	if !strings.Contains(content, "50%") {
		t.Error("Summary should show pass rate")
	}

	// Check challenge details
	if !strings.Contains(content, "## Challenge Details") {
		t.Error("Summary should contain challenge details section")
	}
	if !strings.Contains(content, "Test Challenge") {
		t.Error("Summary should include first challenge")
	}
	if !strings.Contains(content, "Second Challenge") {
		t.Error("Summary should include second challenge")
	}
}

func TestMarkdownReporter_SaveReport(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewMarkdownReporter(tmpDir)
	result := createTestResult()

	filename := "test_report.md"
	err := reporter.SaveReport(result, filename)
	if err != nil {
		t.Fatalf("SaveReport failed: %v", err)
	}

	// Verify file was created
	path := filepath.Join(tmpDir, filename)
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read saved report: %v", err)
	}

	if !strings.Contains(string(data), "Test Challenge") {
		t.Error("Saved report should contain challenge name")
	}
}

func TestMarkdownReporter_SaveMasterSummary(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewMarkdownReporter(tmpDir)

	results := []*ChallengeResult{createTestResult()}

	filename := "master_summary.md"
	err := reporter.SaveMasterSummary(results, filename)
	if err != nil {
		t.Fatalf("SaveMasterSummary failed: %v", err)
	}

	// Verify file was created
	path := filepath.Join(tmpDir, filename)
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read saved summary: %v", err)
	}

	if !strings.Contains(string(data), "Master Summary") {
		t.Error("Saved summary should contain header")
	}
}

func TestJSONReporter_GenerateReport(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewJSONReporter(tmpDir, false)
	result := createTestResult()

	data, err := reporter.GenerateReport(result)
	if err != nil {
		t.Fatalf("GenerateReport failed: %v", err)
	}

	// Parse JSON
	var parsed ChallengeResult
	if err := json.Unmarshal(data, &parsed); err != nil {
		t.Fatalf("Failed to parse JSON report: %v", err)
	}

	if parsed.ChallengeID != "test_challenge" {
		t.Errorf("Challenge ID mismatch: got %s, want test_challenge", parsed.ChallengeID)
	}
	if parsed.Status != StatusPassed {
		t.Errorf("Status mismatch: got %s, want %s", parsed.Status, StatusPassed)
	}
}

func TestJSONReporter_GenerateReport_Pretty(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewJSONReporter(tmpDir, true)
	result := createTestResult()

	data, err := reporter.GenerateReport(result)
	if err != nil {
		t.Fatalf("GenerateReport failed: %v", err)
	}

	// Pretty JSON should have indentation
	if !strings.Contains(string(data), "\n  ") {
		t.Error("Pretty JSON should be indented")
	}
}

func TestJSONReporter_GenerateMasterSummary(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewJSONReporter(tmpDir, true)

	results := []*ChallengeResult{
		createTestResult(),
		{
			ChallengeID:   "second_challenge",
			ChallengeName: "Second Challenge",
			Status:        StatusFailed,
			Duration:      2 * time.Minute,
		},
	}

	data, err := reporter.GenerateMasterSummary(results)
	if err != nil {
		t.Fatalf("GenerateMasterSummary failed: %v", err)
	}

	// Parse JSON
	var summary struct {
		TotalChallenges int `json:"total_challenges"`
		Passed          int `json:"passed"`
		Failed          int `json:"failed"`
	}
	if err := json.Unmarshal(data, &summary); err != nil {
		t.Fatalf("Failed to parse JSON summary: %v", err)
	}

	if summary.TotalChallenges != 2 {
		t.Errorf("Total challenges mismatch: got %d, want 2", summary.TotalChallenges)
	}
	if summary.Passed != 1 {
		t.Errorf("Passed mismatch: got %d, want 1", summary.Passed)
	}
	if summary.Failed != 1 {
		t.Errorf("Failed mismatch: got %d, want 1", summary.Failed)
	}
}

func TestJSONReporter_SaveReport(t *testing.T) {
	tmpDir := t.TempDir()
	reporter := NewJSONReporter(tmpDir, false)
	result := createTestResult()

	filename := "test_report.json"
	err := reporter.SaveReport(result, filename)
	if err != nil {
		t.Fatalf("SaveReport failed: %v", err)
	}

	// Verify file was created and is valid JSON
	path := filepath.Join(tmpDir, filename)
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read saved report: %v", err)
	}

	var parsed ChallengeResult
	if err := json.Unmarshal(data, &parsed); err != nil {
		t.Fatalf("Saved report is not valid JSON: %v", err)
	}
}

func TestBuildMasterSummary(t *testing.T) {
	results := []*ChallengeResult{
		{
			ChallengeID:   "challenge_1",
			ChallengeName: "Challenge One",
			Status:        StatusPassed,
			Duration:      3 * time.Minute,
			Assertions: []AssertionResult{
				{Passed: true},
				{Passed: true},
				{Passed: false},
			},
		},
		{
			ChallengeID:   "challenge_2",
			ChallengeName: "Challenge Two",
			Status:        StatusFailed,
			Duration:      2 * time.Minute,
			Assertions: []AssertionResult{
				{Passed: false},
				{Passed: false},
			},
		},
		{
			ChallengeID:   "challenge_3",
			ChallengeName: "Challenge Three",
			Status:        StatusPassed,
			Duration:      1 * time.Minute,
			Assertions: []AssertionResult{
				{Passed: true},
			},
		},
	}

	summary := BuildMasterSummary(results)

	// Check totals
	if summary.TotalChallenges != 3 {
		t.Errorf("TotalChallenges = %d, want 3", summary.TotalChallenges)
	}
	if summary.PassedChallenges != 2 {
		t.Errorf("PassedChallenges = %d, want 2", summary.PassedChallenges)
	}
	if summary.FailedChallenges != 1 {
		t.Errorf("FailedChallenges = %d, want 1", summary.FailedChallenges)
	}

	// Check duration
	expectedDuration := 6 * time.Minute
	if summary.TotalDuration != expectedDuration {
		t.Errorf("TotalDuration = %v, want %v", summary.TotalDuration, expectedDuration)
	}

	// Check pass rate
	expectedPassRate := 2.0 / 3.0
	if summary.AveragePassRate != expectedPassRate {
		t.Errorf("AveragePassRate = %f, want %f", summary.AveragePassRate, expectedPassRate)
	}

	// Check challenges
	if len(summary.Challenges) != 3 {
		t.Errorf("Challenges count = %d, want 3", len(summary.Challenges))
	}

	// Check first challenge assertions
	if summary.Challenges[0].AssertionsPassed != 2 {
		t.Errorf("Challenge 1 AssertionsPassed = %d, want 2", summary.Challenges[0].AssertionsPassed)
	}
	if summary.Challenges[0].AssertionsTotal != 3 {
		t.Errorf("Challenge 1 AssertionsTotal = %d, want 3", summary.Challenges[0].AssertionsTotal)
	}

	// Check ID format
	if !strings.HasPrefix(summary.ID, "summary_") {
		t.Errorf("ID should start with 'summary_', got %s", summary.ID)
	}
}

func TestBuildMasterSummary_Empty(t *testing.T) {
	summary := BuildMasterSummary([]*ChallengeResult{})

	if summary.TotalChallenges != 0 {
		t.Errorf("TotalChallenges = %d, want 0", summary.TotalChallenges)
	}
	if summary.AveragePassRate != 0 {
		t.Errorf("AveragePassRate should be 0 for empty results")
	}
}

func TestSaveMasterSummary(t *testing.T) {
	tmpDir := t.TempDir()

	summary := &MasterSummary{
		ID:               "test_summary",
		GeneratedAt:      time.Date(2025, 1, 1, 12, 0, 0, 0, time.UTC),
		TotalChallenges:  2,
		PassedChallenges: 1,
		FailedChallenges: 1,
		AveragePassRate:  0.5,
		TotalDuration:    5 * time.Minute,
		Challenges: []ChallengeSummary{
			{
				ChallengeID:     "ch1",
				ChallengeName:   "Challenge One",
				Status:          StatusPassed,
				Duration:        3 * time.Minute,
				AssertionsPassed: 5,
				AssertionsTotal: 5,
			},
		},
	}

	err := SaveMasterSummary(summary, tmpDir)
	if err != nil {
		t.Fatalf("SaveMasterSummary failed: %v", err)
	}

	// Check JSON file was created
	jsonPath := filepath.Join(tmpDir, "master_summary_20250101_120000.json")
	if _, err := os.Stat(jsonPath); os.IsNotExist(err) {
		t.Error("JSON summary file was not created")
	}

	// Check Markdown file was created
	mdPath := filepath.Join(tmpDir, "master_summary_20250101_120000.md")
	if _, err := os.Stat(mdPath); os.IsNotExist(err) {
		t.Error("Markdown summary file was not created")
	}

	// Check symlinks were created
	latestJSON := filepath.Join(tmpDir, "latest_summary.json")
	latestMD := filepath.Join(tmpDir, "latest_summary.md")

	// On some systems symlinks might not be fully supported, so just check if they exist
	if _, err := os.Lstat(latestJSON); os.IsNotExist(err) {
		t.Error("latest_summary.json symlink was not created")
	}
	if _, err := os.Lstat(latestMD); os.IsNotExist(err) {
		t.Error("latest_summary.md symlink was not created")
	}

	// Verify JSON content
	jsonData, err := os.ReadFile(jsonPath)
	if err != nil {
		t.Fatalf("Failed to read JSON summary: %v", err)
	}

	var parsed MasterSummary
	if err := json.Unmarshal(jsonData, &parsed); err != nil {
		t.Fatalf("Failed to parse JSON summary: %v", err)
	}

	if parsed.TotalChallenges != 2 {
		t.Errorf("TotalChallenges = %d, want 2", parsed.TotalChallenges)
	}

	// Verify Markdown content
	mdData, err := os.ReadFile(mdPath)
	if err != nil {
		t.Fatalf("Failed to read Markdown summary: %v", err)
	}

	mdContent := string(mdData)
	if !strings.Contains(mdContent, "Master Summary") {
		t.Error("Markdown should contain header")
	}
	if !strings.Contains(mdContent, "Challenge One") {
		t.Error("Markdown should contain challenge name")
	}
	if !strings.Contains(mdContent, "50%") {
		t.Error("Markdown should contain pass rate")
	}
}

func TestAppendToHistory(t *testing.T) {
	tmpDir := t.TempDir()
	historyPath := filepath.Join(tmpDir, "history.jsonl")

	result := createTestResult()

	// Append first entry
	err := AppendToHistory(historyPath, result, "/results/run1")
	if err != nil {
		t.Fatalf("AppendToHistory failed: %v", err)
	}

	// Append second entry
	result2 := &ChallengeResult{
		ChallengeID:   "second_challenge",
		ChallengeName: "Second Challenge",
		Status:        StatusFailed,
		EndTime:       time.Date(2025, 1, 2, 10, 0, 0, 0, time.UTC),
		Duration:      1 * time.Minute,
		Assertions: []AssertionResult{
			{Passed: false},
		},
	}
	err = AppendToHistory(historyPath, result2, "/results/run2")
	if err != nil {
		t.Fatalf("AppendToHistory failed for second entry: %v", err)
	}

	// Read and verify
	data, err := os.ReadFile(historyPath)
	if err != nil {
		t.Fatalf("Failed to read history file: %v", err)
	}

	lines := strings.Split(strings.TrimSpace(string(data)), "\n")
	if len(lines) != 2 {
		t.Errorf("Expected 2 history entries, got %d", len(lines))
	}

	// Parse first entry
	var entry1 HistoricalEntry
	if err := json.Unmarshal([]byte(lines[0]), &entry1); err != nil {
		t.Fatalf("Failed to parse first history entry: %v", err)
	}

	if entry1.ChallengeID != "test_challenge" {
		t.Errorf("Entry 1 ChallengeID = %s, want test_challenge", entry1.ChallengeID)
	}
	if entry1.Status != StatusPassed {
		t.Errorf("Entry 1 Status = %s, want %s", entry1.Status, StatusPassed)
	}
	if entry1.AssertionsPassed != 2 {
		t.Errorf("Entry 1 AssertionsPassed = %d, want 2", entry1.AssertionsPassed)
	}
	if entry1.AssertionsTotal != 3 {
		t.Errorf("Entry 1 AssertionsTotal = %d, want 3", entry1.AssertionsTotal)
	}
	if entry1.ResultsPath != "/results/run1" {
		t.Errorf("Entry 1 ResultsPath = %s, want /results/run1", entry1.ResultsPath)
	}

	// Parse second entry
	var entry2 HistoricalEntry
	if err := json.Unmarshal([]byte(lines[1]), &entry2); err != nil {
		t.Fatalf("Failed to parse second history entry: %v", err)
	}

	if entry2.ChallengeID != "second_challenge" {
		t.Errorf("Entry 2 ChallengeID = %s, want second_challenge", entry2.ChallengeID)
	}
	if entry2.Status != StatusFailed {
		t.Errorf("Entry 2 Status = %s, want %s", entry2.Status, StatusFailed)
	}
}

func TestGenerateMasterSummaryMarkdown_WithOptionalFields(t *testing.T) {
	summary := &MasterSummary{
		ID:               "full_summary",
		GeneratedAt:      time.Now(),
		TotalChallenges:  3,
		PassedChallenges: 2,
		FailedChallenges: 1,
		AveragePassRate:  0.67,
		TotalDuration:    10 * time.Minute,
		DebateGroupID:    "debate_group_123",
		APITestsRun:      50,
		APITestsPassed:   45,
		TopModels:        []string{"claude-3-opus", "gpt-4", "gemini-pro"},
		Challenges: []ChallengeSummary{
			{ChallengeName: "Challenge 1", Status: StatusPassed},
		},
	}

	tmpDir := t.TempDir()
	err := SaveMasterSummary(summary, tmpDir)
	if err != nil {
		t.Fatalf("SaveMasterSummary failed: %v", err)
	}

	// Find and read the markdown file
	files, _ := os.ReadDir(tmpDir)
	var mdPath string
	for _, f := range files {
		if strings.HasSuffix(f.Name(), ".md") && !strings.HasPrefix(f.Name(), "latest") {
			mdPath = filepath.Join(tmpDir, f.Name())
			break
		}
	}

	data, err := os.ReadFile(mdPath)
	if err != nil {
		t.Fatalf("Failed to read markdown: %v", err)
	}

	content := string(data)

	// Check optional fields are present
	if !strings.Contains(content, "debate_group_123") {
		t.Error("Markdown should contain debate group ID")
	}
	if !strings.Contains(content, "45/50") {
		t.Error("Markdown should contain API tests info")
	}
	if !strings.Contains(content, "claude-3-opus") {
		t.Error("Markdown should contain top models")
	}
}


<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>services: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/superagent/superagent/internal/services/acp_client.go (61.1%)</option>
				
				<option value="file1">github.com/superagent/superagent/internal/services/acp_manager.go (91.1%)</option>
				
				<option value="file2">github.com/superagent/superagent/internal/services/advanced_debate_service.go (72.0%)</option>
				
				<option value="file3">github.com/superagent/superagent/internal/services/cache_factory.go (81.2%)</option>
				
				<option value="file4">github.com/superagent/superagent/internal/services/context_manager.go (90.2%)</option>
				
				<option value="file5">github.com/superagent/superagent/internal/services/debate_history_service.go (100.0%)</option>
				
				<option value="file6">github.com/superagent/superagent/internal/services/debate_monitoring_service.go (100.0%)</option>
				
				<option value="file7">github.com/superagent/superagent/internal/services/debate_performance_service.go (100.0%)</option>
				
				<option value="file8">github.com/superagent/superagent/internal/services/debate_reporting_service.go (100.0%)</option>
				
				<option value="file9">github.com/superagent/superagent/internal/services/debate_resilience_service.go (100.0%)</option>
				
				<option value="file10">github.com/superagent/superagent/internal/services/debate_security_service.go (100.0%)</option>
				
				<option value="file11">github.com/superagent/superagent/internal/services/debate_service.go (100.0%)</option>
				
				<option value="file12">github.com/superagent/superagent/internal/services/debate_types.go (100.0%)</option>
				
				<option value="file13">github.com/superagent/superagent/internal/services/embedding_manager.go (88.8%)</option>
				
				<option value="file14">github.com/superagent/superagent/internal/services/ensemble.go (92.3%)</option>
				
				<option value="file15">github.com/superagent/superagent/internal/services/high_availability.go (96.2%)</option>
				
				<option value="file16">github.com/superagent/superagent/internal/services/integration_orchestrator.go (76.0%)</option>
				
				<option value="file17">github.com/superagent/superagent/internal/services/lsp_manager.go (83.8%)</option>
				
				<option value="file18">github.com/superagent/superagent/internal/services/mcp_client.go (68.0%)</option>
				
				<option value="file19">github.com/superagent/superagent/internal/services/mcp_manager.go (85.7%)</option>
				
				<option value="file20">github.com/superagent/superagent/internal/services/memory_service.go (59.8%)</option>
				
				<option value="file21">github.com/superagent/superagent/internal/services/model_metadata_redis_cache.go (1.0%)</option>
				
				<option value="file22">github.com/superagent/superagent/internal/services/model_metadata_service.go (19.6%)</option>
				
				<option value="file23">github.com/superagent/superagent/internal/services/plugin_system.go (96.1%)</option>
				
				<option value="file24">github.com/superagent/superagent/internal/services/protocol_analytics.go (96.0%)</option>
				
				<option value="file25">github.com/superagent/superagent/internal/services/protocol_cache.go (98.8%)</option>
				
				<option value="file26">github.com/superagent/superagent/internal/services/protocol_cache_manager.go (0.0%)</option>
				
				<option value="file27">github.com/superagent/superagent/internal/services/protocol_discovery.go (59.4%)</option>
				
				<option value="file28">github.com/superagent/superagent/internal/services/protocol_federation.go (0.0%)</option>
				
				<option value="file29">github.com/superagent/superagent/internal/services/protocol_monitor.go (72.7%)</option>
				
				<option value="file30">github.com/superagent/superagent/internal/services/protocol_plugin_system.go (72.6%)</option>
				
				<option value="file31">github.com/superagent/superagent/internal/services/protocol_security.go (95.8%)</option>
				
				<option value="file32">github.com/superagent/superagent/internal/services/provider_metadata_service.go (89.4%)</option>
				
				<option value="file33">github.com/superagent/superagent/internal/services/provider_registry.go (83.1%)</option>
				
				<option value="file34">github.com/superagent/superagent/internal/services/request_service.go (66.0%)</option>
				
				<option value="file35">github.com/superagent/superagent/internal/services/security_sandbox.go (84.3%)</option>
				
				<option value="file36">github.com/superagent/superagent/internal/services/tool_registry.go (90.9%)</option>
				
				<option value="file37">github.com/superagent/superagent/internal/services/unified_protocol_manager.go (77.9%)</option>
				
				<option value="file38">github.com/superagent/superagent/internal/services/user_service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package services

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os/exec"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/models"
)

// LSPClient implements a real Language Server Protocol client
type LSPClient struct {
        servers      map[string]*LSPServerConnection
        capabilities map[string]*LSPCapabilities
        messageID    int
        mu           sync.RWMutex
        logger       *logrus.Logger
}

// LSPServerConnection represents a live connection to an LSP server
type LSPServerConnection struct {
        ID           string
        Name         string
        Language     string
        Transport    LSPTransport
        Capabilities *LSPCapabilities
        Workspace    string
        Connected    bool
        LastUsed     time.Time
        Files        map[string]*LSPFileInfo // URI -&gt; file info
}

// LSPTransport defines the interface for LSP communication
type LSPTransport interface {
        Send(ctx context.Context, message interface{}) error
        Receive(ctx context.Context) (interface{}, error)
        Close() error
        IsConnected() bool
}

// StdioLSPTransport implements LSP transport over stdio
type StdioLSPTransport struct {
        cmd       *exec.Cmd
        stdin     io.WriteCloser
        stdout    io.ReadCloser
        scanner   *bufio.Scanner
        connected bool
        mu        sync.Mutex
}

// LSPMessage represents a JSON-RPC message for LSP
type LSPMessage struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
        Result  interface{} `json:"result,omitempty"`
        Error   *LSPError   `json:"error,omitempty"`
}

// LSPError represents an LSP error
type LSPError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// LSPCapabilities represents LSP server capabilities
type LSPCapabilities struct {
        TextDocumentSync                *TextDocumentSyncOptions `json:"textDocumentSync,omitempty"`
        CompletionProvider              *CompletionOptions       `json:"completionProvider,omitempty"`
        HoverProvider                   bool                     `json:"hoverProvider,omitempty"`
        SignatureHelpProvider           *SignatureHelpOptions    `json:"signatureHelpProvider,omitempty"`
        DefinitionProvider              bool                     `json:"definitionProvider,omitempty"`
        TypeDefinitionProvider          bool                     `json:"typeDefinitionProvider,omitempty"`
        ReferencesProvider              bool                     `json:"referencesProvider,omitempty"`
        DocumentSymbolProvider          bool                     `json:"documentSymbolProvider,omitempty"`
        CodeActionProvider              bool                     `json:"codeActionProvider,omitempty"`
        CodeLensProvider                *CodeLensOptions         `json:"codeLensProvider,omitempty"`
        DocumentFormattingProvider      bool                     `json:"documentFormattingProvider,omitempty"`
        DocumentRangeFormattingProvider bool                     `json:"documentRangeFormattingProvider,omitempty"`
        RenameProvider                  bool                     `json:"renameProvider,omitempty"`
}

// LSPFileInfo represents information about a file being edited
type LSPFileInfo struct {
        URI        string
        LanguageID string
        Version    int
        Content    string
        LastSync   time.Time
}

// LSP request/response types
type InitializeRequest struct {
        ProcessID    *int               `json:"processId,omitempty"`
        RootURI      string             `json:"rootUri,omitempty"`
        Capabilities ClientCapabilities `json:"capabilities"`
}

type ClientCapabilities struct {
        TextDocument TextDocumentClientCapabilities `json:"textDocument,omitempty"`
}

type TextDocumentClientCapabilities struct {
        Completion CompletionCapability `json:"completion,omitempty"`
}

type CompletionCapability struct {
        DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

type InitializeResult struct {
        Capabilities LSPCapabilities `json:"capabilities"`
}

type TextDocumentSyncOptions struct {
        OpenClose bool `json:"openClose,omitempty"`
        Change    int  `json:"change,omitempty"`
}

type CompletionOptions struct {
        ResolveProvider   bool     `json:"resolveProvider,omitempty"`
        TriggerCharacters []string `json:"triggerCharacters,omitempty"`
}

type SignatureHelpOptions struct {
        TriggerCharacters []string `json:"triggerCharacters,omitempty"`
}

type CodeLensOptions struct {
        ResolveProvider bool `json:"resolveProvider,omitempty"`
}

// LSP operation request types
type DidOpenTextDocumentParams struct {
        TextDocument TextDocumentItem `json:"textDocument"`
}

type DidChangeTextDocumentParams struct {
        TextDocument   VersionedTextDocumentIdentifier  `json:"textDocument"`
        ContentChanges []TextDocumentContentChangeEvent `json:"contentChanges"`
}

type CompletionParams struct {
        TextDocument TextDocumentIdentifier `json:"textDocument"`
        Position     Position               `json:"position"`
}

type HoverParams struct {
        TextDocument TextDocumentIdentifier `json:"textDocument"`
        Position     Position               `json:"position"`
}

type DefinitionParams struct {
        TextDocument TextDocumentIdentifier `json:"textDocument"`
        Position     Position               `json:"position"`
}

// Common LSP types
type TextDocumentItem struct {
        URI        string `json:"uri"`
        LanguageID string `json:"languageId"`
        Version    int    `json:"version"`
        Text       string `json:"text"`
}

type VersionedTextDocumentIdentifier struct {
        URI     string `json:"uri"`
        Version int    `json:"version"`
}

type TextDocumentIdentifier struct {
        URI string `json:"uri"`
}

type TextDocumentContentChangeEvent struct {
        Range       *Range `json:"range,omitempty"`
        RangeLength *int   `json:"rangeLength,omitempty"`
        Text        string `json:"text"`
}

type Position struct {
        Line      int `json:"line"`
        Character int `json:"character"`
}

type Range struct {
        Start Position `json:"start"`
        End   Position `json:"end"`
}

// LSP response types
type CompletionList struct {
        IsIncomplete bool             `json:"isIncomplete"`
        Items        []CompletionItem `json:"items"`
}

type CompletionItem struct {
        Label         string `json:"label"`
        Kind          int    `json:"kind,omitempty"`
        Detail        string `json:"detail,omitempty"`
        Documentation string `json:"documentation,omitempty"`
}

type Hover struct {
        Contents MarkupContent `json:"contents"`
        Range    *Range        `json:"range,omitempty"`
}

type MarkupContent struct {
        Kind  string `json:"kind"`
        Value string `json:"value"`
}

type Location struct {
        URI   string `json:"uri"`
        Range Range  `json:"range"`
}

// NewLSPClient creates a new LSP client
func NewLSPClient(logger *logrus.Logger) *LSPClient <span class="cov10" title="38">{
        return &amp;LSPClient{
                servers:      make(map[string]*LSPServerConnection),
                capabilities: make(map[string]*LSPCapabilities),
                messageID:    1,
                logger:       logger,
        }
}</span>

// ConnectServer connects to an LSP server
func (c *LSPClient) ConnectServer(ctx context.Context, serverID, name, language, command string, args []string, workspace string) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, exists := c.servers[serverID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("LSP server %s already connected", serverID)
        }</span>

        // Create transport
        <span class="cov0" title="0">transport, err := c.createStdioTransport(command, args)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create transport: %w", err)
        }</span>

        <span class="cov0" title="0">connection := &amp;LSPServerConnection{
                ID:        serverID,
                Name:      name,
                Language:  language,
                Transport: transport,
                Workspace: workspace,
                Connected: true,
                LastUsed:  time.Now(),
                Files:     make(map[string]*LSPFileInfo),
        }

        // Initialize the server
        if err := c.initializeServer(ctx, connection); err != nil </span><span class="cov0" title="0">{
                transport.Close()
                return fmt.Errorf("failed to initialize LSP server: %w", err)
        }</span>

        <span class="cov0" title="0">c.servers[serverID] = connection
        c.logger.WithFields(logrus.Fields{
                "serverId": serverID,
                "language": language,
        }).Info("Connected to LSP server")

        return nil</span>
}

// DisconnectServer disconnects from an LSP server
func (c *LSPClient) DisconnectServer(serverID string) error <span class="cov2" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        connection, exists := c.servers[serverID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        // Send shutdown request
        <span class="cov1" title="1">shutdownReq := LSPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "shutdown",
                Params:  nil,
        }

        if err := connection.Transport.Send(context.Background(), shutdownReq); err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).Warn("Failed to send shutdown request")
        }</span>

        // Send exit notification
        <span class="cov1" title="1">exitNotification := LSPMessage{
                JSONRPC: "2.0",
                Method:  "exit",
                Params:  nil,
        }

        connection.Transport.Send(context.Background(), exitNotification)

        if err := connection.Transport.Close(); err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).Warn("Error closing LSP transport")
        }</span>

        <span class="cov1" title="1">delete(c.servers, serverID)

        c.logger.WithField("serverId", serverID).Info("Disconnected from LSP server")
        return nil</span>
}

// OpenFile opens a file for LSP operations
func (c *LSPClient) OpenFile(ctx context.Context, serverID, uri, languageID, content string) error <span class="cov4" title="4">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov3" title="3">{
                return fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        // Store file info
        <span class="cov1" title="1">fileInfo := &amp;LSPFileInfo{
                URI:        uri,
                LanguageID: languageID,
                Version:    1,
                Content:    content,
                LastSync:   time.Now(),
        }
        connection.Files[uri] = fileInfo

        // Send didOpen notification
        didOpenParams := DidOpenTextDocumentParams{
                TextDocument: TextDocumentItem{
                        URI:        uri,
                        LanguageID: languageID,
                        Version:    1,
                        Text:       content,
                },
        }

        didOpenMsg := LSPMessage{
                JSONRPC: "2.0",
                Method:  "textDocument/didOpen",
                Params:  didOpenParams,
        }

        if err := connection.Transport.Send(ctx, didOpenMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send didOpen notification: %w", err)
        }</span>

        <span class="cov1" title="1">connection.LastUsed = time.Now()
        return nil</span>
}

// UpdateFile updates file content
func (c *LSPClient) UpdateFile(ctx context.Context, serverID, uri, content string) error <span class="cov3" title="3">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        <span class="cov2" title="2">fileInfo, exists := connection.Files[uri]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("file %s not opened", uri)
        }</span>

        <span class="cov1" title="1">fileInfo.Version++
        fileInfo.Content = content
        fileInfo.LastSync = time.Now()

        // Send didChange notification
        didChangeParams := DidChangeTextDocumentParams{
                TextDocument: VersionedTextDocumentIdentifier{
                        URI:     uri,
                        Version: fileInfo.Version,
                },
                ContentChanges: []TextDocumentContentChangeEvent{
                        {
                                Text: content,
                        },
                },
        }

        didChangeMsg := LSPMessage{
                JSONRPC: "2.0",
                Method:  "textDocument/didChange",
                Params:  didChangeParams,
        }

        if err := connection.Transport.Send(ctx, didChangeMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send didChange notification: %w", err)
        }</span>

        <span class="cov1" title="1">connection.LastUsed = time.Now()
        return nil</span>
}

// CloseFile closes a file
func (c *LSPClient) CloseFile(ctx context.Context, serverID, uri string) error <span class="cov2" title="2">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        <span class="cov1" title="1">if _, exists := connection.Files[uri]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("file %s not opened", uri)
        }</span>

        <span class="cov1" title="1">delete(connection.Files, uri)

        // Send didClose notification
        didCloseParams := map[string]interface{}{
                "textDocument": TextDocumentIdentifier{URI: uri},
        }

        didCloseMsg := LSPMessage{
                JSONRPC: "2.0",
                Method:  "textDocument/didClose",
                Params:  didCloseParams,
        }

        if err := connection.Transport.Send(ctx, didCloseMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send didClose notification: %w", err)
        }</span>

        <span class="cov1" title="1">connection.LastUsed = time.Now()
        return nil</span>
}

// GetCompletion requests completion at a position
func (c *LSPClient) GetCompletion(ctx context.Context, serverID, uri string, line, character int) (*CompletionList, error) <span class="cov4" title="4">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        <span class="cov3" title="3">if connection.Capabilities.CompletionProvider == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("server does not support completion")
        }</span>

        <span class="cov2" title="2">completionParams := CompletionParams{
                TextDocument: TextDocumentIdentifier{URI: uri},
                Position:     Position{Line: line, Character: character},
        }

        completionReq := LSPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "textDocument/completion",
                Params:  completionParams,
        }

        if err := connection.Transport.Send(ctx, completionReq); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send completion request: %w", err)
        }</span>

        <span class="cov2" title="2">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive completion response: %w", err)
        }</span>

        <span class="cov2" title="2">var completionMsg LSPMessage
        if err := c.unmarshalMessage(response, &amp;completionMsg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal completion response: %w", err)
        }</span>

        <span class="cov2" title="2">if completionMsg.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("completion error: %s", completionMsg.Error.Message)
        }</span>

        <span class="cov2" title="2">var completionList CompletionList
        if err := c.unmarshalResult(completionMsg.Result, &amp;completionList); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal completion result: %w", err)
        }</span>

        <span class="cov2" title="2">connection.LastUsed = time.Now()
        return &amp;completionList, nil</span>
}

// GetHover requests hover information at a position
func (c *LSPClient) GetHover(ctx context.Context, serverID, uri string, line, character int) (*Hover, error) <span class="cov3" title="3">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        <span class="cov2" title="2">if !connection.Capabilities.HoverProvider </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("server does not support hover")
        }</span>

        <span class="cov1" title="1">hoverParams := HoverParams{
                TextDocument: TextDocumentIdentifier{URI: uri},
                Position:     Position{Line: line, Character: character},
        }

        hoverReq := LSPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "textDocument/hover",
                Params:  hoverParams,
        }

        if err := connection.Transport.Send(ctx, hoverReq); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send hover request: %w", err)
        }</span>

        <span class="cov1" title="1">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive hover response: %w", err)
        }</span>

        <span class="cov1" title="1">var hoverMsg LSPMessage
        if err := c.unmarshalMessage(response, &amp;hoverMsg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal hover response: %w", err)
        }</span>

        <span class="cov1" title="1">if hoverMsg.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("hover error: %s", hoverMsg.Error.Message)
        }</span>

        <span class="cov1" title="1">var hover Hover
        if err := c.unmarshalResult(hoverMsg.Result, &amp;hover); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal hover result: %w", err)
        }</span>

        <span class="cov1" title="1">connection.LastUsed = time.Now()
        return &amp;hover, nil</span>
}

// GetDefinition finds the definition of a symbol
func (c *LSPClient) GetDefinition(ctx context.Context, serverID, uri string, line, character int) (*Location, error) <span class="cov3" title="3">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        <span class="cov2" title="2">if !connection.Capabilities.DefinitionProvider </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("server does not support definition")
        }</span>

        <span class="cov1" title="1">definitionParams := DefinitionParams{
                TextDocument: TextDocumentIdentifier{URI: uri},
                Position:     Position{Line: line, Character: character},
        }

        definitionReq := LSPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "textDocument/definition",
                Params:  definitionParams,
        }

        if err := connection.Transport.Send(ctx, definitionReq); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send definition request: %w", err)
        }</span>

        <span class="cov1" title="1">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive definition response: %w", err)
        }</span>

        <span class="cov1" title="1">var definitionMsg LSPMessage
        if err := c.unmarshalMessage(response, &amp;definitionMsg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal definition response: %w", err)
        }</span>

        <span class="cov1" title="1">if definitionMsg.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("definition error: %s", definitionMsg.Error.Message)
        }</span>

        <span class="cov1" title="1">var location Location
        if err := c.unmarshalResult(definitionMsg.Result, &amp;location); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal definition result: %w", err)
        }</span>

        <span class="cov1" title="1">connection.LastUsed = time.Now()
        return &amp;location, nil</span>
}

// ListServers returns all connected LSP servers
func (c *LSPClient) ListServers() []*LSPServerConnection <span class="cov4" title="5">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        servers := make([]*LSPServerConnection, 0, len(c.servers))
        for _, server := range c.servers </span><span class="cov3" title="3">{
                servers = append(servers, server)
        }</span>

        <span class="cov4" title="5">return servers</span>
}

// GetServerCapabilities returns capabilities for a server
func (c *LSPClient) GetServerCapabilities(serverID string) (*LSPCapabilities, error) <span class="cov2" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        connection, exists := c.servers[serverID]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LSP server %s not connected", serverID)
        }</span>

        <span class="cov1" title="1">return connection.Capabilities, nil</span>
}

// HealthCheck performs health checks on all connected servers
func (c *LSPClient) HealthCheck(ctx context.Context) map[string]bool <span class="cov2" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        results := make(map[string]bool)
        for serverID, connection := range c.servers </span><span class="cov1" title="1">{
                results[serverID] = connection.Transport.IsConnected()
        }</span>

        <span class="cov2" title="2">return results</span>
}

// StartServer starts a default LSP server (for integration orchestrator)
func (c *LSPClient) StartServer(ctx context.Context) error <span class="cov1" title="1">{
        // Start a default Go LSP server
        return c.ConnectServer(ctx, "default-go", "gopls", "go", "gopls", []string{}, "/tmp")
}</span>

// GetDiagnostics provides diagnostics for a file
func (c *LSPClient) GetDiagnostics(ctx context.Context, filePath string) ([]*models.Diagnostic, error) <span class="cov1" title="1">{
        // For this implementation, we'll return empty diagnostics
        // In a real implementation, this would query the LSP server for diagnostics
        return []*models.Diagnostic{}, nil
}</span>

// GetCodeIntelligence provides code intelligence for a file
func (c *LSPClient) GetCodeIntelligence(ctx context.Context, filePath string, options map[string]interface{}) (*models.CodeIntelligence, error) <span class="cov2" title="2">{
        serverID := "default-go"
        uri := fmt.Sprintf("file://%s", filePath)

        // Open the file first
        content := "" // Would need to read file content
        if err := c.OpenFile(ctx, serverID, uri, "go", content); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>

        // Get completions at position 0,0 as example
        <span class="cov0" title="0">completions, err := c.GetCompletion(ctx, serverID, uri, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get completions: %w", err)
        }</span>

        // Get hover info
        <span class="cov0" title="0">hover, err := c.GetHover(ctx, serverID, uri, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get hover: %w", err)
        }</span>

        // Get definition
        <span class="cov0" title="0">definition, err := c.GetDefinition(ctx, serverID, uri, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get definition: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.CodeIntelligence{
                FilePath:    filePath,
                Completions: convertCompletionList(completions),
                Hover:       convertHover(hover),
                Definitions: []*models.Location{convertLocation(definition)},
        }, nil</span>
}

// Helper functions to convert LSP types to models types
func convertCompletionList(list *CompletionList) []*models.CompletionItem <span class="cov4" title="4">{
        if list == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="3">items := make([]*models.CompletionItem, len(list.Items))
        for i, item := range list.Items </span><span class="cov3" title="3">{
                items[i] = &amp;models.CompletionItem{
                        Label:  item.Label,
                        Kind:   item.Kind,
                        Detail: item.Detail,
                }
        }</span>
        <span class="cov3" title="3">return items</span>
}

func convertHover(hover *Hover) *models.HoverInfo <span class="cov4" title="4">{
        if hover == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="3">return &amp;models.HoverInfo{
                Content: hover.Contents.Value,
        }</span>
}

func convertLocation(loc *Location) *models.Location <span class="cov4" title="4">{
        if loc == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="3">return &amp;models.Location{
                URI: loc.URI,
                Range: models.Range{
                        Start: models.Position{
                                Line:      loc.Range.Start.Line,
                                Character: loc.Range.Start.Character,
                        },
                        End: models.Position{
                                Line:      loc.Range.End.Line,
                                Character: loc.Range.End.Character,
                        },
                },
        }</span>
}

// Private methods

func (c *LSPClient) createStdioTransport(command string, args []string) (LSPTransport, error) <span class="cov0" title="0">{
        cmd := exec.Command(command, args...)

        stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                stdin.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                stdin.Close()
                stdout.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;StdioLSPTransport{
                cmd:       cmd,
                stdin:     stdin,
                stdout:    stdout,
                scanner:   bufio.NewScanner(stdout),
                connected: true,
        }, nil</span>
}

func (c *LSPClient) initializeServer(ctx context.Context, connection *LSPServerConnection) error <span class="cov0" title="0">{
        initializeParams := InitializeRequest{
                ProcessID: nil,
                RootURI:   fmt.Sprintf("file://%s", connection.Workspace),
                Capabilities: ClientCapabilities{
                        TextDocument: TextDocumentClientCapabilities{
                                Completion: CompletionCapability{
                                        DynamicRegistration: false,
                                },
                        },
                },
        }

        initializeReq := LSPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "initialize",
                Params:  initializeParams,
        }

        if err := connection.Transport.Send(ctx, initializeReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialize request: %w", err)
        }</span>

        <span class="cov0" title="0">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">var initializeMsg LSPMessage
        if err := c.unmarshalMessage(response, &amp;initializeMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">if initializeMsg.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initialize failed: %s", initializeMsg.Error.Message)
        }</span>

        <span class="cov0" title="0">var result InitializeResult
        if err := c.unmarshalResult(initializeMsg.Result, &amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal initialize result: %w", err)
        }</span>

        <span class="cov0" title="0">connection.Capabilities = &amp;result.Capabilities

        // Send initialized notification
        initializedNotification := LSPMessage{
                JSONRPC: "2.0",
                Method:  "initialized",
                Params:  map[string]interface{}{},
        }

        if err := connection.Transport.Send(ctx, initializedNotification); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialized notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *LSPClient) nextMessageID() int <span class="cov6" title="8">{
        c.messageID++
        return c.messageID
}</span>

func (c *LSPClient) unmarshalMessage(data interface{}, message *LSPMessage) error <span class="cov5" title="6">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">return json.Unmarshal(jsonData, message)</span>
}

func (c *LSPClient) unmarshalResult(result interface{}, target interface{}) error <span class="cov5" title="6">{
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">return json.Unmarshal(jsonData, target)</span>
}

// StdioLSPTransport implementation

func (t *StdioLSPTransport) Send(ctx context.Context, message interface{}) error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return fmt.Errorf("transport not connected")
        }</span>

        <span class="cov0" title="0">jsonData, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // LSP uses Content-Length headers
        <span class="cov0" title="0">contentLength := len(jsonData)
        header := fmt.Sprintf("Content-Length: %d\r\n\r\n", contentLength)

        if _, err := t.stdin.Write([]byte(header)); err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return err
        }</span>

        <span class="cov0" title="0">if _, err := t.stdin.Write(jsonData); err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t *StdioLSPTransport) Receive(ctx context.Context) (interface{}, error) <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transport not connected")
        }</span>

        // Read Content-Length header
        <span class="cov0" title="0">if !t.scanner.Scan() </span><span class="cov0" title="0">{
                t.connected = false
                if err := t.scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, io.EOF</span>
        }

        <span class="cov0" title="0">headerLine := t.scanner.Text()
        if !strings.HasPrefix(headerLine, "Content-Length: ") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid LSP header: %s", headerLine)
        }</span>

        // Parse content length (simplified - should handle parsing better)
        <span class="cov0" title="0">contentLengthStr := strings.TrimPrefix(headerLine, "Content-Length: ")
        contentLength := 0
        fmt.Sscanf(contentLengthStr, "%d", &amp;contentLength)

        // Skip empty line
        if !t.scanner.Scan() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected empty line after header")
        }</span>

        // Read content
        <span class="cov0" title="0">content := make([]byte, contentLength)
        if _, err := io.ReadFull(t.stdout, content); err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return nil, err
        }</span>

        <span class="cov0" title="0">var message interface{}
        if err := json.Unmarshal(content, &amp;message); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func (t *StdioLSPTransport) Close() error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.connected = false

        if t.stdin != nil </span><span class="cov0" title="0">{
                t.stdin.Close()
        }</span>

        <span class="cov1" title="1">if t.cmd != nil &amp;&amp; t.cmd.Process != nil </span><span class="cov0" title="0">{
                return t.cmd.Process.Kill()
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *StdioLSPTransport) IsConnected() bool <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return t.connected
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// ACPManager handles ACP (Agent Client Protocol) operations
type ACPManager struct {
        repo  *database.ModelMetadataRepository
        cache CacheInterface
        log   *logrus.Logger
}

// ACPServer represents an ACP server configuration
type ACPServer struct {
        ID           string          `json:"id"`
        Name         string          `json:"name"`
        URL          string          `json:"url"`
        Enabled      bool            `json:"enabled"`
        Version      string          `json:"version"`
        Capabilities []ACPCapability `json:"capabilities"`
        LastSync     *time.Time      `json:"lastSync"`
}

// ACPCapability represents an ACP server capability
type ACPCapability struct {
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Parameters  map[string]interface{} `json:"parameters"`
}

// ACPRequest represents a request to an ACP server
type ACPRequest struct {
        ServerID   string                 `json:"serverId"`
        Action     string                 `json:"action"`
        Parameters map[string]interface{} `json:"parameters"`
}

// ACPResponse represents a response from an ACP server
type ACPResponse struct {
        Success   bool        `json:"success"`
        Data      interface{} `json:"data,omitempty"`
        Error     string      `json:"error,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
}

// NewACPManager creates a new ACP manager
func NewACPManager(repo *database.ModelMetadataRepository, cache CacheInterface, log *logrus.Logger) *ACPManager <span class="cov10" title="21">{
        return &amp;ACPManager{
                repo:  repo,
                cache: cache,
                log:   log,
        }
}</span>

// ListACPServers lists all configured ACP servers
func (m *ACPManager) ListACPServers(ctx context.Context) ([]*ACPServer, error) <span class="cov8" title="11">{
        // For now, return default ACP servers
        servers := []*ACPServer{
                {
                        ID:      "opencode-1",
                        Name:    "OpenCode Agent",
                        URL:     "ws://localhost:8080/agent",
                        Enabled: true,
                        Version: "1.0.0",
                        Capabilities: []ACPCapability{
                                {
                                        Name:        "code_execution",
                                        Description: "Execute code and return results",
                                        Parameters: map[string]interface{}{
                                                "language": map[string]string{"type": "string"},
                                                "code":     map[string]string{"type": "string"},
                                        },
                                },
                        },
                },
        }

        m.log.WithField("count", len(servers)).Info("Listed ACP servers")
        return servers, nil
}</span>

// GetACPServer gets a specific ACP server by ID
func (m *ACPManager) GetACPServer(ctx context.Context, serverID string) (*ACPServer, error) <span class="cov6" title="7">{
        servers, err := m.ListACPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="7">for _, server := range servers </span><span class="cov6" title="7">{
                if server.ID == serverID </span><span class="cov5" title="4">{
                        return server, nil
                }</span>
        }

        <span class="cov4" title="3">return nil, fmt.Errorf("ACP server %s not found", serverID)</span>
}

// ExecuteACPAction executes an action on an ACP server
func (m *ACPManager) ExecuteACPAction(ctx context.Context, req ACPRequest) (*ACPResponse, error) <span class="cov4" title="3">{
        m.log.WithFields(logrus.Fields{
                "serverId": req.ServerID,
                "action":   req.Action,
        }).Info("Executing ACP action")

        // Validate server exists
        server, err := m.GetACPServer(ctx, req.ServerID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid server ID: %w", err)
        }</span>

        <span class="cov3" title="2">if !server.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server %s is not enabled", req.ServerID)
        }</span>

        <span class="cov3" title="2">response := &amp;ACPResponse{
                Timestamp: time.Now(),
                Success:   true,
                Data:      fmt.Sprintf("Action %s executed successfully on server %s", req.Action, req.ServerID),
        }

        m.log.WithField("timestamp", response.Timestamp).Info("ACP action execution completed")
        return response, nil</span>
}

// ValidateACPRequest validates an ACP action request
func (m *ACPManager) ValidateACPRequest(ctx context.Context, req ACPRequest) error <span class="cov5" title="4">{
        if req.ServerID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("server ID is required")
        }</span>

        <span class="cov4" title="3">if req.Action == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("action is required")
        }</span>

        // Check if server exists
        <span class="cov3" title="2">server, err := m.GetACPServer(ctx, req.ServerID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid server ID: %w", err)
        }</span>

        <span class="cov1" title="1">if !server.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("server %s is not enabled", req.ServerID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SyncACPServer synchronizes configuration with an ACP server
func (m *ACPManager) SyncACPServer(ctx context.Context, serverID string) error <span class="cov3" title="2">{
        m.log.WithField("serverId", serverID).Info("Synchronizing ACP server")

        // In a real implementation, this would communicate with the ACP server
        m.log.Info("ACP server synchronization completed")
        return nil
}</span>

// GetACPStats returns statistics about ACP usage
func (m *ACPManager) GetACPStats(ctx context.Context) (map[string]interface{}, error) <span class="cov3" title="2">{
        servers, err := m.ListACPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">enabledCount := 0
        totalCapabilities := 0

        for _, server := range servers </span><span class="cov3" title="2">{
                if server.Enabled </span><span class="cov3" title="2">{
                        enabledCount++
                        totalCapabilities += len(server.Capabilities)
                }</span>
        }

        <span class="cov3" title="2">stats := map[string]interface{}{
                "totalServers":      len(servers),
                "enabledServers":    enabledCount,
                "totalCapabilities": totalCapabilities,
                "lastSync":          time.Now(),
        }

        m.log.WithFields(stats).Info("ACP statistics retrieved")
        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/sirupsen/logrus"
)

// AdvancedDebateService provides advanced debate management capabilities
type AdvancedDebateService struct {
        debateService      *DebateService
        monitoringService  *DebateMonitoringService
        performanceService *DebatePerformanceService
        historyService     *DebateHistoryService
        resilienceService  *DebateResilienceService
        reportingService   *DebateReportingService
        securityService    *DebateSecurityService
        logger             *logrus.Logger
}

// NewAdvancedDebateService creates a new advanced debate service
func NewAdvancedDebateService(
        debateService *DebateService,
        monitoringService *DebateMonitoringService,
        performanceService *DebatePerformanceService,
        historyService *DebateHistoryService,
        resilienceService *DebateResilienceService,
        reportingService *DebateReportingService,
        securityService *DebateSecurityService,
        logger *logrus.Logger,
) *AdvancedDebateService <span class="cov10" title="8">{
        return &amp;AdvancedDebateService{
                debateService:      debateService,
                monitoringService:  monitoringService,
                performanceService: performanceService,
                historyService:     historyService,
                resilienceService:  resilienceService,
                reportingService:   reportingService,
                securityService:    securityService,
                logger:             logger,
        }
}</span>

// ConductAdvancedDebate conducts a debate with advanced features
func (ads *AdvancedDebateService) ConductAdvancedDebate(
        ctx context.Context,
        config *DebateConfig,
) (*DebateResult, error) <span class="cov7" title="4">{
        // Security check
        if err := ads.securityService.ValidateDebateRequest(ctx, config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("security validation failed: %w", err)
        }</span>

        // Start monitoring
        <span class="cov7" title="4">monitoringID, err := ads.monitoringService.StartMonitoring(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start monitoring: %w", err)
        }</span>
        <span class="cov7" title="4">defer ads.monitoringService.StopMonitoring(ctx, monitoringID)

        // Conduct debate
        result, err := ads.debateService.ConductDebate(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("debate failed: %w", err)
        }</span>

        // Record performance metrics
        <span class="cov7" title="4">metrics := ads.performanceService.CalculateMetrics(result)
        if err := ads.performanceService.RecordMetrics(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                ads.logger.Warnf("Failed to record performance metrics: %v", err)
        }</span>

        // Save to history
        <span class="cov7" title="4">if err := ads.historyService.SaveDebateResult(ctx, result); err != nil </span><span class="cov0" title="0">{
                ads.logger.Warnf("Failed to save debate to history: %v", err)
        }</span>

        // Generate report
        <span class="cov7" title="4">report, err := ads.reportingService.GenerateReport(ctx, result)
        if err != nil </span><span class="cov0" title="0">{
                ads.logger.Warnf("Failed to generate report: %v", err)
        }</span> else<span class="cov7" title="4"> {
                if result.Metadata == nil </span><span class="cov0" title="0">{
                        result.Metadata = make(map[string]interface{})
                }</span>
                <span class="cov7" title="4">result.Metadata["report"] = report</span>
        }

        <span class="cov7" title="4">return result, nil</span>
}

// GetDebateStatus retrieves the current status of a debate
func (ads *AdvancedDebateService) GetDebateStatus(
        ctx context.Context,
        debateID string,
) (*DebateStatus, error) <span class="cov1" title="1">{
        return ads.monitoringService.GetStatus(ctx, debateID)
}</span>

// GetDebateHistory retrieves historical debate data
func (ads *AdvancedDebateService) GetDebateHistory(
        ctx context.Context,
        filters *HistoryFilters,
) ([]*DebateResult, error) <span class="cov1" title="1">{
        return ads.historyService.QueryHistory(ctx, filters)
}</span>

// GetPerformanceMetrics retrieves performance metrics
func (ads *AdvancedDebateService) GetPerformanceMetrics(
        ctx context.Context,
        timeRange TimeRange,
) (*PerformanceMetrics, error) <span class="cov1" title="1">{
        return ads.performanceService.GetMetrics(ctx, timeRange)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/cache"
)

// CacheFactory creates cache instances based on configuration
type CacheFactory struct {
        redisClient *cache.RedisClient
        log         *logrus.Logger
}

// NewCacheFactory creates a new cache factory
func NewCacheFactory(redisClient *cache.RedisClient, log *logrus.Logger) *CacheFactory <span class="cov10" title="8">{
        return &amp;CacheFactory{
                redisClient: redisClient,
                log:         log,
        }
}</span>

// CreateCache creates a cache instance based on the type
func (f *CacheFactory) CreateCache(cacheType string, ttl time.Duration) CacheInterface <span class="cov9" title="7">{
        switch cacheType </span>{
        case "redis":<span class="cov4" title="2">
                if f.redisClient != nil </span><span class="cov1" title="1">{
                        f.log.Info("Using Redis cache for model metadata")
                        return NewModelMetadataRedisCache(f.redisClient, "modelsdev", ttl, f.log)
                }</span>
                <span class="cov1" title="1">f.log.Warn("Redis client not available, falling back to in-memory cache")
                fallthrough</span>
        case "memory", "":<span class="cov5" title="3">
                f.log.Info("Using in-memory cache for model metadata")
                return NewInMemoryCache(ttl)</span>
        case "multi":<span class="cov4" title="2">
                if f.redisClient != nil </span><span class="cov1" title="1">{
                        f.log.Info("Using multi-level cache for model metadata")
                        inMemoryCache := NewInMemoryCache(ttl)
                        redisCache := NewModelMetadataRedisCache(f.redisClient, "modelsdev", ttl, f.log)
                        return NewMultiLevelCache(inMemoryCache, redisCache, f.log)
                }</span>
                <span class="cov1" title="1">f.log.Warn("Redis client not available, falling back to in-memory cache")
                return NewInMemoryCache(ttl)</span>
        default:<span class="cov1" title="1">
                f.log.WithField("cache_type", cacheType).Warn("Unknown cache type, using in-memory")
                return NewInMemoryCache(ttl)</span>
        }
}

// TestCacheConnection tests if Redis cache is available
func (f *CacheFactory) TestCacheConnection(ctx context.Context) bool <span class="cov7" title="4">{
        if f.redisClient == nil </span><span class="cov4" title="2">{
                return false
        }</span>

        <span class="cov4" title="2">if err := f.redisClient.Ping(ctx); err != nil </span><span class="cov4" title="2">{
                f.log.WithError(err).Warn("Redis cache connection test failed")
                return false
        }</span>

        <span class="cov0" title="0">f.log.Info("Redis cache connection test successful")
        return true</span>
}

// CreateDefaultCache creates the default cache based on available components
func (f *CacheFactory) CreateDefaultCache(ttl time.Duration) CacheInterface <span class="cov4" title="2">{
        // Test Redis connection first
        if f.TestCacheConnection(context.Background()) </span><span class="cov0" title="0">{
                f.log.Info("Redis available, using multi-level cache")
                inMemoryCache := NewInMemoryCache(ttl)
                redisCache := NewModelMetadataRedisCache(f.redisClient, "modelsdev", ttl, f.log)
                return NewMultiLevelCache(inMemoryCache, redisCache, f.log)
        }</span>

        // Fall back to in-memory cache
        <span class="cov4" title="2">f.log.Info("Redis not available, using in-memory cache")
        return NewInMemoryCache(ttl)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package services

import (
        "compress/gzip"
        "crypto/md5"
        "encoding/json"
        "fmt"
        "io"
        "sort"
        "strings"
        "sync"
        "time"
)

// ContextEntry represents a single context item
type ContextEntry struct {
        ID             string                 `json:"id"`
        Type           string                 `json:"type"`   // "lsp", "mcp", "tool", "llm"
        Source         string                 `json:"source"` // file path, tool name, etc.
        Content        string                 `json:"content"`
        Metadata       map[string]interface{} `json:"metadata"`
        Timestamp      time.Time              `json:"timestamp"`
        Priority       int                    `json:"priority"` // 1-10, higher is more important
        Compressed     bool                   `json:"compressed"`
        CompressedData []byte                 `json:"compressed_data,omitempty"`
}

// ContextCacheEntry represents a cached context item
type ContextCacheEntry struct {
        Data      interface{}
        Timestamp time.Time
        TTL       time.Duration
}

// ContextManager manages context for LLM requests
type ContextManager struct {
        mu                   sync.RWMutex
        entries              map[string]*ContextEntry
        cache                map[string]*ContextCacheEntry // For LSP, MCP, tool results
        cacheMu              sync.RWMutex
        maxSize              int
        compressionThreshold int // Compress entries larger than this
}

// NewContextManager creates a new context manager
func NewContextManager(maxSize int) *ContextManager <span class="cov7" title="26">{
        return &amp;ContextManager{
                entries:              make(map[string]*ContextEntry),
                cache:                make(map[string]*ContextCacheEntry),
                maxSize:              maxSize,
                compressionThreshold: 1024, // 1KB
        }
}</span>

// AddEntry adds a context entry
func (cm *ContextManager) AddEntry(entry *ContextEntry) error <span class="cov8" title="33">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        // Compress if needed
        if len(entry.Content) &gt; cm.compressionThreshold </span><span class="cov1" title="1">{
                if err := cm.compressEntry(entry); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compress entry: %w", err)
                }</span>
        }

        // Check size limits
        <span class="cov8" title="33">if len(cm.entries) &gt;= cm.maxSize </span><span class="cov4" title="6">{
                if err := cm.evictLowPriorityEntries(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to evict entries: %w", err)
                }</span>
        }

        <span class="cov8" title="33">entry.Timestamp = time.Now()
        cm.entries[entry.ID] = entry

        return nil</span>
}

// GetEntry retrieves a context entry
func (cm *ContextManager) GetEntry(id string) (*ContextEntry, bool) <span class="cov5" title="11">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        entry, exists := cm.entries[id]
        if !exists </span><span class="cov3" title="4">{
                return nil, false
        }</span>

        // Decompress if needed
        <span class="cov4" title="7">if entry.Compressed </span><span class="cov1" title="1">{
                if err := cm.decompressEntry(entry); err != nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
        }

        <span class="cov4" title="7">return entry, true</span>
}

// UpdateEntry updates an existing entry
func (cm *ContextManager) UpdateEntry(id string, content string, metadata map[string]interface{}) error <span class="cov2" title="2">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        entry, exists := cm.entries[id]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("entry %s not found", id)
        }</span>

        <span class="cov1" title="1">entry.Content = content
        entry.Metadata = metadata
        entry.Timestamp = time.Now()

        // Re-compress if needed
        if len(entry.Content) &gt; cm.compressionThreshold &amp;&amp; !entry.Compressed </span><span class="cov0" title="0">{
                if err := cm.compressEntry(entry); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compress entry: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// RemoveEntry removes a context entry
func (cm *ContextManager) RemoveEntry(id string) <span class="cov1" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        delete(cm.entries, id)
}</span>

// BuildContext builds optimized context for an LLM request
func (cm *ContextManager) BuildContext(requestType string, maxTokens int) ([]*ContextEntry, error) <span class="cov1" title="1">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        // Get all entries
        entries := make([]*ContextEntry, 0, len(cm.entries))
        for _, entry := range cm.entries </span><span class="cov3" title="3">{
                entries = append(entries, entry)
        }</span>

        // Sort by priority and recency
        <span class="cov1" title="1">sort.Slice(entries, func(i, j int) bool </span><span class="cov2" title="2">{
                if entries[i].Priority != entries[j].Priority </span><span class="cov2" title="2">{
                        return entries[i].Priority &gt; entries[j].Priority
                }</span>
                <span class="cov0" title="0">return entries[i].Timestamp.After(entries[j].Timestamp)</span>
        })

        // Filter and select relevant entries
        <span class="cov1" title="1">selected := cm.selectRelevantEntries(entries, requestType, maxTokens)

        // Decompress selected entries
        for _, entry := range selected </span><span class="cov3" title="3">{
                if entry.Compressed </span><span class="cov0" title="0">{
                        if err := cm.decompressEntry(entry); err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip corrupted entries
                        }
                }
        }

        <span class="cov1" title="1">return selected, nil</span>
}

// CacheResult caches a result from LSP, MCP, or tool execution
func (cm *ContextManager) CacheResult(key string, result interface{}, ttl time.Duration) <span class="cov2" title="2">{
        cm.cacheMu.Lock()
        defer cm.cacheMu.Unlock()

        cm.cache[key] = &amp;ContextCacheEntry{
                Data:      result,
                Timestamp: time.Now(),
                TTL:       ttl,
        }
}</span>

// GetCachedResult retrieves a cached result
func (cm *ContextManager) GetCachedResult(key string) (interface{}, bool) <span class="cov3" title="3">{
        cm.cacheMu.RLock()
        defer cm.cacheMu.RUnlock()

        entry, exists := cm.cache[key]
        if !exists </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov2" title="2">if time.Since(entry.Timestamp) &gt; entry.TTL </span><span class="cov1" title="1">{
                // Expired, will be cleaned up by cleanup routine
                return nil, false
        }</span>

        <span class="cov1" title="1">return entry.Data, true</span>
}

// DetectConflicts detects conflicting information in context
func (cm *ContextManager) DetectConflicts() []Conflict <span class="cov2" title="2">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        conflicts := []Conflict{}

        // Group entries by source
        sourceMap := make(map[string][]*ContextEntry)
        for _, entry := range cm.entries </span><span class="cov3" title="3">{
                sourceMap[entry.Source] = append(sourceMap[entry.Source], entry)
        }</span>

        // Check for conflicts within each source
        <span class="cov2" title="2">for source, entries := range sourceMap </span><span class="cov2" title="2">{
                if conflict := cm.detectSourceConflicts(source, entries); conflict != nil </span><span class="cov1" title="1">{
                        conflicts = append(conflicts, *conflict)
                }</span>
        }

        <span class="cov2" title="2">return conflicts</span>
}

// Cleanup removes expired entries
func (cm *ContextManager) Cleanup() <span class="cov1" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        cm.cacheMu.Lock()
        defer cm.cacheMu.Unlock()

        now := time.Now()

        // Clean context entries (keep recent ones)
        for id, entry := range cm.entries </span><span class="cov2" title="2">{
                if now.Sub(entry.Timestamp) &gt; 24*time.Hour </span><span class="cov1" title="1">{
                        delete(cm.entries, id)
                }</span>
        }

        // Clean cache
        <span class="cov1" title="1">for key, entry := range cm.cache </span><span class="cov0" title="0">{
                if now.Sub(entry.Timestamp) &gt; entry.TTL </span><span class="cov0" title="0">{
                        delete(cm.cache, key)
                }</span>
        }
}

// Helper methods

func (cm *ContextManager) compressEntry(entry *ContextEntry) error <span class="cov2" title="2">{
        var buf strings.Builder
        gz := gzip.NewWriter(&amp;buf)

        if _, err := gz.Write([]byte(entry.Content)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">if err := gz.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">entry.CompressedData = []byte(buf.String())
        entry.Compressed = true
        entry.Content = "" // Clear original content

        return nil</span>
}

func (cm *ContextManager) decompressEntry(entry *ContextEntry) error <span class="cov3" title="4">{
        if !entry.Compressed || len(entry.CompressedData) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov2" title="2">gr, err := gzip.NewReader(strings.NewReader(string(entry.CompressedData)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">defer gr.Close()

        content, err := io.ReadAll(gr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">entry.Content = string(content)
        entry.Compressed = false
        entry.CompressedData = nil

        return nil</span>
}

func (cm *ContextManager) evictLowPriorityEntries() error <span class="cov5" title="8">{
        if len(cm.entries) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Find lowest priority entries
        <span class="cov4" title="7">type entryWithID struct {
                id    string
                entry *ContextEntry
        }

        var candidates []entryWithID
        minPriority := 10

        for id, entry := range cm.entries </span><span class="cov9" title="63">{
                if entry.Priority &lt; minPriority </span><span class="cov5" title="11">{
                        minPriority = entry.Priority
                        candidates = []entryWithID{{id, entry}}
                }</span> else<span class="cov9" title="52"> if entry.Priority == minPriority </span><span class="cov5" title="10">{
                        candidates = append(candidates, entryWithID{id, entry})
                }</span>
        }

        // Remove oldest from lowest priority
        <span class="cov4" title="7">if len(candidates) &gt; 0 </span><span class="cov4" title="7">{
                sort.Slice(candidates, func(i, j int) bool </span><span class="cov4" title="6">{
                        return candidates[i].entry.Timestamp.Before(candidates[j].entry.Timestamp)
                }</span>)

                <span class="cov4" title="7">delete(cm.entries, candidates[0].id)</span>
        }

        <span class="cov4" title="7">return nil</span>
}

func (cm *ContextManager) selectRelevantEntries(entries []*ContextEntry, requestType string, maxTokens int) []*ContextEntry <span class="cov3" title="4">{
        // Score entries by relevance
        type scoredEntry struct {
                entry *ContextEntry
                score float64
        }

        var scoredEntries []scoredEntry
        for _, entry := range entries </span><span class="cov5" title="9">{
                score := cm.calculateRelevanceScore(entry, requestType)
                scoredEntries = append(scoredEntries, scoredEntry{entry: entry, score: score})
        }</span>

        // Sort by score (descending) then by recency
        <span class="cov3" title="4">sort.Slice(scoredEntries, func(i, j int) bool </span><span class="cov5" title="8">{
                if scoredEntries[i].score != scoredEntries[j].score </span><span class="cov5" title="8">{
                        return scoredEntries[i].score &gt; scoredEntries[j].score
                }</span>
                <span class="cov0" title="0">return scoredEntries[i].entry.Timestamp.After(scoredEntries[j].entry.Timestamp)</span>
        })

        // Select entries within token limit
        <span class="cov3" title="4">selected := []*ContextEntry{}
        totalTokens := 0

        for _, scored := range scoredEntries </span><span class="cov5" title="8">{
                estimatedTokens := len(scored.entry.Content) / 4
                if totalTokens+estimatedTokens &gt; maxTokens </span><span class="cov1" title="1">{
                        break</span>
                }

                <span class="cov4" title="7">selected = append(selected, scored.entry)
                totalTokens += estimatedTokens</span>
        }

        <span class="cov3" title="4">return selected</span>
}

// calculateRelevanceScore calculates ML-based relevance score
func (cm *ContextManager) calculateRelevanceScore(entry *ContextEntry, requestType string) float64 <span class="cov6" title="15">{
        score := 0.0

        // Base score from priority
        score += float64(entry.Priority) * 10.0

        // Recency bonus (newer entries get higher score)
        hoursOld := time.Since(entry.Timestamp).Hours()
        recencyScore := 1.0 / (1.0 + hoursOld/24.0) // Exponential decay
        score += recencyScore * 5.0

        // Content-based scoring
        contentLower := strings.ToLower(entry.Content)

        // Keyword matching
        keywords := cm.extractKeywords(requestType)
        keywordMatches := 0
        for _, keyword := range keywords </span><span class="cov10" title="80">{
                if strings.Contains(contentLower, keyword) </span><span class="cov4" title="5">{
                        keywordMatches++
                }</span>
        }
        <span class="cov6" title="15">score += float64(keywordMatches) * 2.0

        // Type-specific scoring
        switch requestType </span>{
        case "code_completion":<span class="cov5" title="11">
                if entry.Type == "lsp" </span><span class="cov4" title="6">{
                        score += 15.0
                }</span>
        case "tool_execution":<span class="cov1" title="1">
                if entry.Type == "tool" || entry.Type == "mcp" </span><span class="cov1" title="1">{
                        score += 15.0
                }</span>
        case "chat":<span class="cov2" title="2">
                if entry.Type == "llm" </span><span class="cov0" title="0">{
                        score += 10.0
                }</span>
        }

        // Source reliability scoring
        <span class="cov6" title="15">switch entry.Source </span>{
        case "lsp":<span class="cov0" title="0">
                score += 8.0</span>
        case "mcp":<span class="cov0" title="0">
                score += 7.0</span>
        case "tool":<span class="cov0" title="0">
                score += 6.0</span>
        }

        <span class="cov6" title="15">return score</span>
}

// extractKeywords extracts keywords from request type
func (cm *ContextManager) extractKeywords(requestType string) []string <span class="cov6" title="18">{
        // Simple keyword extraction - can be enhanced with NLP
        keywords := []string{requestType}

        switch requestType </span>{
        case "code_completion":<span class="cov6" title="12">
                keywords = append(keywords, "function", "class", "variable", "import", "syntax")</span>
        case "tool_execution":<span class="cov2" title="2">
                keywords = append(keywords, "run", "execute", "command", "script")</span>
        case "chat":<span class="cov3" title="3">
                keywords = append(keywords, "conversation", "question", "answer")</span>
        }

        <span class="cov6" title="18">return keywords</span>
}

func (cm *ContextManager) isRelevant(entry *ContextEntry, requestType string) bool <span class="cov4" title="7">{
        // Simple relevance logic - can be enhanced with ML
        switch requestType </span>{
        case "code_completion":<span class="cov2" title="2">
                return entry.Type == "lsp" || entry.Type == "tool"</span>
        case "chat":<span class="cov2" title="2">
                return entry.Type == "llm" || entry.Type == "memory"</span>
        case "tool_execution":<span class="cov2" title="2">
                return entry.Type == "tool" || entry.Type == "mcp"</span>
        default:<span class="cov1" title="1">
                return true</span>
        }
}

func (cm *ContextManager) detectSourceConflicts(source string, entries []*ContextEntry) *Conflict <span class="cov2" title="2">{
        // Simple conflict detection - check for contradictory information
        // This is a placeholder for more sophisticated conflict detection

        contentMap := make(map[string][]*ContextEntry)
        for _, entry := range entries </span><span class="cov3" title="3">{
                hash := fmt.Sprintf("%x", md5.Sum([]byte(entry.Content)))
                contentMap[hash] = append(contentMap[hash], entry)
        }</span>

        // If we have multiple entries with same content but different metadata,
        // it might indicate a conflict
        <span class="cov2" title="2">for _, group := range contentMap </span><span class="cov2" title="2">{
                if len(group) &gt; 1 </span><span class="cov1" title="1">{
                        // Check if metadata differs significantly
                        if cm.hasConflictingMetadata(group) </span><span class="cov1" title="1">{
                                return &amp;Conflict{
                                        Type:     "metadata_conflict",
                                        Source:   source,
                                        Entries:  group,
                                        Severity: "medium",
                                }
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

func (cm *ContextManager) hasConflictingMetadata(entries []*ContextEntry) bool <span class="cov4" title="5">{
        if len(entries) &lt; 2 </span><span class="cov2" title="2">{
                return false
        }</span>

        // Compare metadata between entries
        <span class="cov3" title="3">base := entries[0].Metadata
        for _, entry := range entries[1:] </span><span class="cov3" title="3">{
                if !cm.metadataEqual(base, entry.Metadata) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

func (cm *ContextManager) metadataEqual(a, b map[string]interface{}) bool <span class="cov5" title="10">{
        aBytes, _ := json.Marshal(a)
        bBytes, _ := json.Marshal(b)
        return string(aBytes) == string(bBytes)
}</span>

// ContextContextCacheEntry represents a cached context item
type ContextContextCacheEntry struct {
        Data      interface{}
        Timestamp time.Time
        TTL       time.Duration
}

// Conflict represents a detected conflict in context
type Conflict struct {
        Type     string          `json:"type"`
        Source   string          `json:"source"`
        Entries  []*ContextEntry `json:"entries"`
        Severity string          `json:"severity"`
        Message  string          `json:"message"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "context"

        "github.com/sirupsen/logrus"
)

// DebateHistoryService provides historical debate data
type DebateHistoryService struct {
        logger *logrus.Logger
}

// NewDebateHistoryService creates a new history service
func NewDebateHistoryService(logger *logrus.Logger) *DebateHistoryService <span class="cov10" title="11">{
        return &amp;DebateHistoryService{
                logger: logger,
        }
}</span>

// SaveDebateResult saves a debate result to history
func (dhs *DebateHistoryService) SaveDebateResult(ctx context.Context, result *DebateResult) error <span class="cov7" title="5">{
        dhs.logger.Infof("Saved debate result %s to history", result.DebateID)
        return nil
}</span>

// QueryHistory queries historical debate data
func (dhs *DebateHistoryService) QueryHistory(ctx context.Context, filters *HistoryFilters) ([]*DebateResult, error) <span class="cov3" title="2">{
        dhs.logger.Infof("Queried debate history with filters")
        return []*DebateResult{}, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"
)

// DebateMonitoringService provides monitoring capabilities
type DebateMonitoringService struct {
        logger *logrus.Logger
}

// NewDebateMonitoringService creates a new monitoring service
func NewDebateMonitoringService(logger *logrus.Logger) *DebateMonitoringService <span class="cov10" title="12">{
        return &amp;DebateMonitoringService{
                logger: logger,
        }
}</span>

// StartMonitoring starts monitoring for a debate
func (dms *DebateMonitoringService) StartMonitoring(ctx context.Context, config *DebateConfig) (string, error) <span class="cov6" title="5">{
        monitoringID := "monitoring-" + time.Now().Format("20060102150405")
        dms.logger.Infof("Started monitoring %s for debate %s", monitoringID, config.DebateID)
        return monitoringID, nil
}</span>

// StopMonitoring stops monitoring for a debate
func (dms *DebateMonitoringService) StopMonitoring(ctx context.Context, monitoringID string) error <span class="cov6" title="5">{
        dms.logger.Infof("Stopped monitoring %s", monitoringID)
        return nil
}</span>

// GetStatus retrieves the current status of a debate
func (dms *DebateMonitoringService) GetStatus(ctx context.Context, debateID string) (*DebateStatus, error) <span class="cov3" title="2">{
        return &amp;DebateStatus{
                DebateID:     debateID,
                Status:       "completed",
                CurrentRound: 3,
                TotalRounds:  3,
                StartTime:    time.Now().Add(-5 * time.Minute),
                Participants: []ParticipantStatus{
                        {
                                ParticipantID:   "participant-1",
                                ParticipantName: "Alice",
                                Status:          "completed",
                                ResponseTime:    5 * time.Second,
                        },
                },
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"
)

// DebatePerformanceService provides performance metrics
type DebatePerformanceService struct {
        logger *logrus.Logger
}

// NewDebatePerformanceService creates a new performance service
func NewDebatePerformanceService(logger *logrus.Logger) *DebatePerformanceService <span class="cov10" title="12">{
        return &amp;DebatePerformanceService{
                logger: logger,
        }
}</span>

// CalculateMetrics calculates performance metrics from a debate result
func (dps *DebatePerformanceService) CalculateMetrics(result *DebateResult) *PerformanceMetrics <span class="cov6" title="5">{
        return &amp;PerformanceMetrics{
                Duration:     result.Duration,
                TotalRounds:  result.TotalRounds,
                QualityScore: result.QualityScore,
                Throughput:   float64(result.TotalRounds) / result.Duration.Minutes(),
                Latency:      result.Duration / time.Duration(result.TotalRounds),
                ErrorRate:    0.0,
                ResourceUsage: ResourceUsage{
                        CPU:     0.5,
                        Memory:  1024 * 1024 * 100, // 100MB
                        Network: 1024 * 1024 * 10,  // 10MB
                },
        }
}</span>

// RecordMetrics records performance metrics
func (dps *DebatePerformanceService) RecordMetrics(ctx context.Context, metrics *PerformanceMetrics) error <span class="cov6" title="5">{
        dps.logger.Infof("Recorded performance metrics: duration=%v, quality=%f", metrics.Duration, metrics.QualityScore)
        return nil
}</span>

// GetMetrics retrieves performance metrics for a time range
func (dps *DebatePerformanceService) GetMetrics(ctx context.Context, timeRange TimeRange) (*PerformanceMetrics, error) <span class="cov3" title="2">{
        return &amp;PerformanceMetrics{
                Duration:     5 * time.Minute,
                TotalRounds:  3,
                QualityScore: 0.85,
                Throughput:   0.6,
                Latency:      100 * time.Second,
                ErrorRate:    0.0,
                ResourceUsage: ResourceUsage{
                        CPU:     0.5,
                        Memory:  1024 * 1024 * 100,
                        Network: 1024 * 1024 * 10,
                },
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"
)

// DebateReportingService provides reporting capabilities
type DebateReportingService struct {
        logger *logrus.Logger
}

// NewDebateReportingService creates a new reporting service
func NewDebateReportingService(logger *logrus.Logger) *DebateReportingService <span class="cov10" title="11">{
        return &amp;DebateReportingService{
                logger: logger,
        }
}</span>

// GenerateReport generates a report for a debate
func (drs *DebateReportingService) GenerateReport(ctx context.Context, result *DebateResult) (*DebateReport, error) <span class="cov7" title="5">{
        return &amp;DebateReport{
                ReportID:        "report-" + result.DebateID,
                DebateID:        result.DebateID,
                GeneratedAt:     time.Now(),
                Summary:         "Debate summary",
                KeyFindings:     []string{"Finding 1", "Finding 2"},
                Recommendations: []string{"Recommendation 1"},
                Metrics: PerformanceMetrics{
                        Duration:     result.Duration,
                        TotalRounds:  result.TotalRounds,
                        QualityScore: result.QualityScore,
                },
        }, nil
}</span>

// ExportReport exports a report in the specified format
func (drs *DebateReportingService) ExportReport(ctx context.Context, reportID string, format string) ([]byte, error) <span class="cov1" title="1">{
        drs.logger.Infof("Exported report %s in format %s", reportID, format)
        return []byte("report content"), nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "context"

        "github.com/sirupsen/logrus"
)

// DebateResilienceService provides resilience and recovery capabilities
type DebateResilienceService struct {
        logger *logrus.Logger
}

// NewDebateResilienceService creates a new resilience service
func NewDebateResilienceService(logger *logrus.Logger) *DebateResilienceService <span class="cov10" title="11">{
        return &amp;DebateResilienceService{
                logger: logger,
        }
}</span>

// HandleFailure handles a failure during debate
func (drs *DebateResilienceService) HandleFailure(ctx context.Context, err error) error <span class="cov1" title="1">{
        drs.logger.Warnf("Handled failure: %v", err)
        return nil
}</span>

// RecoverDebate recovers a debate from a failure
func (drs *DebateResilienceService) RecoverDebate(ctx context.Context, debateID string) (*DebateResult, error) <span class="cov1" title="1">{
        drs.logger.Infof("Recovered debate %s", debateID)
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "context"

        "github.com/sirupsen/logrus"
)

// DebateSecurityService provides security capabilities
type DebateSecurityService struct {
        logger *logrus.Logger
}

// NewDebateSecurityService creates a new security service
func NewDebateSecurityService(logger *logrus.Logger) *DebateSecurityService <span class="cov10" title="12">{
        return &amp;DebateSecurityService{
                logger: logger,
        }
}</span>

// ValidateDebateRequest validates a debate request
func (dss *DebateSecurityService) ValidateDebateRequest(ctx context.Context, config *DebateConfig) error <span class="cov6" title="5">{
        dss.logger.Infof("Validated debate request for %s", config.DebateID)
        return nil
}</span>

// SanitizeResponse sanitizes a response
func (dss *DebateSecurityService) SanitizeResponse(ctx context.Context, response string) (string, error) <span class="cov1" title="1">{
        dss.logger.Infof("Sanitized response")
        return response, nil
}</span>

// AuditDebate audits a debate
func (dss *DebateSecurityService) AuditDebate(ctx context.Context, debateID string) error <span class="cov1" title="1">{
        dss.logger.Infof("Audited debate %s", debateID)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/sirupsen/logrus"
)

// DebateService provides core debate functionality
type DebateService struct {
        logger *logrus.Logger
}

// NewDebateService creates a new debate service
func NewDebateService(logger *logrus.Logger) *DebateService <span class="cov9" title="11">{
        return &amp;DebateService{
                logger: logger,
        }
}</span>

// ConductDebate conducts a debate with the given configuration
func (ds *DebateService) ConductDebate(
        ctx context.Context,
        config *DebateConfig,
) (*DebateResult, error) <span class="cov9" title="10">{
        startTime := time.Now()

        ds.logger.Infof("Starting debate %s with topic: %s", config.DebateID, config.Topic)

        // Simulate debate execution
        result := &amp;DebateResult{
                DebateID:        config.DebateID,
                SessionID:       fmt.Sprintf("session-%s", config.DebateID),
                Topic:           config.Topic,
                StartTime:       startTime,
                EndTime:         startTime.Add(config.Timeout),
                Duration:        config.Timeout,
                TotalRounds:     config.MaxRounds,
                RoundsConducted: config.MaxRounds,
                Success:         true,
                QualityScore:    0.85,
                FinalScore:      0.87,
                Metadata:        make(map[string]interface{}),
        }

        // Add participants
        for _, participant := range config.Participants </span><span class="cov10" title="13">{
                result.Participants = append(result.Participants, ParticipantResponse{
                        ParticipantID:   participant.ParticipantID,
                        ParticipantName: participant.Name,
                        Role:            participant.Role,
                        Round:           1,
                        RoundNumber:     1,
                        Response:        fmt.Sprintf("Response from %s", participant.Name),
                        Content:         fmt.Sprintf("Content from %s", participant.Name),
                        Confidence:      0.9,
                        QualityScore:    0.85,
                        ResponseTime:    5 * time.Second,
                        LLMProvider:     participant.LLMProvider,
                        LLMModel:        participant.LLMModel,
                        LLMName:         participant.LLMModel,
                        Timestamp:       startTime,
                })
        }</span>

        // Add consensus
        <span class="cov9" title="10">result.Consensus = &amp;ConsensusResult{
                Reached:        true,
                Achieved:       true,
                Confidence:     0.85,
                ConsensusLevel: 0.85,
                AgreementLevel: 0.85,
                AgreementScore: 0.85,
                FinalPosition:  "Agreement reached",
                KeyPoints:      []string{"Point 1", "Point 2"},
                Disagreements:  []string{},
                Summary:        "Consensus summary",
                Timestamp:      startTime,
                QualityScore:   0.85,
        }

        if config.EnableCognee </span><span class="cov3" title="2">{
                result.CogneeEnhanced = true
                start := time.Now()

                // Generate insights using topic as query
                insights := &amp;CogneeInsights{
                        DatasetName:     "debate-insights",
                        EnhancementTime: time.Since(start),
                        SemanticAnalysis: SemanticAnalysis{
                                MainThemes:     []string{config.Topic, "debate", "discussion"},
                                CoherenceScore: 0.85,
                        },
                        EntityExtraction: []Entity{
                                {Text: config.Topic, Type: "TOPIC", Confidence: 1.0},
                        },
                        SentimentAnalysis: SentimentAnalysis{
                                OverallSentiment: "neutral",
                                SentimentScore:   0.7,
                        },
                        KnowledgeGraph: KnowledgeGraph{
                                Nodes:           []Node{}, // Would be populated from actual Cognee response
                                Edges:           []Edge{}, // Would be populated from actual Cognee response
                                CentralConcepts: []string{config.Topic},
                        },
                        Recommendations: []string{
                                "Consider diverse perspectives",
                                "Focus on evidence-based arguments",
                                "Maintain respectful discourse",
                        },
                        QualityMetrics: &amp;QualityMetrics{
                                Coherence:    0.9,
                                Relevance:    0.85,
                                Accuracy:     0.88,
                                Completeness: 0.87,
                                OverallScore: 0.87,
                        },
                        TopicModeling: map[string]float64{
                                config.Topic: 0.9,
                        },
                        CoherenceScore:  0.85,
                        RelevanceScore:  0.82,
                        InnovationScore: 0.75,
                }

                result.CogneeInsights = insights
        }</span>

        <span class="cov9" title="10">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package services

import (
        "fmt"
        "time"
)

// DebateResult represents the outcome of a complete AI debate
type DebateResult struct {
        DebateID        string                `json:"debate_id"`
        SessionID       string                `json:"session_id,omitempty"`
        Topic           string                `json:"topic,omitempty"`
        StartTime       time.Time             `json:"start_time"`
        EndTime         time.Time             `json:"end_time"`
        Duration        time.Duration         `json:"duration"`
        TotalRounds     int                   `json:"total_rounds"`
        RoundsConducted int                   `json:"rounds_conducted,omitempty"`
        Participants    []ParticipantResponse `json:"participants"`
        AllResponses    []ParticipantResponse `json:"all_responses,omitempty"`
        BestResponse    *ParticipantResponse  `json:"best_response,omitempty"`
        Consensus       *ConsensusResult      `json:"consensus,omitempty"`
        CogneeInsights  *CogneeInsights       `json:"cognee_insights,omitempty"`
        QualityScore    float64               `json:"quality_score"`
        FinalScore      float64               `json:"final_score,omitempty"`
        QualityMetrics  *QualityMetrics       `json:"quality_metrics,omitempty"`
        Success         bool                  `json:"success"`
        FallbackUsed    bool                  `json:"fallback_used,omitempty"`
        CogneeEnhanced  bool                  `json:"cognee_enhanced,omitempty"`
        MemoryUsed      bool                  `json:"memory_used,omitempty"`
        Recommendations []string              `json:"recommendations,omitempty"`
        ErrorMessage    string                `json:"error_message,omitempty"`
        Metadata        map[string]any        `json:"metadata,omitempty"`
}

// ConsensusResult represents the consensus reached during debate
type ConsensusResult struct {
        Reached        bool          `json:"reached,omitempty"`
        Achieved       bool          `json:"achieved"`
        Confidence     float64       `json:"confidence"`
        ConsensusLevel float64       `json:"consensus_level,omitempty"`
        AgreementLevel float64       `json:"agreement_level"`
        AgreementScore float64       `json:"agreement_score,omitempty"`
        FinalPosition  string        `json:"final_position"`
        KeyPoints      []string      `json:"key_points"`
        Disagreements  []string      `json:"disagreements"`
        Summary        string        `json:"summary,omitempty"`
        VotingSummary  VotingSummary `json:"voting_summary"`
        Timestamp      time.Time     `json:"timestamp"`
        QualityScore   float64       `json:"quality_score,omitempty"`
}

// ParticipantResponse represents a single participant's response
type ParticipantResponse struct {
        ParticipantID   string          `json:"participant_id"`
        ParticipantName string          `json:"participant_name"`
        Role            string          `json:"role"`
        Round           int             `json:"round"`
        RoundNumber     int             `json:"round_number,omitempty"`
        Response        string          `json:"response"`
        Content         string          `json:"content,omitempty"`
        Confidence      float64         `json:"confidence"`
        QualityScore    float64         `json:"quality_score"`
        ResponseTime    time.Duration   `json:"response_time"`
        LLMProvider     string          `json:"llm_provider"`
        LLMModel        string          `json:"llm_model"`
        LLMName         string          `json:"llm_name,omitempty"`
        CogneeEnhanced  bool            `json:"cognee_enhanced"`
        CogneeAnalysis  *CogneeAnalysis `json:"cognee_analysis,omitempty"`
        Timestamp       time.Time       `json:"timestamp"`
        Metadata        map[string]any  `json:"metadata,omitempty"`
}

// CogneeInsights represents insights generated by Cognee AI
type CogneeInsights struct {
        DatasetName       string             `json:"dataset_name"`
        EnhancementTime   time.Duration      `json:"enhancement_time"`
        SemanticAnalysis  SemanticAnalysis   `json:"semantic_analysis"`
        EntityExtraction  []Entity           `json:"entity_extraction"`
        SentimentAnalysis SentimentAnalysis  `json:"sentiment_analysis"`
        KnowledgeGraph    KnowledgeGraph     `json:"knowledge_graph"`
        Recommendations   []string           `json:"recommendations"`
        QualityMetrics    *QualityMetrics    `json:"quality_metrics,omitempty"`
        TopicModeling     map[string]float64 `json:"topic_modeling,omitempty"`
        CoherenceScore    float64            `json:"coherence_score,omitempty"`
        RelevanceScore    float64            `json:"relevance_score,omitempty"`
        InnovationScore   float64            `json:"innovation_score,omitempty"`
}

// CogneeAnalysis represents Cognee analysis for a single response
type CogneeAnalysis struct {
        Enhanced         bool          `json:"enhanced"`
        OriginalResponse string        `json:"original_response,omitempty"`
        EnhancedResponse string        `json:"enhanced_response,omitempty"`
        Sentiment        string        `json:"sentiment"`
        Entities         []string      `json:"entities"`
        KeyPhrases       []string      `json:"key_phrases"`
        Confidence       float64       `json:"confidence"`
        ProcessingTime   time.Duration `json:"processing_time"`
}

// VotingSummary represents the voting results
type VotingSummary struct {
        Strategy         string         `json:"strategy"`
        TotalVotes       int            `json:"total_votes"`
        VoteDistribution map[string]int `json:"vote_distribution"`
        Winner           string         `json:"winner"`
        Margin           float64        `json:"margin"`
}

// SemanticAnalysis represents semantic analysis results
type SemanticAnalysis struct {
        SimilarityMatrix [][]float64 `json:"similarity_matrix"`
        Clusters         []Cluster   `json:"clusters"`
        MainThemes       []string    `json:"main_themes"`
        CoherenceScore   float64     `json:"coherence_score"`
}

// SentimentAnalysis represents sentiment analysis results
type SentimentAnalysis struct {
        OverallSentiment string             `json:"overall_sentiment"`
        SentimentScore   float64            `json:"sentiment_score"`
        SentimentByRound []SentimentByRound `json:"sentiment_by_round"`
}

// KnowledgeGraph represents the knowledge graph
type KnowledgeGraph struct {
        Nodes           []Node   `json:"nodes"`
        Edges           []Edge   `json:"edges"`
        CentralConcepts []string `json:"central_concepts"`
}

// QualityMetrics represents quality metrics
type QualityMetrics struct {
        Coherence    float64 `json:"coherence"`
        Relevance    float64 `json:"relevance"`
        Accuracy     float64 `json:"accuracy"`
        Completeness float64 `json:"completeness"`
        OverallScore float64 `json:"overall_score"`
}

// Helper types
type Entity struct {
        Text       string  `json:"text"`
        Type       string  `json:"type"`
        Confidence float64 `json:"confidence"`
}

type Cluster struct {
        ID       string   `json:"id"`
        Members  []string `json:"members"`
        Centroid string   `json:"centroid"`
}

type SentimentByRound struct {
        Round     int     `json:"round"`
        Sentiment string  `json:"sentiment"`
        Score     float64 `json:"score"`
}

type Node struct {
        ID         string         `json:"id"`
        Label      string         `json:"label"`
        Type       string         `json:"type"`
        Properties map[string]any `json:"properties"`
}

type Edge struct {
        Source string  `json:"source"`
        Target string  `json:"target"`
        Type   string  `json:"type"`
        Weight float64 `json:"weight"`
}

// Validate validates the DebateResult
func (dr *DebateResult) Validate() error <span class="cov9" title="5">{
        if dr.DebateID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("debate_id is required")
        }</span>
        <span class="cov7" title="4">if dr.StartTime.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("start_time is required")
        }</span>
        <span class="cov6" title="3">if dr.TotalRounds &lt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("total_rounds must be at least 1")
        }</span>
        <span class="cov4" title="2">if len(dr.Participants) &lt; 2 </span><span class="cov1" title="1">{
                return fmt.Errorf("at least 2 participants required")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Validate validates the ConsensusResult
func (cr *ConsensusResult) Validate() error <span class="cov10" title="6">{
        if cr.Timestamp.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("timestamp is required")
        }</span>
        <span class="cov9" title="5">if cr.Confidence &lt; 0 || cr.Confidence &gt; 1 </span><span class="cov4" title="2">{
                return fmt.Errorf("confidence must be between 0 and 1")
        }</span>
        <span class="cov6" title="3">return nil</span>
}

// Validate validates the ParticipantResponse
func (pr *ParticipantResponse) Validate() error <span class="cov10" title="6">{
        if pr.ParticipantID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("participant_id is required")
        }</span>
        <span class="cov9" title="5">if pr.ParticipantName == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("participant_name is required")
        }</span>
        <span class="cov7" title="4">if pr.Round &lt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("round must be at least 1")
        }</span>
        <span class="cov6" title="3">if pr.Response == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("response is required")
        }</span>
        <span class="cov4" title="2">if pr.Timestamp.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("timestamp is required")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// EmbeddingManager handles embedding generation and vector database operations
type EmbeddingManager struct {
        repo           *database.ModelMetadataRepository
        cache          CacheInterface
        log            *logrus.Logger
        vectorProvider string // "pgvector", "weaviate", etc.
}

// EmbeddingRequest represents a request to generate embeddings
type EmbeddingRequest struct {
        Text      string `json:"text"`
        Model     string `json:"model,omitempty"`
        Dimension int    `json:"dimension,omitempty"`
        Batch     bool   `json:"batch,omitempty"`
}

// EmbeddingResponse represents the response from embedding generation
type EmbeddingResponse struct {
        Success    bool      `json:"success"`
        Embeddings []float64 `json:"embeddings,omitempty"`
        Error      string    `json:"error,omitempty"`
        Timestamp  time.Time `json:"timestamp"`
}

// VectorSearchRequest represents a vector similarity search request
type VectorSearchRequest struct {
        Query     string    `json:"query"`
        Vector    []float64 `json:"vector"`
        Limit     int       `json:"limit,omitempty"`
        Threshold float64   `json:"threshold,omitempty"`
}

// VectorSearchResponse represents the response from vector search
type VectorSearchResponse struct {
        Success   bool                 `json:"success"`
        Results   []VectorSearchResult `json:"results,omitempty"`
        Error     string               `json:"error,omitempty"`
        Timestamp time.Time            `json:"timestamp"`
}

// VectorSearchResult represents a single search result
type VectorSearchResult struct {
        ID       string                 `json:"id"`
        Content  string                 `json:"content"`
        Score    float64                `json:"score"`
        Metadata map[string]interface{} `json:"metadata"`
}

// NewEmbeddingManager creates a new embedding manager
func NewEmbeddingManager(repo *database.ModelMetadataRepository, cache CacheInterface, log *logrus.Logger) *EmbeddingManager <span class="cov4" title="28">{
        return &amp;EmbeddingManager{
                repo:           repo,
                cache:          cache,
                log:            log,
                vectorProvider: "pgvector", // Default vector provider
        }
}</span>

// GenerateEmbedding generates embeddings for the given text
func (m *EmbeddingManager) GenerateEmbedding(ctx context.Context, text string) (EmbeddingResponse, error) <span class="cov1" title="2">{
        // Generate embeddings for the input text
        embedding := make([]float64, 384) // Placeholder for 384-dimensional embedding
        for i := range embedding </span><span class="cov7" title="768">{
                embedding[i] = 0.1 // Placeholder values
        }</span>

        <span class="cov1" title="2">response := EmbeddingResponse{
                Success:    true,
                Embeddings: embedding,
                Timestamp:  time.Now(),
        }

        return response, nil</span>
}

// GenerateEmbeddings generates embeddings for text
func (e *EmbeddingManager) GenerateEmbeddings(ctx context.Context, req EmbeddingRequest) (*EmbeddingResponse, error) <span class="cov3" title="9">{
        e.log.WithFields(logrus.Fields{
                "text":      req.Text,
                "model":     req.Model,
                "dimension": req.Dimension,
        }).Info("Generating embeddings")

        // For demonstration, simulate embedding generation
        // In a real implementation, this would call an embedding service
        embeddings := make([]float64, 1536) // Simulate 1536-dimensional embedding
        for i := 0; i &lt; len(embeddings); i++ </span><span class="cov10" title="13824">{
                embeddings[i] = float64(i+1) * 0.1 // Simple simulation
        }</span>

        <span class="cov3" title="9">response := &amp;EmbeddingResponse{
                Timestamp:  time.Now(),
                Success:    true,
                Embeddings: embeddings,
        }

        e.log.WithField("embeddingCount", len(embeddings)).Info("Embeddings generated successfully")
        return response, nil</span>
}

// StoreEmbedding stores embeddings in the vector database
func (e *EmbeddingManager) StoreEmbedding(ctx context.Context, id string, text string, vector []float64) error <span class="cov3" title="10">{
        e.log.WithFields(logrus.Fields{
                "id":   id,
                "text": text[:min(50, len(text))],
        }).Debug("Storing embedding in vector database")

        // In a real implementation, this would store in PostgreSQL with pgvector
        // For now, just cache the embedding
        cacheKey := fmt.Sprintf("embedding_%s", id)
        _ = map[string]interface{}{ // embeddingData would be used in real implementation
                "id":     id,
                "text":   text,
                "vector": vector,
                "stored": time.Now(),
        }

        // This would use the actual cache interface
        e.log.WithField("cacheKey", cacheKey).Debug("Cached embedding data")

        return nil
}</span>

// VectorSearch performs similarity search in the vector database
func (e *EmbeddingManager) VectorSearch(ctx context.Context, req VectorSearchRequest) (*VectorSearchResponse, error) <span class="cov2" title="3">{
        e.log.WithFields(logrus.Fields{
                "query":     req.Query,
                "limit":     req.Limit,
                "threshold": req.Threshold,
        }).Info("Performing vector search")

        // For demonstration, simulate vector search
        // In a real implementation, this would query pgvector
        results := []VectorSearchResult{
                {
                        ID:      "doc1",
                        Content: "This is a sample document about machine learning",
                        Score:   0.95,
                        Metadata: map[string]interface{}{
                                "source": "knowledge_base",
                                "type":   "documentation",
                        },
                },
                {
                        ID:      "doc2",
                        Content: "Another relevant document about AI and ML",
                        Score:   0.87,
                        Metadata: map[string]interface{}{
                                "source": "research_papers",
                                "type":   "academic",
                        },
                },
        }

        response := &amp;VectorSearchResponse{
                Timestamp: time.Now(),
                Success:   true,
                Results:   results,
        }

        e.log.WithField("resultCount", len(results)).Info("Vector search completed")
        return response, nil
}</span>

// GetEmbeddingStats returns statistics about embedding usage
func (e *EmbeddingManager) GetEmbeddingStats(ctx context.Context) (map[string]interface{}, error) <span class="cov1" title="2">{
        stats := map[string]interface{}{
                "totalEmbeddings": 1000, // Simulated
                "vectorDimension": 1536,
                "vectorProvider":  e.vectorProvider,
                "lastUpdate":      time.Now(),
        }

        e.log.WithFields(stats).Info("Embedding statistics retrieved")
        return stats, nil
}</span>

// ConfigureVectorProvider configures the vector database provider
func (e *EmbeddingManager) ConfigureVectorProvider(ctx context.Context, provider string) error <span class="cov1" title="1">{
        e.log.WithField("provider", provider).Info("Configuring vector provider")
        e.vectorProvider = provider
        return nil
}</span>

// IndexDocument indexes a document for semantic search
func (e *EmbeddingManager) IndexDocument(ctx context.Context, id, title, content string, metadata map[string]interface{}) error <span class="cov2" title="7">{
        e.log.WithFields(logrus.Fields{
                "id":    id,
                "title": title,
        }).Info("Indexing document for semantic search")

        // Generate embedding for the document
        embeddingReq := EmbeddingRequest{
                Text:      content,
                Model:     "text-embedding-ada-002",
                Dimension: 1536,
        }

        embeddingResp, err := e.GenerateEmbeddings(ctx, embeddingReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate embedding for document: %w", err)
        }</span>

        // Store the embedding
        <span class="cov2" title="7">err = e.StoreEmbedding(ctx, id, content, embeddingResp.Embeddings)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store embedding: %w", err)
        }</span>

        <span class="cov2" title="7">e.log.WithField("id", id).Info("Document indexed successfully")
        return nil</span>
}

// BatchIndexDocuments indexes multiple documents for semantic search
func (e *EmbeddingManager) BatchIndexDocuments(ctx context.Context, documents []map[string]interface{}) error <span class="cov2" title="3">{
        e.log.WithField("count", len(documents)).Info("Batch indexing documents for semantic search")

        for _, doc := range documents </span><span class="cov2" title="4">{
                id, _ := doc["id"].(string)
                title, _ := doc["title"].(string)
                content, _ := doc["content"].(string)
                metadata, _ := doc["metadata"].(map[string]interface{})

                err := e.IndexDocument(ctx, id, title, content, metadata)
                if err != nil </span><span class="cov0" title="0">{
                        e.log.WithError(err).WithField("id", id).Error("Failed to index document")
                        continue</span> // Continue with other documents
                }

                <span class="cov2" title="4">e.log.WithField("id", id).Debug("Document indexed successfully")</span>
        }

        <span class="cov2" title="3">e.log.Info("Batch document indexing completed")
        return nil</span>
}

// cosineSimilarity calculates cosine similarity between two vectors
func (m *EmbeddingManager) cosineSimilarity(a, b []float64) float64 <span class="cov3" title="12">{
        if len(a) != len(b) </span><span class="cov1" title="2">{
                return 0
        }</span>

        <span class="cov3" title="10">var dotProduct, normA, normB float64
        for i := range a </span><span class="cov4" title="27">{
                dotProduct += a[i] * b[i]
                normA += a[i] * a[i]
                normB += b[i] * b[i]
        }</span>

        <span class="cov3" title="10">if normA == 0 || normB == 0 </span><span class="cov2" title="5">{
                return 0
        }</span>

        <span class="cov2" title="5">return dotProduct / math.Sqrt(normA) / math.Sqrt(normB)</span>
}

// EmbeddingProviderInfo represents information about an embedding provider
type EmbeddingProviderInfo struct {
        Name        string    `json:"name"`
        Model       string    `json:"model"`
        Dimension   int       `json:"dimension"`
        Enabled     bool      `json:"enabled"`
        MaxTokens   int       `json:"maxTokens"`
        Description string    `json:"description"`
        LastSync    time.Time `json:"lastSync,omitempty"`
}

// ListEmbeddingProviders lists all embedding providers
func (m *EmbeddingManager) ListEmbeddingProviders(ctx context.Context) ([]map[string]interface{}, error) <span class="cov2" title="5">{
        m.log.Debug("Listing embedding providers")

        // Define available embedding providers
        providers := []EmbeddingProviderInfo{
                {
                        Name:        "openai-ada",
                        Model:       "text-embedding-ada-002",
                        Dimension:   1536,
                        Enabled:     true,
                        MaxTokens:   8191,
                        Description: "OpenAI Ada v2 embedding model",
                },
                {
                        Name:        "openai-3-small",
                        Model:       "text-embedding-3-small",
                        Dimension:   1536,
                        Enabled:     true,
                        MaxTokens:   8191,
                        Description: "OpenAI text-embedding-3-small",
                },
                {
                        Name:        "openai-3-large",
                        Model:       "text-embedding-3-large",
                        Dimension:   3072,
                        Enabled:     true,
                        MaxTokens:   8191,
                        Description: "OpenAI text-embedding-3-large",
                },
                {
                        Name:        "cohere-multilingual",
                        Model:       "embed-multilingual-v3.0",
                        Dimension:   1024,
                        Enabled:     false,
                        MaxTokens:   512,
                        Description: "Cohere multilingual embedding model",
                },
                {
                        Name:        "local-minilm",
                        Model:       "all-MiniLM-L6-v2",
                        Dimension:   384,
                        Enabled:     true,
                        MaxTokens:   512,
                        Description: "Local sentence-transformers MiniLM model",
                },
        }

        // Convert to map format for API response
        result := make([]map[string]interface{}, len(providers))
        for i, p := range providers </span><span class="cov4" title="25">{
                result[i] = map[string]interface{}{
                        "name":        p.Name,
                        "model":       p.Model,
                        "dimension":   p.Dimension,
                        "enabled":     p.Enabled,
                        "maxTokens":   p.MaxTokens,
                        "description": p.Description,
                }
        }</span>

        <span class="cov2" title="5">m.log.WithField("count", len(providers)).Info("Listed embedding providers")
        return result, nil</span>
}

// RefreshAllEmbeddings refreshes all embedding providers
func (m *EmbeddingManager) RefreshAllEmbeddings(ctx context.Context) error <span class="cov2" title="3">{
        m.log.Info("Starting embedding providers refresh")

        providers, err := m.ListEmbeddingProviders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithError(err).Error("Failed to list embedding providers for refresh")
                return fmt.Errorf("failed to list embedding providers: %w", err)
        }</span>

        <span class="cov2" title="3">var refreshErrors []error
        refreshedCount := 0

        for _, provider := range providers </span><span class="cov3" title="15">{
                providerName, _ := provider["name"].(string)
                enabled, _ := provider["enabled"].(bool)

                if !enabled </span><span class="cov2" title="3">{
                        m.log.WithField("provider", providerName).Debug("Skipping disabled embedding provider")
                        continue</span>
                }

                <span class="cov3" title="12">if err := m.refreshEmbeddingProvider(ctx, providerName); err != nil </span><span class="cov0" title="0">{
                        m.log.WithFields(logrus.Fields{
                                "provider": providerName,
                                "error":    err.Error(),
                        }).Warn("Failed to refresh embedding provider")
                        refreshErrors = append(refreshErrors, err)
                }</span> else<span class="cov3" title="12"> {
                        refreshedCount++
                }</span>
        }

        // Clear embedding cache
        <span class="cov2" title="3">if m.cache != nil </span><span class="cov1" title="1">{
                if invalidator, ok := m.cache.(interface {
                        InvalidateByPattern(ctx context.Context, pattern string) error
                }); ok </span><span class="cov0" title="0">{
                        if err := invalidator.InvalidateByPattern(ctx, "embedding:*"); err != nil </span><span class="cov0" title="0">{
                                m.log.WithError(err).Warn("Failed to invalidate embedding cache during refresh")
                        }</span>
                }
        }

        <span class="cov2" title="3">m.log.WithFields(logrus.Fields{
                "refreshedCount": refreshedCount,
                "totalProviders": len(providers),
                "errorCount":     len(refreshErrors),
        }).Info("Embedding providers refresh completed")

        if len(refreshErrors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to refresh %d of %d providers", len(refreshErrors), len(providers))
        }</span>

        <span class="cov2" title="3">return nil</span>
}

// refreshEmbeddingProvider refreshes a single embedding provider
func (m *EmbeddingManager) refreshEmbeddingProvider(ctx context.Context, providerName string) error <span class="cov3" title="12">{
        m.log.WithField("provider", providerName).Debug("Refreshing embedding provider")

        // In a real implementation, this would:
        // 1. Verify the embedding service is accessible
        // 2. Check API key validity
        // 3. Update model metadata if needed
        // 4. Run a test embedding to verify functionality

        // Simulate provider health check
        time.Sleep(10 * time.Millisecond) // Simulate API call latency

        m.log.WithField("provider", providerName).Info("Embedding provider refreshed successfully")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "sort"
        "sync"
        "time"

        "github.com/superagent/superagent/internal/models"
)

// EnsembleService manages multiple LLM providers and implements voting strategies
type EnsembleService struct {
        providers map[string]LLMProvider
        strategy  string
        timeout   time.Duration
        mu        sync.RWMutex
}

// LLMProvider interface for all LLM providers
type LLMProvider interface {
        Complete(ctx context.Context, req *models.LLMRequest) (*models.LLMResponse, error)
        CompleteStream(ctx context.Context, req *models.LLMRequest) (&lt;-chan *models.LLMResponse, error)
}

// EnsembleResult contains the results from ensemble voting
type EnsembleResult struct {
        Responses    []*models.LLMResponse
        Selected     *models.LLMResponse
        VotingMethod string
        Scores       map[string]float64
        Metadata     map[string]any
}

// VotingStrategy defines different voting strategies
type VotingStrategy interface {
        Vote(responses []*models.LLMResponse, req *models.LLMRequest) (*models.LLMResponse, map[string]float64, error)
}

// ConfidenceWeightedStrategy implements confidence-weighted voting
type ConfidenceWeightedStrategy struct{}

// MajorityVoteStrategy implements majority voting
type MajorityVoteStrategy struct{}

// QualityWeightedStrategy implements quality-based voting
type QualityWeightedStrategy struct{}

func NewEnsembleService(strategy string, timeout time.Duration) *EnsembleService <span class="cov10" title="36">{
        return &amp;EnsembleService{
                providers: make(map[string]LLMProvider),
                strategy:  strategy,
                timeout:   timeout,
        }
}</span>

func (e *EnsembleService) RegisterProvider(name string, provider LLMProvider) <span class="cov9" title="34">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.providers[name] = provider
}</span>

func (e *EnsembleService) RemoveProvider(name string) <span class="cov3" title="3">{
        e.mu.Lock()
        defer e.mu.Unlock()
        delete(e.providers, name)
}</span>

func (e *EnsembleService) GetProviders() []string <span class="cov5" title="6">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        names := make([]string, 0, len(e.providers))
        for name := range e.providers </span><span class="cov5" title="7">{
                names = append(names, name)
        }</span>
        <span class="cov5" title="6">return names</span>
}

func (e *EnsembleService) RunEnsemble(ctx context.Context, req *models.LLMRequest) (*EnsembleResult, error) <span class="cov5" title="6">{
        e.mu.RLock()
        providers := make(map[string]LLMProvider)
        for k, v := range e.providers </span><span class="cov7" title="11">{
                providers[k] = v
        }</span>
        <span class="cov5" title="6">e.mu.RUnlock()

        if len(providers) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no providers available")
        }</span>

        // Filter providers based on request preferences
        <span class="cov5" title="5">filteredProviders := e.filterProviders(providers, req)
        if len(filteredProviders) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no suitable providers available")
        }</span>

        // Create context with timeout
        <span class="cov5" title="5">timeoutCtx, cancel := context.WithTimeout(ctx, e.timeout)
        defer cancel()

        // Execute requests concurrently
        responses := make([]*models.LLMResponse, 0, len(filteredProviders))
        responseChan := make(chan *models.LLMResponse, len(filteredProviders))
        errorChan := make(chan error, len(filteredProviders))

        var wg sync.WaitGroup
        for name, provider := range filteredProviders </span><span class="cov6" title="9">{
                wg.Add(1)
                go func(name string, provider LLMProvider) </span><span class="cov6" title="9">{
                        defer wg.Done()

                        resp, err := provider.Complete(timeoutCtx, req)
                        if err != nil </span><span class="cov3" title="3">{
                                errorChan &lt;- fmt.Errorf("provider %s failed: %w", name, err)
                                return
                        }</span>

                        // Add provider metadata
                        <span class="cov5" title="6">resp.ProviderID = name
                        resp.ProviderName = name
                        responseChan &lt;- resp</span>
                }(name, provider)
        }

        // Wait for all providers to complete
        <span class="cov5" title="5">go func() </span><span class="cov5" title="5">{
                wg.Wait()
                close(responseChan)
                close(errorChan)
        }</span>()

        // Collect responses
        <span class="cov5" title="5">for resp := range responseChan </span><span class="cov5" title="6">{
                responses = append(responses, resp)
        }</span>

        // Check for errors
        <span class="cov5" title="5">var errors []error
        for err := range errorChan </span><span class="cov3" title="3">{
                errors = append(errors, err)
        }</span>

        // If we have some responses, proceed with voting
        <span class="cov5" title="5">if len(responses) &gt; 0 </span><span class="cov4" title="4">{
                selected, scores, err := e.vote(responses, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("voting failed: %w", err)
                }</span>

                <span class="cov4" title="4">return &amp;EnsembleResult{
                        Responses:    responses,
                        Selected:     selected,
                        VotingMethod: e.strategy,
                        Scores:       scores,
                        Metadata: map[string]any{
                                "total_providers":      len(providers),
                                "successful_providers": len(responses),
                                "failed_providers":     len(errors),
                                "errors":               errors,
                                "execution_time":       time.Since(time.Now()).Milliseconds(),
                        },
                }, nil</span>
        }

        // If no responses and we have errors, return the errors
        <span class="cov1" title="1">if len(errors) &gt; 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("all providers failed: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no responses received from any provider")</span>
}

func (e *EnsembleService) RunEnsembleStream(ctx context.Context, req *models.LLMRequest) (&lt;-chan *models.LLMResponse, error) <span class="cov5" title="6">{
        e.mu.RLock()
        providers := make(map[string]LLMProvider)
        for k, v := range e.providers </span><span class="cov5" title="7">{
                providers[k] = v
        }</span>
        <span class="cov5" title="6">e.mu.RUnlock()

        if len(providers) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no providers available")
        }</span>

        // Filter providers based on request preferences
        <span class="cov5" title="5">filteredProviders := e.filterProviders(providers, req)
        if len(filteredProviders) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no suitable providers available")
        }</span>

        // Create context with timeout
        <span class="cov5" title="5">timeoutCtx, cancel := context.WithTimeout(ctx, e.timeout)
        defer cancel()

        // For streaming, we'll use the first available provider for now
        // In a more sophisticated implementation, we could merge streams
        for name, provider := range filteredProviders </span><span class="cov5" title="6">{
                streamChan, err := provider.CompleteStream(timeoutCtx, req)
                if err != nil </span><span class="cov2" title="2">{
                        continue</span>
                }

                // Wrap responses with provider info
                <span class="cov4" title="4">wrappedChan := make(chan *models.LLMResponse)
                go func() </span><span class="cov4" title="4">{
                        defer close(wrappedChan)
                        for resp := range streamChan </span><span class="cov1" title="1">{
                                resp.ProviderID = name
                                resp.ProviderName = name
                                wrappedChan &lt;- resp
                        }</span>
                }()

                <span class="cov4" title="4">return wrappedChan, nil</span>
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("no providers available for streaming")</span>
}

func (e *EnsembleService) filterProviders(providers map[string]LLMProvider, req *models.LLMRequest) map[string]LLMProvider <span class="cov7" title="13">{
        filtered := make(map[string]LLMProvider)

        // If no preferred providers specified, use all
        if req.EnsembleConfig == nil || len(req.EnsembleConfig.PreferredProviders) == 0 </span><span class="cov6" title="9">{
                for k, v := range providers </span><span class="cov7" title="15">{
                        filtered[k] = v
                }</span>
                <span class="cov6" title="9">return filtered</span>
        }

        // Filter by preferred providers
        <span class="cov4" title="4">for _, preferred := range req.EnsembleConfig.PreferredProviders </span><span class="cov5" title="5">{
                if provider, exists := providers[preferred]; exists </span><span class="cov5" title="5">{
                        filtered[preferred] = provider
                }</span>
        }

        // If we don't have enough preferred providers, add more
        <span class="cov4" title="4">minProviders := 2
        if req.EnsembleConfig != nil &amp;&amp; req.EnsembleConfig.MinProviders &gt; 0 </span><span class="cov3" title="3">{
                minProviders = req.EnsembleConfig.MinProviders
        }</span>

        <span class="cov4" title="4">if len(filtered) &lt; minProviders </span><span class="cov2" title="2">{
                // Add additional providers until we reach minimum
                for name, provider := range providers </span><span class="cov3" title="3">{
                        if _, exists := filtered[name]; !exists </span><span class="cov2" title="2">{
                                filtered[name] = provider
                                if len(filtered) &gt;= minProviders </span><span class="cov2" title="2">{
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov4" title="4">return filtered</span>
}

func (e *EnsembleService) vote(responses []*models.LLMResponse, req *models.LLMRequest) (*models.LLMResponse, map[string]float64, error) <span class="cov5" title="5">{
        var strategy VotingStrategy

        switch e.strategy </span>{
        case "confidence_weighted":<span class="cov4" title="4">
                strategy = &amp;ConfidenceWeightedStrategy{}</span>
        case "majority_vote":<span class="cov0" title="0">
                strategy = &amp;MajorityVoteStrategy{}</span>
        case "quality_weighted":<span class="cov0" title="0">
                strategy = &amp;QualityWeightedStrategy{}</span>
        default:<span class="cov1" title="1">
                strategy = &amp;ConfidenceWeightedStrategy{}</span> // Default
        }

        <span class="cov5" title="5">return strategy.Vote(responses, req)</span>
}

// ConfidenceWeightedStrategy implementation
func (s *ConfidenceWeightedStrategy) Vote(responses []*models.LLMResponse, req *models.LLMRequest) (*models.LLMResponse, map[string]float64, error) <span class="cov7" title="16">{
        if len(responses) == 0 </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("no responses to vote on")
        }</span>

        <span class="cov7" title="15">scores := make(map[string]float64)

        // Calculate weighted scores
        for _, resp := range responses </span><span class="cov8" title="23">{
                // Base score from confidence
                score := resp.Confidence

                // Apply weights based on response characteristics
                score = s.applyQualityWeights(resp, score)

                // Apply provider-specific weights if available
                if req.EnsembleConfig != nil &amp;&amp; len(req.EnsembleConfig.PreferredProviders) &gt; 0 </span><span class="cov5" title="6">{
                        for i, preferred := range req.EnsembleConfig.PreferredProviders </span><span class="cov6" title="9">{
                                if resp.ProviderName == preferred </span><span class="cov5" title="5">{
                                        // Higher weight for more preferred providers
                                        weight := 1.0 + (float64(len(req.EnsembleConfig.PreferredProviders)-i) * 0.1)
                                        score *= weight
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="23">scores[resp.ID] = score</span>
        }

        // Select response with highest score
        <span class="cov7" title="15">var selected *models.LLMResponse
        maxScore := -1.0

        for _, resp := range responses </span><span class="cov8" title="23">{
                if score, exists := scores[resp.ID]; exists &amp;&amp; score &gt; maxScore </span><span class="cov8" title="17">{
                        maxScore = score
                        selected = resp
                }</span>
        }

        <span class="cov7" title="15">if selected == nil </span><span class="cov0" title="0">{
                return nil, scores, fmt.Errorf("failed to select response")
        }</span>

        // Mark as selected
        <span class="cov7" title="15">for _, resp := range responses </span><span class="cov8" title="23">{
                resp.Selected = (resp.ID == selected.ID)
                resp.SelectionScore = scores[resp.ID]
        }</span>

        <span class="cov7" title="15">return selected, scores, nil</span>
}

func (s *ConfidenceWeightedStrategy) applyQualityWeights(resp *models.LLMResponse, baseScore float64) float64 <span class="cov8" title="23">{
        score := baseScore

        // Length factor - prefer responses with reasonable length
        contentLength := len(resp.Content)
        if contentLength &gt; 50 &amp;&amp; contentLength &lt; 1000 </span><span class="cov0" title="0">{
                score *= 1.1
        }</span> else<span class="cov8" title="23"> if contentLength &gt;= 1000 &amp;&amp; contentLength &lt; 2000 </span><span class="cov1" title="1">{
                score *= 1.05
        }</span> else<span class="cov8" title="22"> if contentLength &gt;= 2000 </span><span class="cov1" title="1">{
                score *= 0.95 // Too long might be verbose
        }</span>

        // Response time factor - prefer faster responses
        <span class="cov8" title="23">if resp.ResponseTime &lt; 1000 </span><span class="cov8" title="22">{ // &lt; 1 second
                score *= 1.1
        }</span> else<span class="cov1" title="1"> if resp.ResponseTime &lt; 3000 </span><span class="cov0" title="0">{ // &lt; 3 seconds
                score *= 1.05
        }</span> else<span class="cov1" title="1"> if resp.ResponseTime &gt; 10000 </span><span class="cov1" title="1">{ // &gt; 10 seconds
                score *= 0.9
        }</span>

        // Token efficiency factor
        <span class="cov8" title="23">if resp.TokensUsed &gt; 0 </span><span class="cov8" title="21">{
                efficiency := float64(len(resp.Content)) / float64(resp.TokensUsed)
                if efficiency &gt; 3.0 </span><span class="cov2" title="2">{
                        score *= 1.1
                }</span> else<span class="cov8" title="19"> if efficiency &gt; 2.0 </span><span class="cov0" title="0">{
                        score *= 1.05
                }</span>
        }

        // Finish reason factor
        <span class="cov8" title="23">switch resp.FinishReason </span>{
        case "stop":<span class="cov8" title="20">
                score *= 1.1</span>
        case "length":<span class="cov1" title="1">
                score *= 0.95</span>
        case "content_filter":<span class="cov1" title="1">
                score *= 0.7</span>
        }

        <span class="cov8" title="23">return score</span>
}

// MajorityVoteStrategy implementation
func (s *MajorityVoteStrategy) Vote(responses []*models.LLMResponse, req *models.LLMRequest) (*models.LLMResponse, map[string]float64, error) <span class="cov3" title="3">{
        if len(responses) == 0 </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("no responses to vote on")
        }</span>

        // For majority voting, we'll use content similarity as a proxy
        // This is a simplified implementation - in practice, you'd use semantic similarity
        <span class="cov2" title="2">scores := make(map[string]float64)

        // Group similar responses
        responseGroups := make(map[string][]*models.LLMResponse)
        for _, resp := range responses </span><span class="cov4" title="4">{
                // Use first 100 characters as a simple grouping key
                key := resp.Content
                if len(key) &gt; 100 </span><span class="cov0" title="0">{
                        key = key[:100]
                }</span>
                <span class="cov4" title="4">responseGroups[key] = append(responseGroups[key], resp)</span>
        }

        // Find the largest group
        <span class="cov2" title="2">var largestGroup []*models.LLMResponse
        for _, group := range responseGroups </span><span class="cov3" title="3">{
                if len(group) &gt; len(largestGroup) </span><span class="cov3" title="3">{
                        largestGroup = group
                }</span>
        }

        // If we have a clear majority, use it
        <span class="cov2" title="2">if len(largestGroup) &gt; len(responses)/2 </span><span class="cov2" title="2">{
                // Select the highest confidence response from the majority group
                var selected *models.LLMResponse
                maxConfidence := 0.0

                for _, resp := range largestGroup </span><span class="cov3" title="3">{
                        scores[resp.ID] = 1.0 // Majority vote score
                        if resp.Confidence &gt; maxConfidence </span><span class="cov3" title="3">{
                                maxConfidence = resp.Confidence
                                selected = resp
                        }</span>
                }

                // Mark all responses
                <span class="cov2" title="2">for _, resp := range responses </span><span class="cov4" title="4">{
                        resp.Selected = (resp.ID == selected.ID)
                        resp.SelectionScore = scores[resp.ID]
                }</span>

                <span class="cov2" title="2">return selected, scores, nil</span>
        }

        // No clear majority, fall back to confidence weighted
        <span class="cov0" title="0">fallback := &amp;ConfidenceWeightedStrategy{}
        return fallback.Vote(responses, req)</span>
}

// QualityWeightedStrategy implementation
func (s *QualityWeightedStrategy) Vote(responses []*models.LLMResponse, req *models.LLMRequest) (*models.LLMResponse, map[string]float64, error) <span class="cov2" title="2">{
        if len(responses) == 0 </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("no responses to vote on")
        }</span>

        <span class="cov1" title="1">scores := make(map[string]float64)

        for _, resp := range responses </span><span class="cov3" title="3">{
                // Calculate quality score based on multiple factors
                score := s.calculateQualityScore(resp)
                scores[resp.ID] = score
        }</span>

        // Select response with highest quality score
        <span class="cov1" title="1">var selected *models.LLMResponse
        maxScore := -1.0

        for _, resp := range responses </span><span class="cov3" title="3">{
                if score, exists := scores[resp.ID]; exists &amp;&amp; score &gt; maxScore </span><span class="cov2" title="2">{
                        maxScore = score
                        selected = resp
                }</span>
        }

        // Mark all responses
        <span class="cov1" title="1">for _, resp := range responses </span><span class="cov3" title="3">{
                resp.Selected = (resp.ID == selected.ID)
                resp.SelectionScore = scores[resp.ID]
        }</span>

        <span class="cov1" title="1">return selected, scores, nil</span>
}

func (s *QualityWeightedStrategy) calculateQualityScore(resp *models.LLMResponse) float64 <span class="cov3" title="3">{
        score := 0.0

        // Confidence factor (30% weight)
        score += resp.Confidence * 0.3

        // Response time factor (20% weight)
        timeScore := math.Max(0, 1.0-(float64(resp.ResponseTime)/10000.0))
        score += timeScore * 0.2

        // Token efficiency factor (20% weight)
        if resp.TokensUsed &gt; 0 </span><span class="cov3" title="3">{
                efficiency := math.Min(1.0, float64(len(resp.Content))/float64(resp.TokensUsed))
                score += efficiency * 0.2
        }</span>

        // Content length factor (15% weight)
        <span class="cov3" title="3">lengthScore := 0.0
        contentLength := len(resp.Content)
        if contentLength &gt; 50 &amp;&amp; contentLength &lt; 1000 </span><span class="cov0" title="0">{
                lengthScore = 1.0
        }</span> else<span class="cov3" title="3"> if contentLength &gt;= 1000 &amp;&amp; contentLength &lt; 2000 </span><span class="cov0" title="0">{
                lengthScore = 0.8
        }</span> else<span class="cov3" title="3"> if contentLength &gt;= 2000 </span><span class="cov0" title="0">{
                lengthScore = 0.6
        }</span> else<span class="cov3" title="3"> {
                lengthScore = 0.4
        }</span>
        <span class="cov3" title="3">score += lengthScore * 0.15

        // Finish reason factor (15% weight)
        finishScore := 0.0
        switch resp.FinishReason </span>{
        case "stop":<span class="cov2" title="2">
                finishScore = 1.0</span>
        case "length":<span class="cov1" title="1">
                finishScore = 0.7</span>
        case "content_filter":<span class="cov0" title="0">
                finishScore = 0.3</span>
        default:<span class="cov0" title="0">
                finishScore = 0.5</span>
        }
        <span class="cov3" title="3">score += finishScore * 0.15

        return score</span>
}

// Legacy methods for backward compatibility
func (e *EnsembleService) ProcessEnsemble(ctx context.Context, req *models.LLMRequest, responses []*models.LLMResponse) (*models.LLMResponse, error) <span class="cov4" title="4">{
        if req.EnsembleConfig == nil </span><span class="cov2" title="2">{
                // No ensemble, return best response
                return e.selectBestResponse(responses), nil
        }</span>

        <span class="cov2" title="2">config := req.EnsembleConfig

        switch config.Strategy </span>{
        case "confidence_weighted":<span class="cov1" title="1">
                return e.confidenceWeightedVoting(responses, config), nil</span>
        case "majority_vote":<span class="cov1" title="1">
                return e.majorityVoting(responses, config), nil</span>
        default:<span class="cov0" title="0">
                return e.selectBestResponse(responses), nil</span>
        }
}

func (e *EnsembleService) confidenceWeightedVoting(responses []*models.LLMResponse, config *models.EnsembleConfig) *models.LLMResponse <span class="cov4" title="4">{
        if len(responses) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Sort by confidence
        <span class="cov4" title="4">sort.Slice(responses, func(i, j int) bool </span><span class="cov3" title="3">{
                return responses[i].Confidence &gt; responses[j].Confidence
        }</span>)

        // Select highest confidence if above threshold
        <span class="cov4" title="4">if responses[0].Confidence &gt;= config.ConfidenceThreshold </span><span class="cov2" title="2">{
                responses[0].Selected = true
                responses[0].SelectionScore = responses[0].Confidence
                return responses[0]
        }</span>

        // Fallback to best
        <span class="cov2" title="2">if config.FallbackToBest </span><span class="cov1" title="1">{
                responses[0].Selected = true
                responses[0].SelectionScore = responses[0].Confidence
                return responses[0]
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (e *EnsembleService) majorityVoting(responses []*models.LLMResponse, _ *models.EnsembleConfig) *models.LLMResponse <span class="cov3" title="3">{
        // Simplified majority voting
        if len(responses) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // For now, return first
        <span class="cov2" title="2">responses[0].Selected = true
        responses[0].SelectionScore = 1.0
        return responses[0]</span>
}

func (e *EnsembleService) selectBestResponse(responses []*models.LLMResponse) *models.LLMResponse <span class="cov4" title="4">{
        if len(responses) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov2" title="2">best := responses[0]
        for _, resp := range responses[1:] </span><span class="cov3" title="3">{
                if resp.Confidence &gt; best.Confidence </span><span class="cov2" title="2">{
                        best = resp
                }</span>
        }

        <span class="cov2" title="2">best.Selected = true
        best.SelectionScore = best.Confidence
        return best</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolFederation manages cross-protocol communication and data sharing
type ProtocolFederation struct {
        mu            sync.RWMutex
        protocols     map[string]FederatedProtocol
        translators   map[string]*DataTranslator
        eventBus      *EventBus
        subscriptions map[string][]EventSubscription
        logger        *logrus.Logger
}

// FederatedProtocol represents a protocol that can participate in federation
type FederatedProtocol interface {
        Name() string
        HandleFederatedRequest(ctx context.Context, request *FederatedRequest) (*FederatedResponse, error)
        PublishEvent(ctx context.Context, event *ProtocolEvent) error
        GetCapabilities() map[string]interface{}
}

// FederatedRequest represents a cross-protocol request
type FederatedRequest struct {
        ID            string                 `json:"id"`
        Source        string                 `json:"source"`
        Target        string                 `json:"target"`
        Action        string                 `json:"action"`
        Data          map[string]interface{} `json:"data"`
        Timestamp     time.Time              `json:"timestamp"`
        CorrelationID string                 `json:"correlationId,omitempty"`
}

// FederatedResponse represents a cross-protocol response
type FederatedResponse struct {
        ID            string                 `json:"id"`
        Success       bool                   `json:"success"`
        Data          map[string]interface{} `json:"data,omitempty"`
        Error         string                 `json:"error,omitempty"`
        Timestamp     time.Time              `json:"timestamp"`
        CorrelationID string                 `json:"correlationId,omitempty"`
}

// ProtocolEvent represents an event that can be shared across protocols
type ProtocolEvent struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Source    string                 `json:"source"`
        Data      map[string]interface{} `json:"data"`
        Timestamp time.Time              `json:"timestamp"`
}

// EventSubscription represents an event subscription
type EventSubscription struct {
        ID        string
        Protocol  string
        EventType string
        Handler   EventHandler
}

// EventHandler defines an event handler function
type EventHandler func(ctx context.Context, event *ProtocolEvent) error

// EventBus manages event distribution
type EventBus struct {
        subscribers map[string][]EventHandler
        mu          sync.RWMutex
        logger      *logrus.Logger
}

// DataTranslator handles data format translation between protocols
type DataTranslator struct {
        SourceProtocol string
        TargetProtocol string
        Translations   map[string]TranslationRule
}

// TranslationRule defines how to translate data between protocols
type TranslationRule struct {
        SourcePath string
        TargetPath string
        Transform  DataTransform
}

// DataTransform defines a data transformation function
type DataTransform func(input interface{}) (interface{}, error)

// NewProtocolFederation creates a new protocol federation manager
func NewProtocolFederation(logger *logrus.Logger) *ProtocolFederation <span class="cov9" title="21">{
        return &amp;ProtocolFederation{
                protocols:     make(map[string]FederatedProtocol),
                translators:   make(map[string]*DataTranslator),
                eventBus:      NewEventBus(logger),
                subscriptions: make(map[string][]EventSubscription),
                logger:        logger,
        }
}</span>

// RegisterProtocol registers a protocol for federation
func (pf *ProtocolFederation) RegisterProtocol(protocol FederatedProtocol) error <span class="cov9" title="21">{
        pf.mu.Lock()
        defer pf.mu.Unlock()

        name := protocol.Name()
        if _, exists := pf.protocols[name]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("protocol %s already registered", name)
        }</span>

        <span class="cov9" title="20">pf.protocols[name] = protocol

        pf.logger.WithField("protocol", name).Info("Protocol registered for federation")
        return nil</span>
}

// UnregisterProtocol removes a protocol from federation
func (pf *ProtocolFederation) UnregisterProtocol(protocolName string) error <span class="cov2" title="2">{
        pf.mu.Lock()
        defer pf.mu.Unlock()

        if _, exists := pf.protocols[protocolName]; !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("protocol %s not registered", protocolName)
        }</span>

        <span class="cov1" title="1">delete(pf.protocols, protocolName)

        // Clean up subscriptions
        delete(pf.subscriptions, protocolName)

        pf.logger.WithField("protocol", protocolName).Info("Protocol unregistered from federation")
        return nil</span>
}

// SendFederatedRequest sends a request to another protocol
func (pf *ProtocolFederation) SendFederatedRequest(ctx context.Context, request *FederatedRequest) (*FederatedResponse, error) <span class="cov7" title="9">{
        pf.mu.RLock()
        protocol, exists := pf.protocols[request.Target]
        pf.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("target protocol %s not registered", request.Target)
        }</span>

        // Translate data if needed
        <span class="cov6" title="8">translatedRequest := request
        if translator, exists := pf.translators[pf.getTranslatorKey(request.Source, request.Target)]; exists </span><span class="cov2" title="2">{
                var err error
                translatedRequest, err = pf.translateRequest(translator, request)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to translate request: %w", err)
                }</span>
        }

        <span class="cov6" title="7">response, err := protocol.HandleFederatedRequest(ctx, translatedRequest)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Translate response if needed
        <span class="cov6" title="6">if translator, exists := pf.translators[pf.getTranslatorKey(request.Target, request.Source)]; exists </span><span class="cov1" title="1">{
                var err error
                response, err = pf.translateResponse(translator, response)
                if err != nil </span><span class="cov0" title="0">{
                        pf.logger.WithError(err).Warn("Failed to translate response")
                }</span>
        }

        <span class="cov6" title="6">return response, nil</span>
}

// PublishEvent publishes an event to all subscribed protocols
func (pf *ProtocolFederation) PublishEvent(ctx context.Context, event *ProtocolEvent) error <span class="cov1" title="1">{
        return pf.eventBus.Publish(ctx, event)
}</span>

// SubscribeToEvents subscribes a protocol to events
func (pf *ProtocolFederation) SubscribeToEvents(protocolName, eventType string, handler EventHandler) error <span class="cov5" title="5">{
        pf.mu.Lock()
        defer pf.mu.Unlock()

        if _, exists := pf.protocols[protocolName]; !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("protocol %s not registered", protocolName)
        }</span>

        <span class="cov4" title="4">subscription := EventSubscription{
                ID:        fmt.Sprintf("%s-%s-%d", protocolName, eventType, time.Now().Unix()),
                Protocol:  protocolName,
                EventType: eventType,
                Handler:   handler,
        }

        pf.subscriptions[protocolName] = append(pf.subscriptions[protocolName], subscription)

        // Subscribe to event bus
        pf.eventBus.Subscribe(eventType, handler)

        pf.logger.WithFields(logrus.Fields{
                "protocol":  protocolName,
                "eventType": eventType,
        }).Info("Protocol subscribed to events")

        return nil</span>
}

// UnsubscribeFromEvents unsubscribes a protocol from events
func (pf *ProtocolFederation) UnsubscribeFromEvents(protocolName, subscriptionID string) error <span class="cov4" title="3">{
        pf.mu.Lock()
        defer pf.mu.Unlock()

        subscriptions, exists := pf.subscriptions[protocolName]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("no subscriptions found for protocol %s", protocolName)
        }</span>

        <span class="cov2" title="2">for i, sub := range subscriptions </span><span class="cov2" title="2">{
                if sub.ID == subscriptionID </span><span class="cov1" title="1">{
                        pf.subscriptions[protocolName] = append(subscriptions[:i], subscriptions[i+1:]...)
                        break</span>
                }
        }

        <span class="cov2" title="2">pf.logger.WithFields(logrus.Fields{
                "protocol":       protocolName,
                "subscriptionId": subscriptionID,
        }).Info("Protocol unsubscribed from events")

        return nil</span>
}

// AddDataTranslator adds a data translator between protocols
func (pf *ProtocolFederation) AddDataTranslator(translator *DataTranslator) error <span class="cov2" title="2">{
        key := pf.getTranslatorKey(translator.SourceProtocol, translator.TargetProtocol)
        pf.translators[key] = translator

        pf.logger.WithFields(logrus.Fields{
                "source": translator.SourceProtocol,
                "target": translator.TargetProtocol,
        }).Info("Data translator added")

        return nil
}</span>

// GetRegisteredProtocols returns all registered protocols
func (pf *ProtocolFederation) GetRegisteredProtocols() []string <span class="cov4" title="3">{
        pf.mu.RLock()
        defer pf.mu.RUnlock()

        protocols := make([]string, 0, len(pf.protocols))
        for name := range pf.protocols </span><span class="cov4" title="3">{
                protocols = append(protocols, name)
        }</span>

        <span class="cov4" title="3">return protocols</span>
}

// GetProtocolCapabilities returns capabilities for a protocol
func (pf *ProtocolFederation) GetProtocolCapabilities(protocolName string) (map[string]interface{}, error) <span class="cov2" title="2">{
        pf.mu.RLock()
        protocol, exists := pf.protocols[protocolName]
        pf.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("protocol %s not registered", protocolName)
        }</span>

        <span class="cov1" title="1">return protocol.GetCapabilities(), nil</span>
}

// BroadcastRequest broadcasts a request to all registered protocols
func (pf *ProtocolFederation) BroadcastRequest(ctx context.Context, action string, data map[string]interface{}) map[string]*FederatedResponse <span class="cov1" title="1">{
        pf.mu.RLock()
        protocols := make(map[string]FederatedProtocol)
        for k, v := range pf.protocols </span><span class="cov4" title="3">{
                protocols[k] = v
        }</span>
        <span class="cov1" title="1">pf.mu.RUnlock()

        results := make(map[string]*FederatedResponse)
        correlationID := fmt.Sprintf("broadcast-%d", time.Now().Unix())

        for protocolName := range protocols </span><span class="cov4" title="3">{
                request := &amp;FederatedRequest{
                        ID:            fmt.Sprintf("%s-%d", protocolName, time.Now().UnixNano()),
                        Source:        "federation",
                        Target:        protocolName,
                        Action:        action,
                        Data:          data,
                        Timestamp:     time.Now(),
                        CorrelationID: correlationID,
                }

                response, err := pf.SendFederatedRequest(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        results[protocolName] = &amp;FederatedResponse{
                                ID:            request.ID,
                                Success:       false,
                                Error:         err.Error(),
                                Timestamp:     time.Now(),
                                CorrelationID: correlationID,
                        }
                }</span> else<span class="cov4" title="3"> {
                        results[protocolName] = response
                }</span>
        }

        <span class="cov1" title="1">return results</span>
}

// Private methods

func (pf *ProtocolFederation) getTranslatorKey(source, target string) string <span class="cov8" title="16">{
        return fmt.Sprintf("%s-%s", source, target)
}</span>

func (pf *ProtocolFederation) translateRequest(translator *DataTranslator, request *FederatedRequest) (*FederatedRequest, error) <span class="cov5" title="5">{
        translated := &amp;FederatedRequest{
                ID:            request.ID,
                Source:        request.Source,
                Target:        request.Target,
                Action:        request.Action,
                Data:          make(map[string]interface{}),
                Timestamp:     request.Timestamp,
                CorrelationID: request.CorrelationID,
        }

        // Copy original data
        for k, v := range request.Data </span><span class="cov6" title="6">{
                translated.Data[k] = v
        }</span>

        // Apply translations
        <span class="cov5" title="5">for _, rule := range translator.Translations </span><span class="cov4" title="4">{
                if value, exists := pf.getNestedValue(request.Data, rule.SourcePath); exists </span><span class="cov4" title="4">{
                        translatedValue, err := rule.Transform(value)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("translation failed for %s: %w", rule.SourcePath, err)
                        }</span>
                        <span class="cov4" title="3">pf.setNestedValue(translated.Data, rule.TargetPath, translatedValue)</span>
                }
        }

        <span class="cov4" title="4">return translated, nil</span>
}

func (pf *ProtocolFederation) translateResponse(translator *DataTranslator, response *FederatedResponse) (*FederatedResponse, error) <span class="cov4" title="4">{
        translated := &amp;FederatedResponse{
                ID:            response.ID,
                Success:       response.Success,
                Data:          make(map[string]interface{}),
                Error:         response.Error,
                Timestamp:     response.Timestamp,
                CorrelationID: response.CorrelationID,
        }

        // Copy original data
        for k, v := range response.Data </span><span class="cov4" title="4">{
                translated.Data[k] = v
        }</span>

        // Apply translations
        <span class="cov4" title="4">for _, rule := range translator.Translations </span><span class="cov4" title="3">{
                if value, exists := pf.getNestedValue(response.Data, rule.SourcePath); exists </span><span class="cov4" title="3">{
                        translatedValue, err := rule.Transform(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("translation failed for %s: %w", rule.SourcePath, err)
                        }</span>
                        <span class="cov4" title="3">pf.setNestedValue(translated.Data, rule.TargetPath, translatedValue)</span>
                }
        }

        <span class="cov4" title="4">return translated, nil</span>
}

func (pf *ProtocolFederation) getNestedValue(data map[string]interface{}, path string) (interface{}, bool) <span class="cov8" title="13">{
        keys := strings.Split(path, ".")
        current := data

        for i, key := range keys </span><span class="cov9" title="19">{
                if i == len(keys)-1 </span><span class="cov7" title="12">{
                        value, exists := current[key]
                        return value, exists
                }</span>

                <span class="cov6" title="7">if nested, ok := current[key].(map[string]interface{}); ok </span><span class="cov6" title="6">{
                        current = nested
                }</span> else<span class="cov1" title="1"> {
                        return nil, false
                }</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (pf *ProtocolFederation) setNestedValue(data map[string]interface{}, path string, value interface{}) <span class="cov7" title="11">{
        keys := strings.Split(path, ".")
        current := data

        for i, key := range keys </span><span class="cov9" title="18">{
                if i == len(keys)-1 </span><span class="cov7" title="11">{
                        current[key] = value
                        return
                }</span>

                <span class="cov6" title="7">if current[key] == nil </span><span class="cov5" title="5">{
                        current[key] = make(map[string]interface{})
                }</span>

                <span class="cov6" title="7">if nested, ok := current[key].(map[string]interface{}); ok </span><span class="cov6" title="6">{
                        current = nested
                }</span> else<span class="cov1" title="1"> {
                        // Create new nested map
                        newMap := make(map[string]interface{})
                        current[key] = newMap
                        current = newMap
                }</span>
        }
}

// EventBus implementation

// NewEventBus creates a new event bus
func NewEventBus(logger *logrus.Logger) *EventBus <span class="cov10" title="25">{
        return &amp;EventBus{
                subscribers: make(map[string][]EventHandler),
                logger:      logger,
        }
}</span>

// Subscribe subscribes to an event type
func (eb *EventBus) Subscribe(eventType string, handler EventHandler) <span class="cov6" title="7">{
        eb.mu.Lock()
        defer eb.mu.Unlock()

        eb.subscribers[eventType] = append(eb.subscribers[eventType], handler)
        eb.logger.WithField("eventType", eventType).Debug("Event subscription added")
}</span>

// Unsubscribe removes a subscription
func (eb *EventBus) Unsubscribe(eventType string, handler EventHandler) <span class="cov2" title="2">{
        eb.mu.Lock()
        defer eb.mu.Unlock()

        handlers := eb.subscribers[eventType]
        for i, h := range handlers </span><span class="cov1" title="1">{
                if fmt.Sprintf("%p", h) == fmt.Sprintf("%p", handler) </span><span class="cov1" title="1">{
                        eb.subscribers[eventType] = append(handlers[:i], handlers[i+1:]...)
                        break</span>
                }
        }
}

// Publish publishes an event to all subscribers
func (eb *EventBus) Publish(ctx context.Context, event *ProtocolEvent) error <span class="cov4" title="3">{
        eb.mu.RLock()
        handlers := eb.subscribers[event.Type]
        eb.mu.RUnlock()

        if len(handlers) == 0 </span><span class="cov2" title="2">{
                return nil // No subscribers
        }</span>

        // Publish to all handlers (fire and forget for now)
        <span class="cov1" title="1">for _, handler := range handlers </span><span class="cov1" title="1">{
                go func(h EventHandler) </span><span class="cov1" title="1">{
                        if err := h(ctx, event); err != nil </span><span class="cov0" title="0">{
                                eb.logger.WithError(err).WithField("eventType", event.Type).Error("Event handler failed")
                        }</span>
                }(handler)
        }

        <span class="cov1" title="1">eb.logger.WithFields(logrus.Fields{
                "eventType":   event.Type,
                "subscribers": len(handlers),
        }).Debug("Event published")

        return nil</span>
}

// Common data transformations

// IdentityTransform returns the input unchanged
func IdentityTransform(input interface{}) (interface{}, error) <span class="cov6" title="8">{
        return input, nil
}</span>

// StringToIntTransform converts a string to int
func StringToIntTransform(input interface{}) (interface{}, error) <span class="cov4" title="4">{
        if str, ok := input.(string); ok </span><span class="cov4" title="3">{
                // Simple conversion - in real implementation, use strconv
                switch str </span>{
                case "true":<span class="cov1" title="1">
                        return 1, nil</span>
                case "false":<span class="cov1" title="1">
                        return 0, nil</span>
                default:<span class="cov1" title="1">
                        return 0, fmt.Errorf("cannot convert string to int: %s", str)</span>
                }
        }
        <span class="cov1" title="1">return input, nil</span>
}

// JSONTransform marshals/unmarshals JSON
func JSONTransform(input interface{}) (interface{}, error) <span class="cov6" title="6">{
        if data, err := json.Marshal(input); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span> else<span class="cov5" title="5"> {
                var result interface{}
                if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="5">return result, nil</span>
        }
}

// Protocol-specific federation wrappers

// MCPFederatedProtocol wraps MCP for federation
type MCPFederatedProtocol struct {
        client *MCPClient
}

// NewMCPFederatedProtocol creates a new MCP federation wrapper
func NewMCPFederatedProtocol(client *MCPClient) *MCPFederatedProtocol <span class="cov6" title="6">{
        return &amp;MCPFederatedProtocol{client: client}
}</span>

func (m *MCPFederatedProtocol) Name() string <span class="cov2" title="2">{
        return "mcp"
}</span>

func (m *MCPFederatedProtocol) HandleFederatedRequest(ctx context.Context, request *FederatedRequest) (*FederatedResponse, error) <span class="cov5" title="5">{
        // Convert federated request to MCP tool call
        toolName := request.Action
        servers := m.client.ListServers()

        if len(servers) == 0 </span><span class="cov4" title="4">{
                return &amp;FederatedResponse{
                        ID:      request.ID,
                        Success: false,
                        Error:   "no MCP servers available",
                }, nil
        }</span>

        <span class="cov1" title="1">serverID := servers[0].ID // Use first available server
        result, err := m.client.CallTool(ctx, serverID, toolName, request.Data)

        response := &amp;FederatedResponse{
                ID:            request.ID,
                Success:       err == nil,
                CorrelationID: request.CorrelationID,
                Timestamp:     time.Now(),
        }

        if err != nil </span><span class="cov1" title="1">{
                response.Error = err.Error()
        }</span> else<span class="cov0" title="0"> {
                response.Data = map[string]interface{}{
                        "result": result,
                }
        }</span>

        <span class="cov1" title="1">return response, nil</span>
}

func (m *MCPFederatedProtocol) PublishEvent(ctx context.Context, event *ProtocolEvent) error <span class="cov1" title="1">{
        // MCP doesn't have built-in event publishing
        // This could be implemented as tool calls or notifications
        return nil
}</span>

func (m *MCPFederatedProtocol) GetCapabilities() map[string]interface{} <span class="cov1" title="1">{
        tools, err := m.client.ListTools(context.Background())
        toolCount := 0
        if err == nil </span><span class="cov1" title="1">{
                toolCount = len(tools)
        }</span>
        <span class="cov1" title="1">return map[string]interface{}{
                "tools":   toolCount,
                "servers": len(m.client.ListServers()),
                "type":    "mcp",
        }</span>
}

// LSPFederatedProtocol wraps LSP for federation
type LSPFederatedProtocol struct {
        client *LSPClient
}

// NewLSPFederatedProtocol creates a new LSP federation wrapper
func NewLSPFederatedProtocol(client *LSPClient) *LSPFederatedProtocol <span class="cov6" title="6">{
        return &amp;LSPFederatedProtocol{client: client}
}</span>

func (l *LSPFederatedProtocol) Name() string <span class="cov2" title="2">{
        return "lsp"
}</span>

func (l *LSPFederatedProtocol) HandleFederatedRequest(ctx context.Context, request *FederatedRequest) (*FederatedResponse, error) <span class="cov6" title="8">{
        response := &amp;FederatedResponse{
                ID:            request.ID,
                Success:       false,
                CorrelationID: request.CorrelationID,
                Timestamp:     time.Now(),
        }

        // LSP operations typically need file context
        // This is a simplified implementation
        switch request.Action </span>{
        case "completion":<span class="cov6" title="6">
                if uri, ok := request.Data["uri"].(string); ok </span><span class="cov4" title="4">{
                        if line, ok := request.Data["line"].(float64); ok </span><span class="cov4" title="3">{
                                if character, ok := request.Data["character"].(float64); ok </span><span class="cov2" title="2">{
                                        // Use first available server
                                        servers := l.client.ListServers()
                                        if len(servers) &gt; 0 </span><span class="cov1" title="1">{
                                                serverID := servers[0].ID
                                                completion, err := l.client.GetCompletion(ctx, serverID, uri, int(line), int(character))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        response.Error = err.Error()
                                                }</span> else<span class="cov1" title="1"> {
                                                        response.Success = true
                                                        response.Data = map[string]interface{}{
                                                                "completion": completion,
                                                        }
                                                }</span>
                                        } else<span class="cov1" title="1"> {
                                                response.Error = "no LSP servers available"
                                        }</span>
                                } else<span class="cov1" title="1"> {
                                        response.Error = "missing character parameter"
                                }</span>
                        } else<span class="cov1" title="1"> {
                                response.Error = "missing line parameter"
                        }</span>
                } else<span class="cov2" title="2"> {
                        response.Error = "missing uri parameter"
                }</span>
        default:<span class="cov2" title="2">
                response.Error = fmt.Sprintf("unsupported LSP action: %s", request.Action)</span>
        }

        <span class="cov6" title="8">return response, nil</span>
}

func (l *LSPFederatedProtocol) PublishEvent(ctx context.Context, event *ProtocolEvent) error <span class="cov1" title="1">{
        // LSP doesn't have built-in event publishing
        return nil
}</span>

func (l *LSPFederatedProtocol) GetCapabilities() map[string]interface{} <span class="cov1" title="1">{
        servers := l.client.ListServers()
        return map[string]interface{}{
                "servers":   len(servers),
                "type":      "lsp",
                "languages": []string{"go", "python", "typescript", "rust"}, // Common languages
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/superagent/superagent/internal/models"
)

// IntegrationOrchestrator coordinates MCP, LSP, and tool execution
type IntegrationOrchestrator struct {
        mcpManager       *MCPManager
        lspClient        *LSPClient
        toolRegistry     *ToolRegistry
        contextManager   *ContextManager
        providerRegistry *ProviderRegistry
        workflows        map[string]*Workflow
        mu               sync.RWMutex
}

// Workflow represents a sequence of integrated operations
type Workflow struct {
        ID          string
        Name        string
        Description string
        Steps       []WorkflowStep
        Status      string // "pending", "running", "completed", "failed"
        Results     map[string]any
        Errors      []error
        CreatedAt   time.Time
        UpdatedAt   time.Time
}

// WorkflowStep represents a single step in a workflow
type WorkflowStep struct {
        ID         string
        Name       string
        Type       string // "lsp", "mcp", "tool", "llm"
        Parameters map[string]any
        DependsOn  []string // IDs of steps this depends on
        Status     string   // "pending", "running", "completed", "failed"
        Result     any
        Error      error
        StartTime  *time.Time
        EndTime    *time.Time
        RetryCount int
        MaxRetries int
}

// NewIntegrationOrchestrator creates a new orchestrator
func NewIntegrationOrchestrator(mcpManager *MCPManager, lspClient *LSPClient, toolRegistry *ToolRegistry, contextManager *ContextManager) *IntegrationOrchestrator <span class="cov10" title="37">{
        return &amp;IntegrationOrchestrator{
                mcpManager:     mcpManager,
                lspClient:      lspClient,
                toolRegistry:   toolRegistry,
                contextManager: contextManager,
                workflows:      make(map[string]*Workflow),
        }
}</span>

// SetProviderRegistry sets the LLM provider registry for LLM workflow steps
func (io *IntegrationOrchestrator) SetProviderRegistry(registry *ProviderRegistry) <span class="cov1" title="1">{
        io.providerRegistry = registry
}</span>

// ExecuteCodeAnalysis performs comprehensive code analysis
func (io *IntegrationOrchestrator) ExecuteCodeAnalysis(ctx context.Context, filePath string, languageID string) (*models.CodeIntelligence, error) <span class="cov0" title="0">{
        log.Printf("Starting code analysis for %s with language %s", filePath, languageID)
        workflow := &amp;Workflow{
                ID:          fmt.Sprintf("analysis-%d", time.Now().Unix()),
                Name:        "Code Analysis",
                Description: "Comprehensive code analysis using LSP and tools",
                Steps: []WorkflowStep{
                        {
                                ID:         "lsp_init",
                                Name:       "Initialize LSP Client",
                                Type:       "lsp",
                                Parameters: map[string]any{"languageID": languageID, "filePath": filePath},
                        },
                        {
                                ID:         "lsp_intelligence",
                                Name:       "Get Code Intelligence",
                                Type:       "lsp",
                                Parameters: map[string]any{"filePath": filePath},
                                DependsOn:  []string{"lsp_init"},
                        },
                        {
                                ID:         "tool_analysis",
                                Name:       "Run Analysis Tools",
                                Type:       "tool",
                                Parameters: map[string]any{"filePath": filePath},
                                DependsOn:  []string{"lsp_intelligence"},
                        },
                },
                Status:    "pending",
                Results:   make(map[string]interface{}),
                CreatedAt: time.Now(),
        }

        if err := io.executeWorkflow(ctx, workflow); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Combine results
        <span class="cov0" title="0">intelligence := &amp;models.CodeIntelligence{FilePath: filePath}

        if lspResult, ok := workflow.Results["lsp_intelligence"].(*models.CodeIntelligence); ok </span><span class="cov0" title="0">{
                intelligence = lspResult
        }</span>

        <span class="cov0" title="0">return intelligence, nil</span>
}

// ExecuteToolChain executes a chain of tools with dependencies
func (io *IntegrationOrchestrator) ExecuteToolChain(ctx context.Context, toolChain []ToolExecution) (map[string]interface{}, error) <span class="cov1" title="1">{
        workflow := &amp;Workflow{
                ID:          fmt.Sprintf("toolchain-%d", time.Now().Unix()),
                Name:        "Tool Chain Execution",
                Description: "Execute a chain of tools with dependencies",
                Status:      "pending",
                Results:     make(map[string]any),
                CreatedAt:   time.Now(),
        }

        // Convert tool executions to workflow steps
        for i, execution := range toolChain </span><span class="cov0" title="0">{
                step := WorkflowStep{
                        ID:         fmt.Sprintf("tool_%d", i),
                        Name:       execution.ToolName,
                        Type:       "tool",
                        Parameters: execution.Parameters,
                        DependsOn:  execution.DependsOn,
                        MaxRetries: execution.MaxRetries,
                }
                workflow.Steps = append(workflow.Steps, step)
        }</span>

        <span class="cov1" title="1">if err := io.executeWorkflow(ctx, workflow); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return workflow.Results, nil</span>
}

// ExecuteParallelOperations executes multiple operations in parallel
func (io *IntegrationOrchestrator) ExecuteParallelOperations(ctx context.Context, operations []Operation) (map[string]interface{}, error) <span class="cov2" title="2">{
        results := make(map[string]interface{})
        errors := make([]error, 0)

        var wg sync.WaitGroup
        resultChan := make(chan OperationResult, len(operations))

        for _, op := range operations </span><span class="cov2" title="2">{
                wg.Add(1)
                go func(operation Operation) </span><span class="cov2" title="2">{
                        defer wg.Done()
                        result := io.executeOperation(ctx, operation)
                        resultChan &lt;- result
                }</span>(op)
        }

        <span class="cov2" title="2">go func() </span><span class="cov2" title="2">{
                wg.Wait()
                close(resultChan)
        }</span>()

        <span class="cov2" title="2">for result := range resultChan </span><span class="cov2" title="2">{
                if result.Error != nil </span><span class="cov2" title="2">{
                        errors = append(errors, result.Error)
                }</span> else<span class="cov0" title="0"> {
                        results[result.ID] = result.Data
                }</span>
        }

        <span class="cov2" title="2">if len(errors) &gt; 0 </span><span class="cov1" title="1">{
                return results, fmt.Errorf("parallel execution had %d errors: %v", len(errors), errors)
        }</span>

        <span class="cov1" title="1">return results, nil</span>
}

// executeWorkflow executes a workflow with proper dependency management
func (io *IntegrationOrchestrator) executeWorkflow(ctx context.Context, workflow *Workflow) error <span class="cov5" title="6">{
        workflow.Status = "running"
        workflow.UpdatedAt = time.Now()

        // Build dependency graph
        dependencyGraph := io.buildDependencyGraph(workflow.Steps)

        // Execute steps in topological order
        completed := make(map[string]bool)
        running := make(map[string]bool)

        // Mutex to protect shared state accessed by goroutines
        var mu sync.Mutex

        for </span><span class="cov7" title="13">{
                mu.Lock()
                completedCount := len(completed)
                mu.Unlock()

                if completedCount &gt;= len(workflow.Steps) </span><span class="cov5" title="6">{
                        break</span>
                }

                // Find steps that can be executed
                <span class="cov5" title="7">mu.Lock()
                executable := io.findExecutableSteps(workflow.Steps, dependencyGraph, completed, running)
                mu.Unlock()

                if len(executable) == 0 </span><span class="cov0" title="0">{
                        // Check for circular dependencies or deadlocks
                        mu.Lock()
                        runningCount := len(running)
                        mu.Unlock()

                        if runningCount &gt; 0 </span><span class="cov0" title="0">{
                                // Wait for running steps to complete
                                time.Sleep(100 * time.Millisecond)
                                continue</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("workflow deadlock or circular dependency detected")</span>
                }

                // Execute steps in parallel
                <span class="cov5" title="7">var wg sync.WaitGroup
                for _, step := range executable </span><span class="cov6" title="9">{
                        wg.Add(1)
                        mu.Lock()
                        running[step.ID] = true
                        mu.Unlock()

                        go func(s WorkflowStep) </span><span class="cov6" title="9">{
                                defer wg.Done()
                                defer func() </span><span class="cov6" title="9">{
                                        mu.Lock()
                                        delete(running, s.ID)
                                        mu.Unlock()
                                }</span>()

                                <span class="cov6" title="9">result, err := io.executeStep(ctx, &amp;s)
                                mu.Lock()
                                if err != nil </span><span class="cov6" title="9">{
                                        s.Error = err
                                        s.Status = "failed"
                                        workflow.Errors = append(workflow.Errors, err)
                                }</span> else<span class="cov0" title="0"> {
                                        s.Result = result
                                        s.Status = "completed"
                                        workflow.Results[s.ID] = result
                                }</span>

                                <span class="cov6" title="9">s.EndTime = &amp;time.Time{}
                                *s.EndTime = time.Now()
                                completed[s.ID] = true
                                mu.Unlock()</span>
                        }(step)
                }

                <span class="cov5" title="7">wg.Wait()</span>
        }

        <span class="cov5" title="6">workflow.Status = "completed"
        workflow.UpdatedAt = time.Now()

        return nil</span>
}

// executeStep executes a single workflow step
func (io *IntegrationOrchestrator) executeStep(ctx context.Context, step *WorkflowStep) (any, error) <span class="cov7" title="14">{
        step.Status = "running"
        now := time.Now()
        step.StartTime = &amp;now

        defer func() </span><span class="cov7" title="14">{
                step.EndTime = &amp;time.Time{}
                *step.EndTime = time.Now()
        }</span>()

        <span class="cov7" title="14">var result interface{}
        var err error

        switch step.Type </span>{
        case "lsp":<span class="cov1" title="1">
                result, err = io.executeLSPStep(ctx, step)</span>
        case "mcp":<span class="cov1" title="1">
                result, err = io.executeMCPStep(ctx, step)</span>
        case "tool":<span class="cov1" title="1">
                result, err = io.executeToolStep(ctx, step)</span>
        case "llm":<span class="cov1" title="1">
                result, err = io.executeLLMStep(ctx, step)</span>
        default:<span class="cov6" title="10">
                err = fmt.Errorf("unknown step type: %s", step.Type)</span>
        }

        // Retry logic
        <span class="cov7" title="14">for err != nil &amp;&amp; step.RetryCount &lt; step.MaxRetries </span><span class="cov0" title="0">{
                step.RetryCount++
                log.Printf("Retrying step %s (attempt %d)", step.ID, step.RetryCount+1)

                time.Sleep(time.Duration(step.RetryCount) * time.Second)

                switch step.Type </span>{
                case "lsp":<span class="cov0" title="0">
                        result, err = io.executeLSPStep(ctx, step)</span>
                case "mcp":<span class="cov0" title="0">
                        result, err = io.executeMCPStep(ctx, step)</span>
                case "tool":<span class="cov0" title="0">
                        result, err = io.executeToolStep(ctx, step)</span>
                case "llm":<span class="cov0" title="0">
                        result, err = io.executeLLMStep(ctx, step)</span>
                }
        }

        <span class="cov7" title="14">return result, err</span>
}

// executeLSPStep executes an LSP-related step
func (io *IntegrationOrchestrator) executeLSPStep(ctx context.Context, step *WorkflowStep) (any, error) <span class="cov4" title="4">{
        switch step.Name </span>{
        case "Initialize LSP Client":<span class="cov1" title="1">
                return nil, io.lspClient.StartServer(ctx)</span>
        case "Get Code Intelligence":<span class="cov0" title="0">
                filePath, _ := step.Parameters["filePath"].(string)
                return io.lspClient.GetCodeIntelligence(ctx, filePath, nil)</span>
        default:<span class="cov3" title="3">
                return nil, fmt.Errorf("unknown LSP step: %s", step.Name)</span>
        }
}

// executeMCPStep executes an MCP-related step
func (io *IntegrationOrchestrator) executeMCPStep(ctx context.Context, step *WorkflowStep) (any, error) <span class="cov6" title="9">{
        if io.mcpManager == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("MCP manager not available")
        }</span>

        // Extract MCP operation parameters
        <span class="cov6" title="8">operation, ok := step.Parameters["operation"].(string)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("MCP operation parameter required")
        }</span>

        <span class="cov5" title="7">switch operation </span>{
        case "list_tools":<span class="cov2" title="2">
                return io.mcpManager.ListTools(), nil</span>

        case "call_tool":<span class="cov2" title="2">
                toolName, ok := step.Parameters["toolName"].(string)
                if !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("toolName parameter required for call_tool operation")
                }</span>

                <span class="cov1" title="1">params, ok := step.Parameters["params"].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        params = make(map[string]interface{})
                }</span>

                <span class="cov1" title="1">return io.mcpManager.CallTool(ctx, toolName, params)</span>

        case "list_servers":<span class="cov1" title="1">
                servers, err := io.mcpManager.ListMCPServers(ctx)
                return servers, err</span>

        case "register_server":<span class="cov1" title="1">
                serverConfig, ok := step.Parameters["serverConfig"].(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("serverConfig parameter required for register_server operation")
                }</span>

                <span class="cov0" title="0">return nil, io.mcpManager.RegisterServer(serverConfig)</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unknown MCP operation: %s", operation)</span>
        }
}

// executeToolStep executes a tool-related step
func (io *IntegrationOrchestrator) executeToolStep(ctx context.Context, step *WorkflowStep) (any, error) <span class="cov3" title="3">{
        toolName, ok := step.Parameters["toolName"].(string)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("toolName parameter required")
        }</span>

        <span class="cov2" title="2">return io.toolRegistry.ExecuteTool(ctx, toolName, step.Parameters)</span>
}

// executeLLMStep executes an LLM-related step
func (io *IntegrationOrchestrator) executeLLMStep(ctx context.Context, step *WorkflowStep) (any, error) <span class="cov4" title="4">{
        // Extract LLM operation parameters
        operation, ok := step.Parameters["operation"].(string)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("LLM operation parameter required")
        }</span>

        // Check if provider registry is available
        <span class="cov3" title="3">if io.providerRegistry == nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("LLM provider registry not configured")
        }</span>

        // Get provider name (default to first available)
        <span class="cov1" title="1">providerName, _ := step.Parameters["provider"].(string)
        if providerName == "" </span><span class="cov1" title="1">{
                providers := io.providerRegistry.ListProviders()
                if len(providers) == 0 </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("no LLM providers available")
                }</span>
                <span class="cov0" title="0">providerName = providers[0]</span>
        }

        <span class="cov0" title="0">provider, err := io.providerRegistry.GetProvider(providerName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider %s: %w", providerName, err)
        }</span>

        // Build the LLM request
        <span class="cov0" title="0">llmReq, err := io.buildLLMRequest(step)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch operation </span>{
        case "complete":<span class="cov0" title="0">
                return provider.Complete(ctx, llmReq)</span>

        case "stream":<span class="cov0" title="0">
                // Get the streaming channel from provider
                streamChan, err := provider.CompleteStream(ctx, llmReq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to start streaming: %w", err)
                }</span>

                // Collect all streamed responses into a single result
                <span class="cov0" title="0">var fullContent string
                var lastResponse *models.LLMResponse

                for response := range streamChan </span><span class="cov0" title="0">{
                        if response != nil </span><span class="cov0" title="0">{
                                fullContent += response.Content
                                lastResponse = response
                        }</span>
                }

                // Return combined response
                <span class="cov0" title="0">if lastResponse != nil </span><span class="cov0" title="0">{
                        lastResponse.Content = fullContent
                        return lastResponse, nil
                }</span>

                <span class="cov0" title="0">return &amp;models.LLMResponse{
                        ID:        fmt.Sprintf("workflow-%s-%d", step.ID, time.Now().Unix()),
                        RequestID: llmReq.ID,
                        Content:   fullContent,
                        CreatedAt: time.Now(),
                }, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown LLM operation: %s", operation)</span>
        }
}

// buildLLMRequest constructs an LLMRequest from workflow step parameters
func (io *IntegrationOrchestrator) buildLLMRequest(step *WorkflowStep) (*models.LLMRequest, error) <span class="cov5" title="6">{
        prompt, _ := step.Parameters["prompt"].(string)
        model, _ := step.Parameters["model"].(string)
        if model == "" </span><span class="cov5" title="5">{
                model = "default"
        }</span>

        <span class="cov5" title="6">llmReq := &amp;models.LLMRequest{
                ID:     fmt.Sprintf("workflow-%s-%d", step.ID, time.Now().Unix()),
                Prompt: prompt,
                ModelParams: models.ModelParameters{
                        Model: model,
                },
                CreatedAt: time.Now(),
        }

        // Add temperature if provided
        if temp, ok := step.Parameters["temperature"].(float64); ok </span><span class="cov1" title="1">{
                llmReq.ModelParams.Temperature = temp
        }</span>

        // Add max_tokens if provided
        <span class="cov5" title="6">if maxTokens, ok := step.Parameters["max_tokens"].(int); ok </span><span class="cov1" title="1">{
                llmReq.ModelParams.MaxTokens = maxTokens
        }</span> else<span class="cov5" title="5"> if maxTokensFloat, ok := step.Parameters["max_tokens"].(float64); ok </span><span class="cov1" title="1">{
                llmReq.ModelParams.MaxTokens = int(maxTokensFloat)
        }</span>

        // Add messages if provided
        <span class="cov5" title="6">if messages, ok := step.Parameters["messages"].([]interface{}); ok </span><span class="cov1" title="1">{
                llmMessages := make([]models.Message, 0, len(messages))
                for _, msg := range messages </span><span class="cov2" title="2">{
                        if msgMap, ok := msg.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                                role, _ := msgMap["role"].(string)
                                content, _ := msgMap["content"].(string)
                                llmMessages = append(llmMessages, models.Message{
                                        Role:    role,
                                        Content: content,
                                })
                        }</span>
                }
                <span class="cov1" title="1">llmReq.Messages = llmMessages</span>
        }

        <span class="cov5" title="6">return llmReq, nil</span>
}

// executeOperation executes a single operation
func (io *IntegrationOrchestrator) executeOperation(ctx context.Context, op Operation) OperationResult <span class="cov5" title="5">{
        result := OperationResult{ID: op.ID}

        switch op.Type </span>{
        case "lsp":<span class="cov1" title="1">
                data, err := io.executeLSPStep(ctx, &amp;WorkflowStep{Name: op.Name, Parameters: op.Parameters})
                result.Data = data
                result.Error = err</span>
        case "tool":<span class="cov1" title="1">
                data, err := io.executeToolStep(ctx, &amp;WorkflowStep{Parameters: op.Parameters})
                result.Data = data
                result.Error = err</span>
        default:<span class="cov3" title="3">
                result.Error = fmt.Errorf("unknown operation type: %s", op.Type)</span>
        }

        <span class="cov5" title="5">return result</span>
}

// Helper methods

func (io *IntegrationOrchestrator) buildDependencyGraph(steps []WorkflowStep) map[string][]string <span class="cov6" title="10">{
        graph := make(map[string][]string)
        stepMap := make(map[string]*WorkflowStep)

        for i := range steps </span><span class="cov7" title="16">{
                stepMap[steps[i].ID] = &amp;steps[i]
                graph[steps[i].ID] = steps[i].DependsOn
        }</span>

        // Detect cycles
        <span class="cov6" title="10">if io.hasCycles(graph) </span><span class="cov0" title="0">{
                log.Printf("Warning: Cycle detected in workflow dependencies")
                // Could implement cycle breaking logic here
        }</span>

        <span class="cov6" title="10">return graph</span>
}

// hasCycles detects if the dependency graph has cycles
func (io *IntegrationOrchestrator) hasCycles(graph map[string][]string) bool <span class="cov7" title="16">{
        visited := make(map[string]bool)
        recStack := make(map[string]bool)

        for node := range graph </span><span class="cov9" title="26">{
                if !visited[node] </span><span class="cov9" title="25">{
                        if io.hasCyclesUtil(node, graph, visited, recStack) </span><span class="cov3" title="3">{
                                return true
                        }</span>
                }
        }
        <span class="cov7" title="13">return false</span>
}

// hasCyclesUtil is a utility function for cycle detection
func (io *IntegrationOrchestrator) hasCyclesUtil(node string, graph map[string][]string, visited, recStack map[string]bool) bool <span class="cov9" title="35">{
        visited[node] = true
        recStack[node] = true

        for _, neighbor := range graph[node] </span><span class="cov9" title="25">{
                if !visited[neighbor] &amp;&amp; io.hasCyclesUtil(neighbor, graph, visited, recStack) </span><span class="cov5" title="5">{
                        return true
                }</span> else<span class="cov8" title="20"> if recStack[neighbor] </span><span class="cov4" title="4">{
                        return true
                }</span>
        }

        <span class="cov9" title="26">recStack[node] = false
        return false</span>
}

func (io *IntegrationOrchestrator) findExecutableSteps(steps []WorkflowStep, graph map[string][]string, completed, running map[string]bool) []WorkflowStep <span class="cov7" title="14">{
        var executable []WorkflowStep

        for _, step := range steps </span><span class="cov9" title="34">{
                if completed[step.ID] || running[step.ID] </span><span class="cov7" title="12">{
                        continue</span>
                }

                // Check if all dependencies are completed
                <span class="cov8" title="22">canExecute := true
                for _, dep := range graph[step.ID] </span><span class="cov7" title="14">{
                        if !completed[dep] </span><span class="cov5" title="6">{
                                canExecute = false
                                break</span>
                        }
                }

                <span class="cov8" title="22">if canExecute </span><span class="cov7" title="16">{
                        executable = append(executable, step)
                }</span>
        }

        <span class="cov7" title="14">return executable</span>
}

// Data structures

// ToolExecution represents a tool execution request
type ToolExecution struct {
        ToolName   string
        Parameters map[string]any
        DependsOn  []string
        MaxRetries int
}

// Operation represents a single operation to execute
type Operation struct {
        ID         string
        Type       string
        Name       string
        Parameters map[string]interface{}
}

// OperationResult represents the result of an operation
type OperationResult struct {
        ID    string
        Data  interface{}
        Error error
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// LSPManager handles LSP (Language Server Protocol) operations
type LSPManager struct {
        repo  *database.ModelMetadataRepository
        cache CacheInterface
        log   *logrus.Logger
}

// LSPServer represents an LSP server configuration
type LSPServer struct {
        ID           string          `json:"id"`
        Name         string          `json:"name"`
        Language     string          `json:"language"`
        Command      string          `json:"command"`
        Enabled      bool            `json:"enabled"`
        Workspace    string          `json:"workspace"`
        LastSync     *time.Time      `json:"lastSync"`
        Capabilities []LSPCapability `json:"capabilities"`
}

// LSPCapability represents a capability of an LSP server
type LSPCapability struct {
        Name        string `json:"name"`
        Description string `json:"description"`
}

// LSPRequest represents a request to an LSP server
type LSPRequest struct {
        ServerID string                 `json:"serverId"`
        Method   string                 `json:"method"`
        Params   map[string]interface{} `json:"params"`
        Text     string                 `json:"text,omitempty"`
        FileURI  string                 `json:"fileUri,omitempty"`
        Position LSPPosition            `json:"position,omitempty"`
}

// LSPPosition represents a position in a file for LSP operations
type LSPPosition struct {
        Line      int `json:"line"`
        Character int `json:"character"`
}

// LSPResponse represents a response from an LSP server
type LSPResponse struct {
        Success   bool        `json:"success"`
        Result    interface{} `json:"result,omitempty"`
        Error     string      `json:"error,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
}

// NewLSPManager creates a new LSP manager
func NewLSPManager(repo *database.ModelMetadataRepository, cache CacheInterface, log *logrus.Logger) *LSPManager <span class="cov9" title="25">{
        return &amp;LSPManager{
                repo:  repo,
                cache: cache,
                log:   log,
        }
}</span>

// ListLSPServers lists all configured LSP servers
func (l *LSPManager) ListLSPServers(ctx context.Context) ([]LSPServer, error) <span class="cov8" title="20">{
        // For demonstration, return some example LSP servers
        servers := []LSPServer{
                {
                        ID:        "gopls",
                        Name:      "Go Language Server",
                        Language:  "go",
                        Command:   "gopls",
                        Enabled:   true,
                        Workspace: "/workspace",
                        Capabilities: []LSPCapability{
                                {Name: "completion", Description: "Code completion"},
                                {Name: "diagnostics", Description: "Code diagnostics"},
                                {Name: "hover", Description: "Hover information"},
                                {Name: "definition", Description: "Go to definition"},
                                {Name: "references", Description: "Find references"},
                        },
                },
                {
                        ID:        "rust-analyzer",
                        Name:      "Rust Analyzer",
                        Language:  "rust",
                        Command:   "rust-analyzer",
                        Enabled:   true,
                        Workspace: "/workspace",
                        Capabilities: []LSPCapability{
                                {Name: "completion", Description: "Code completion"},
                                {Name: "diagnostics", Description: "Code diagnostics"},
                                {Name: "hover", Description: "Hover information"},
                        },
                },
                {
                        ID:        "pylsp",
                        Name:      "Python Language Server",
                        Language:  "python",
                        Command:   "pylsp",
                        Enabled:   true,
                        Workspace: "/workspace",
                        Capabilities: []LSPCapability{
                                {Name: "completion", Description: "Code completion"},
                                {Name: "diagnostics", Description: "Code diagnostics"},
                                {Name: "hover", Description: "Hover information"},
                                {Name: "definition", Description: "Go to definition"},
                        },
                },
                {
                        ID:        "ts-language-server",
                        Name:      "TypeScript Language Server",
                        Language:  "typescript",
                        Command:   "typescript-language-server",
                        Enabled:   true,
                        Workspace: "/workspace",
                        Capabilities: []LSPCapability{
                                {Name: "completion", Description: "Code completion"},
                                {Name: "diagnostics", Description: "Code diagnostics"},
                                {Name: "hover", Description: "Hover information"},
                                {Name: "definition", Description: "Go to definition"},
                                {Name: "references", Description: "Find references"},
                        },
                },
        }

        l.log.WithField("count", len(servers)).Info("Listed LSP servers")
        return servers, nil
}</span>

// GetLSPServer gets a specific LSP server by ID
func (l *LSPManager) GetLSPServer(ctx context.Context, serverID string) (*LSPServer, error) <span class="cov7" title="14">{
        servers, err := l.ListLSPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="14">for _, server := range servers </span><span class="cov10" title="35">{
                if server.ID == serverID </span><span class="cov7" title="11">{
                        return &amp;server, nil
                }</span>
        }

        <span class="cov3" title="3">return nil, fmt.Errorf("LSP server %s not found", serverID)</span>
}

// ExecuteLSPRequest executes a method on an LSP server
func (l *LSPManager) ExecuteLSPRequest(ctx context.Context, req LSPRequest) (*LSPResponse, error) <span class="cov1" title="1">{
        l.log.WithFields(logrus.Fields{
                "serverId": req.ServerID,
                "method":   req.Method,
        }).Info("Executing LSP request")

        // For demonstration, simulate LSP request execution
        // In a real implementation, this would communicate with the LSP server
        response := &amp;LSPResponse{
                Timestamp: time.Now(),
                Success:   true,
                Result: map[string]interface{}{
                        "message": fmt.Sprintf("Executed %s on server %s", req.Method, req.ServerID),
                        "data":    req.Params,
                },
        }

        // Cache the response
        cacheKey := fmt.Sprintf("lsp_response_%s_%s", req.ServerID, req.Method)
        _, _ = json.Marshal(response) // responseJSON would be used in real implementation

        // This would use the actual cache interface
        l.log.WithField("cacheKey", cacheKey).Debug("Cached LSP response")

        return response, nil
}</span>

// GetDiagnostics gets diagnostics for a file from an LSP server
func (l *LSPManager) GetDiagnostics(ctx context.Context, serverID, fileURI string) (interface{}, error) <span class="cov1" title="1">{
        l.log.WithFields(logrus.Fields{
                "serverId": serverID,
                "fileUri":  fileURI,
        }).Info("Getting LSP diagnostics")

        // Simulate diagnostics response
        diagnostics := map[string]interface{}{
                "serverId": serverID,
                "fileUri":  fileURI,
                "diagnostics": []map[string]interface{}{
                        {
                                "range": map[string]interface{}{
                                        "start": map[string]int{"line": 1, "character": 1},
                                        "end":   map[string]int{"line": 1, "character": 50},
                                },
                                "severity": "error",
                                "message":  "Unresolved variable",
                                "source":   "go",
                        },
                        {
                                "range": map[string]interface{}{
                                        "start": map[string]int{"line": 2, "character": 5},
                                        "end":   map[string]int{"line": 2, "character": 25},
                                },
                                "severity": "warning",
                                "message":  "Unused import",
                                "source":   "go",
                        },
                },
                "timestamp": time.Now(),
        }

        return diagnostics, nil
}</span>

// GetCodeActions gets code actions for a position from an LSP server
func (l *LSPManager) GetCodeActions(ctx context.Context, serverID, text, fileURI string, position LSPPosition) (interface{}, error) <span class="cov1" title="1">{
        l.log.WithFields(logrus.Fields{
                "serverId": serverID,
                "fileUri":  fileURI,
                "line":     position.Line,
        }).Info("Getting LSP code actions")

        // Simulate code actions response
        actions := map[string]interface{}{
                "serverId": serverID,
                "fileUri":  fileURI,
                "actions": []map[string]interface{}{
                        {
                                "title":   "Go to definition",
                                "command": "editor.action.goToDefinition",
                                "arguments": map[string]interface{}{
                                        "uri": fmt.Sprintf("file://%s#%d", fileURI, position.Line),
                                },
                        },
                        {
                                "title":   "Quick fix",
                                "command": "editor.action.quickFix",
                                "arguments": map[string]interface{}{
                                        "fix": "remove unused import",
                                        "range": map[string]interface{}{
                                                "start": map[string]int{"line": 2, "character": 5},
                                                "end":   map[string]int{"line": 2, "character": 25},
                                        },
                                },
                        },
                },
                "timestamp": time.Now(),
        }

        return actions, nil
}</span>

// GetCompletion gets completion suggestions from an LSP server
func (l *LSPManager) GetCompletion(ctx context.Context, serverID, text, fileURI string, position LSPPosition) (interface{}, error) <span class="cov1" title="1">{
        l.log.WithFields(logrus.Fields{
                "serverId": serverID,
                "fileUri":  fileURI,
                "text":     text,
        }).Info("Getting LSP completion")

        // Simulate completion response
        completions := map[string]interface{}{
                "serverId": serverID,
                "fileUri":  fileURI,
                "completions": []map[string]interface{}{
                        {
                                "label":      "fmt.Printf(\"hello, %s\\n\", name)",
                                "text":       "fmt.Printf(\"hello, %s\\n\", name)",
                                "insertText": "fmt.Printf(\"hello, %s\\n\", name)",
                                "filterText": "fmt",
                        },
                        {
                                "label":      "fmt.Println(name)",
                                "text":       "fmt.Println(name)",
                                "insertText": "fmt.Println(name)",
                                "filterText": "fmt",
                        },
                },
                "timestamp": time.Now(),
        }

        return completions, nil
}</span>

// ValidateLSPRequest validates an LSP request
func (l *LSPManager) ValidateLSPRequest(ctx context.Context, req LSPRequest) error <span class="cov4" title="4">{
        // Basic validation
        if req.ServerID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("server ID is required")
        }</span>

        <span class="cov3" title="3">if req.Method == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("method is required")
        }</span>

        // Check if server exists
        <span class="cov2" title="2">server, err := l.GetLSPServer(ctx, req.ServerID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid server ID: %w", err)
        }</span>

        <span class="cov1" title="1">if !server.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("server %s is not enabled", req.ServerID)
        }</span>

        <span class="cov1" title="1">return nil</span> // Validation passed
}

// SyncLSPServer synchronizes configuration with an LSP server
func (l *LSPManager) SyncLSPServer(ctx context.Context, serverID string) error <span class="cov2" title="2">{
        return l.refreshLSPServer(ctx, serverID)
}</span>

// GetLSPStats returns statistics about LSP usage
func (l *LSPManager) GetLSPStats(ctx context.Context) (map[string]interface{}, error) <span class="cov2" title="2">{
        servers, err := l.ListLSPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">enabledCount := 0
        totalCapabilities := 0

        for _, server := range servers </span><span class="cov6" title="8">{
                if server.Enabled </span><span class="cov6" title="8">{
                        enabledCount++
                        totalCapabilities += len(server.Capabilities)
                }</span>
        }

        <span class="cov2" title="2">stats := map[string]interface{}{
                "totalServers":      len(servers),
                "enabledServers":    enabledCount,
                "totalCapabilities": totalCapabilities,
                "lastSync":          time.Now(),
        }

        l.log.WithFields(stats).Info("LSP statistics retrieved")
        return stats, nil</span>
}

// RefreshAllLSPServers refreshes all LSP servers
func (m *LSPManager) RefreshAllLSPServers(ctx context.Context) error <span class="cov2" title="2">{
        servers, err := m.ListLSPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithError(err).Error("Failed to list LSP servers for refresh")
                return fmt.Errorf("failed to list LSP servers: %w", err)
        }</span>

        <span class="cov2" title="2">var refreshErrors []error
        refreshedCount := 0

        for _, server := range servers </span><span class="cov6" title="8">{
                if !server.Enabled </span><span class="cov0" title="0">{
                        m.log.WithField("serverId", server.ID).Debug("Skipping disabled LSP server")
                        continue</span>
                }

                <span class="cov6" title="8">if err := m.refreshLSPServer(ctx, server.ID); err != nil </span><span class="cov0" title="0">{
                        m.log.WithFields(logrus.Fields{
                                "serverId": server.ID,
                                "error":    err.Error(),
                        }).Warn("Failed to refresh LSP server")
                        refreshErrors = append(refreshErrors, err)
                }</span> else<span class="cov6" title="8"> {
                        refreshedCount++
                }</span>
        }

        <span class="cov2" title="2">m.log.WithFields(logrus.Fields{
                "refreshedCount": refreshedCount,
                "totalServers":   len(servers),
                "errorCount":     len(refreshErrors),
        }).Info("LSP servers refresh completed")

        if len(refreshErrors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to refresh %d of %d servers", len(refreshErrors), len(servers))
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// refreshLSPServer refreshes a single LSP server by ID
func (m *LSPManager) refreshLSPServer(ctx context.Context, serverID string) error <span class="cov6" title="10">{
        server, err := m.GetLSPServer(ctx, serverID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="9">m.log.WithFields(logrus.Fields{
                "serverId": serverID,
                "language": server.Language,
        }).Debug("Refreshing LSP server")

        // In a real implementation, this would:
        // 1. Check if the LSP server process is running
        // 2. Send an initialization request if needed
        // 3. Update capabilities
        // 4. Invalidate relevant cache entries

        // For now, we simulate the refresh by updating the lastSync time
        now := time.Now()
        server.LastSync = &amp;now

        // Clear any cached responses for this server
        cachePattern := fmt.Sprintf("lsp_response_%s_*", serverID)
        if m.cache != nil </span><span class="cov0" title="0">{
                if invalidator, ok := m.cache.(interface {
                        InvalidateByPattern(ctx context.Context, pattern string) error
                }); ok </span><span class="cov0" title="0">{
                        if err := invalidator.InvalidateByPattern(ctx, cachePattern); err != nil </span><span class="cov0" title="0">{
                                m.log.WithError(err).Warn("Failed to invalidate cache entries during refresh")
                        }</span>
                }
        }

        <span class="cov6" title="9">m.log.WithFields(logrus.Fields{
                "serverId": serverID,
                "lastSync": now,
        }).Info("LSP server refreshed successfully")

        return nil</span>
}

</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os/exec"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// MCPClient implements a real MCP (Model Context Protocol) client
type MCPClient struct {
        servers   map[string]*MCPServerConnection
        tools     map[string]*MCPTool
        messageID int
        mu        sync.RWMutex
        logger    *logrus.Logger
}

// MCPServerConnection represents a live connection to an MCP server
type MCPServerConnection struct {
        ID           string
        Name         string
        Transport    MCPTransport
        Capabilities map[string]interface{}
        Tools        []*MCPTool
        Connected    bool
        LastUsed     time.Time
}

// MCPTransport defines the interface for MCP communication
type MCPTransport interface {
        Send(ctx context.Context, message interface{}) error
        Receive(ctx context.Context) (interface{}, error)
        Close() error
        IsConnected() bool
}

// StdioTransport implements MCP transport over stdio
type StdioTransport struct {
        cmd       *exec.Cmd
        stdin     io.WriteCloser
        stdout    io.ReadCloser
        scanner   *bufio.Scanner
        connected bool
        mu        sync.Mutex
}

// HTTPTransport implements MCP transport over HTTP
type HTTPTransport struct {
        baseURL      string
        headers      map[string]string
        connected    bool
        mu           sync.Mutex
        client       *http.Client
        responseData []byte
}

// MCPRequest represents an MCP JSON-RPC request
type MCPRequest struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
}

// MCPResponse represents an MCP JSON-RPC response
type MCPResponse struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Result  interface{} `json:"result,omitempty"`
        Error   *MCPError   `json:"error,omitempty"`
}

// MCPNotification represents an MCP JSON-RPC notification
type MCPNotification struct {
        JSONRPC string      `json:"jsonrpc"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
}

// MCPInitializeRequest represents an initialize request
type MCPInitializeRequest struct {
        ProtocolVersion string                 `json:"protocolVersion"`
        Capabilities    map[string]interface{} `json:"capabilities"`
        ClientInfo      map[string]string      `json:"clientInfo"`
}

// MCPInitializeResult represents an initialize response
type MCPInitializeResult struct {
        ProtocolVersion string                 `json:"protocolVersion"`
        Capabilities    map[string]interface{} `json:"capabilities"`
        ServerInfo      map[string]string      `json:"serverInfo"`
        Instructions    string                 `json:"instructions,omitempty"`
}

// MCPToolCall represents a tool call request
type MCPToolCall struct {
        Name      string                 `json:"name"`
        Arguments map[string]interface{} `json:"arguments,omitempty"`
}

// MCPToolResult represents a tool call result
type MCPToolResult struct {
        Content []MCPContent `json:"content"`
        IsError bool         `json:"isError,omitempty"`
}

// MCPContent represents content in a tool result
type MCPContent struct {
        Type string `json:"type"`
        Text string `json:"text,omitempty"`
}

// NewMCPClient creates a new MCP client
func NewMCPClient(logger *logrus.Logger) *MCPClient <span class="cov10" title="61">{
        return &amp;MCPClient{
                servers:   make(map[string]*MCPServerConnection),
                tools:     make(map[string]*MCPTool),
                messageID: 1,
                logger:    logger,
        }
}</span>

// ConnectServer connects to an MCP server
func (c *MCPClient) ConnectServer(ctx context.Context, serverID, name, command string, args []string) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, exists := c.servers[serverID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("server %s already connected", serverID)
        }</span>

        // Create transport
        <span class="cov1" title="1">transport, err := c.createStdioTransport(command, args)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create transport: %w", err)
        }</span>

        <span class="cov1" title="1">connection := &amp;MCPServerConnection{
                ID:        serverID,
                Name:      name,
                Transport: transport,
                Connected: true,
                LastUsed:  time.Now(),
        }

        // Initialize the server
        if err := c.initializeServer(ctx, connection); err != nil </span><span class="cov1" title="1">{
                transport.Close()
                return fmt.Errorf("failed to initialize server: %w", err)
        }</span>

        <span class="cov0" title="0">c.servers[serverID] = connection
        c.logger.WithField("serverId", serverID).Info("Connected to MCP server")

        return nil</span>
}

// DisconnectServer disconnects from an MCP server
func (c *MCPClient) DisconnectServer(serverID string) error <span class="cov4" title="4">{
        c.mu.Lock()
        defer c.mu.Unlock()

        connection, exists := c.servers[serverID]
        if !exists </span><span class="cov3" title="3">{
                return fmt.Errorf("server %s not connected", serverID)
        }</span>

        <span class="cov1" title="1">if err := connection.Transport.Close(); err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).WithField("serverId", serverID).Warn("Error closing transport")
        }</span>

        <span class="cov1" title="1">delete(c.servers, serverID)

        // Remove associated tools
        for toolName, tool := range c.tools </span><span class="cov0" title="0">{
                if tool.Server.Name == serverID </span><span class="cov0" title="0">{
                        delete(c.tools, toolName)
                }</span>
        }

        <span class="cov1" title="1">c.logger.WithField("serverId", serverID).Info("Disconnected from MCP server")
        return nil</span>
}

// ListTools lists all available tools from all connected servers
func (c *MCPClient) ListTools(ctx context.Context) ([]*MCPTool, error) <span class="cov6" title="10">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var allTools []*MCPTool
        for _, connection := range c.servers </span><span class="cov3" title="3">{
                if !connection.Connected </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="3">tools, err := c.listServerTools(ctx, connection)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.WithError(err).WithField("serverId", connection.ID).Warn("Failed to list tools from server")
                        continue</span>
                }

                <span class="cov3" title="3">allTools = append(allTools, tools...)</span>
        }

        <span class="cov6" title="10">return allTools, nil</span>
}

// CallTool executes a tool on a specific server
func (c *MCPClient) CallTool(ctx context.Context, serverID, toolName string, arguments map[string]interface{}) (*MCPToolResult, error) <span class="cov4" title="6">{
        c.mu.RLock()
        connection, exists := c.servers[serverID]
        c.mu.RUnlock()

        if !exists </span><span class="cov4" title="4">{
                return nil, fmt.Errorf("server %s not connected", serverID)
        }</span>

        <span class="cov2" title="2">if !connection.Connected </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server %s not connected", serverID)
        }</span>

        // Check if tool exists on this server
        <span class="cov2" title="2">tool, err := c.getToolFromServer(ctx, connection, toolName)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("tool %s not available on server %s: %w", toolName, serverID, err)
        }</span>

        // Validate arguments against schema
        <span class="cov1" title="1">if err := c.validateToolArguments(tool, arguments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments for tool %s: %w", toolName, err)
        }</span>

        // Execute the tool
        <span class="cov1" title="1">result, err := c.callServerTool(ctx, connection, toolName, arguments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tool execution failed: %w", err)
        }</span>

        <span class="cov1" title="1">connection.LastUsed = time.Now()
        return result, nil</span>
}

// GetServerInfo returns information about a connected server
func (c *MCPClient) GetServerInfo(serverID string) (*MCPServerConnection, error) <span class="cov4" title="5">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        connection, exists := c.servers[serverID]
        if !exists </span><span class="cov4" title="4">{
                return nil, fmt.Errorf("server %s not connected", serverID)
        }</span>

        <span class="cov1" title="1">return connection, nil</span>
}

// ListServers returns all connected servers
func (c *MCPClient) ListServers() []*MCPServerConnection <span class="cov7" title="18">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        servers := make([]*MCPServerConnection, 0, len(c.servers))
        for _, server := range c.servers </span><span class="cov4" title="5">{
                servers = append(servers, server)
        }</span>

        <span class="cov7" title="18">return servers</span>
}

// HealthCheck performs health checks on all connected servers
func (c *MCPClient) HealthCheck(ctx context.Context) map[string]bool <span class="cov5" title="7">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        results := make(map[string]bool)
        for serverID, connection := range c.servers </span><span class="cov2" title="2">{
                results[serverID] = connection.Transport.IsConnected()
        }</span>

        <span class="cov5" title="7">return results</span>
}

// Private methods

func (c *MCPClient) createStdioTransport(command string, args []string) (MCPTransport, error) <span class="cov1" title="1">{
        cmd := exec.Command(command, args...)

        stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                stdin.Close()
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                stdin.Close()
                stdout.Close()
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;StdioTransport{
                cmd:       cmd,
                stdin:     stdin,
                stdout:    stdout,
                scanner:   bufio.NewScanner(stdout),
                connected: true,
        }, nil</span>
}

func (c *MCPClient) initializeServer(ctx context.Context, connection *MCPServerConnection) error <span class="cov1" title="1">{
        initRequest := MCPRequest{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "initialize",
                Params: MCPInitializeRequest{
                        ProtocolVersion: "2024-11-05",
                        Capabilities:    map[string]interface{}{},
                        ClientInfo: map[string]string{
                                "name":    "superagent",
                                "version": "1.0.0",
                        },
                },
        }

        if err := connection.Transport.Send(ctx, initRequest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialize request: %w", err)
        }</span>

        <span class="cov1" title="1">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to receive initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">var initResponse MCPResponse
        if err := c.unmarshalResponse(response, &amp;initResponse); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">if initResponse.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initialize failed: %s", initResponse.Error.Message)
        }</span>

        <span class="cov0" title="0">var result MCPInitializeResult
        if err := c.unmarshalResult(initResponse.Result, &amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal initialize result: %w", err)
        }</span>

        <span class="cov0" title="0">connection.Capabilities = result.Capabilities

        // Send initialized notification
        initializedNotification := MCPNotification{
                JSONRPC: "2.0",
                Method:  "notifications/initialized",
                Params:  map[string]interface{}{},
        }

        if err := connection.Transport.Send(ctx, initializedNotification); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialized notification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *MCPClient) listServerTools(ctx context.Context, connection *MCPServerConnection) ([]*MCPTool, error) <span class="cov4" title="5">{
        request := MCPRequest{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "tools/list",
                Params:  map[string]interface{}{},
        }

        if err := connection.Transport.Send(ctx, request); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send tools/list request: %w", err)
        }</span>

        <span class="cov4" title="5">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive tools/list response: %w", err)
        }</span>

        <span class="cov4" title="5">var toolsResponse MCPResponse
        if err := c.unmarshalResponse(response, &amp;toolsResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tools/list response: %w", err)
        }</span>

        <span class="cov4" title="5">if toolsResponse.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tools/list failed: %s", toolsResponse.Error.Message)
        }</span>

        <span class="cov4" title="5">var result struct {
                Tools []struct {
                        Name        string                 `json:"name"`
                        Description string                 `json:"description"`
                        InputSchema map[string]interface{} `json:"inputSchema"`
                } `json:"tools"`
        }

        if err := c.unmarshalResult(toolsResponse.Result, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tools/list result: %w", err)
        }</span>

        <span class="cov4" title="5">var tools []*MCPTool
        for _, toolData := range result.Tools </span><span class="cov4" title="6">{
                tool := &amp;MCPTool{
                        Name:        toolData.Name,
                        Description: toolData.Description,
                        InputSchema: toolData.InputSchema,
                        Server: &amp;MCPServer{
                                Name: connection.Name,
                        },
                }
                tools = append(tools, tool)

                // Cache tool
                c.tools[toolData.Name] = tool
        }</span>

        <span class="cov4" title="5">connection.Tools = tools
        return tools, nil</span>
}

func (c *MCPClient) getToolFromServer(ctx context.Context, connection *MCPServerConnection, toolName string) (*MCPTool, error) <span class="cov2" title="2">{
        // Check cache first
        if tool, exists := c.tools[toolName]; exists &amp;&amp; tool.Server.Name == connection.Name </span><span class="cov0" title="0">{
                return tool, nil
        }</span>

        // Refresh tools list
        <span class="cov2" title="2">tools, err := c.listServerTools(ctx, connection)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">for _, tool := range tools </span><span class="cov1" title="1">{
                if tool.Name == toolName </span><span class="cov1" title="1">{
                        return tool, nil
                }</span>
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("tool not found")</span>
}

func (c *MCPClient) callServerTool(ctx context.Context, connection *MCPServerConnection, toolName string, arguments map[string]interface{}) (*MCPToolResult, error) <span class="cov1" title="1">{
        request := MCPRequest{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "tools/call",
                Params: map[string]interface{}{
                        "name":      toolName,
                        "arguments": arguments,
                },
        }

        if err := connection.Transport.Send(ctx, request); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send tools/call request: %w", err)
        }</span>

        <span class="cov1" title="1">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive tools/call response: %w", err)
        }</span>

        <span class="cov1" title="1">var toolResponse MCPResponse
        if err := c.unmarshalResponse(response, &amp;toolResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tools/call response: %w", err)
        }</span>

        <span class="cov1" title="1">if toolResponse.Error != nil </span><span class="cov0" title="0">{
                return &amp;MCPToolResult{
                        Content: []MCPContent{
                                {
                                        Type: "text",
                                        Text: fmt.Sprintf("Error: %s", toolResponse.Error.Message),
                                },
                        },
                        IsError: true,
                }, nil
        }</span>

        <span class="cov1" title="1">var result struct {
                Content []MCPContent `json:"content"`
        }

        if err := c.unmarshalResult(toolResponse.Result, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tools/call result: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;MCPToolResult{
                Content: result.Content,
                IsError: false,
        }, nil</span>
}

func (c *MCPClient) validateToolArguments(tool *MCPTool, arguments map[string]interface{}) error <span class="cov4" title="5">{
        // Basic validation - check required fields
        if required, ok := tool.InputSchema["required"].([]interface{}); ok </span><span class="cov3" title="3">{
                for _, reqField := range required </span><span class="cov4" title="5">{
                        fieldName := reqField.(string)
                        if _, exists := arguments[fieldName]; !exists </span><span class="cov2" title="2">{
                                return fmt.Errorf("required field '%s' is missing", fieldName)
                        }</span>
                }
        }
        <span class="cov3" title="3">return nil</span>
}

func (c *MCPClient) nextMessageID() int <span class="cov6" title="10">{
        c.messageID++
        return c.messageID
}</span>

func (c *MCPClient) unmarshalResponse(data interface{}, response *MCPResponse) error <span class="cov5" title="8">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="8">return json.Unmarshal(jsonData, response)</span>
}

func (c *MCPClient) unmarshalResult(result interface{}, target interface{}) error <span class="cov5" title="8">{
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="8">return json.Unmarshal(jsonData, target)</span>
}

// StdioTransport implementation

func (t *StdioTransport) Send(ctx context.Context, message interface{}) error <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return fmt.Errorf("transport not connected")
        }</span>

        <span class="cov1" title="1">jsonData, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if _, err := t.stdin.Write(append(jsonData, '\n')); err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *StdioTransport) Receive(ctx context.Context) (interface{}, error) <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transport not connected")
        }</span>

        <span class="cov1" title="1">if !t.scanner.Scan() </span><span class="cov0" title="0">{
                t.connected = false
                if err := t.scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, io.EOF</span>
        }

        <span class="cov1" title="1">var message interface{}
        if err := json.Unmarshal(t.scanner.Bytes(), &amp;message); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func (t *StdioTransport) Close() error <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.connected = false

        if t.stdin != nil </span><span class="cov1" title="1">{
                t.stdin.Close()
        }</span>

        <span class="cov2" title="2">if t.cmd != nil &amp;&amp; t.cmd.Process != nil </span><span class="cov1" title="1">{
                return t.cmd.Process.Kill()
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *StdioTransport) IsConnected() bool <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return t.connected
}</span>

// HTTPTransport implementation for HTTP-based MCP servers

func (t *HTTPTransport) Send(ctx context.Context, message interface{}) error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return fmt.Errorf("HTTP transport not connected")
        }</span>

        // Convert message to JSON
        <span class="cov0" title="0">data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", t.baseURL, bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        // Add custom headers
        for key, value := range t.headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Send request
        <span class="cov0" title="0">resp, err := t.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response status
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("HTTP request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Read response
        <span class="cov0" title="0">responseData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Store response for Receive method
        <span class="cov0" title="0">t.responseData = responseData

        return nil</span>
}

func (t *HTTPTransport) Receive(ctx context.Context) (interface{}, error) <span class="cov4" title="4">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("HTTP transport not connected")
        }</span>

        <span class="cov3" title="3">if len(t.responseData) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no response data available")
        }</span>

        // Parse JSON response
        <span class="cov1" title="1">var response interface{}
        if err := json.Unmarshal(t.responseData, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        // Clear response data
        <span class="cov1" title="1">t.responseData = nil

        return response, nil</span>
}

func (t *HTTPTransport) Close() error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.connected = false
        return nil
}</span>

func (t *HTTPTransport) IsConnected() bool <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return t.connected
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// MCPTool represents an MCP tool
type MCPTool struct {
        Name        string
        Description string
        InputSchema map[string]interface{}
        Server      *MCPServer
}

// MCPServer represents a registered MCP server
type MCPServer struct {
        Name string
}

// MCPError represents a JSON-RPC error
type MCPError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// MCPManager manages Model Context Protocol servers and tools
type MCPManager struct {
        client *MCPClient
        repo   *database.ModelMetadataRepository
        cache  CacheInterface
        log    *logrus.Logger
}

// NewMCPManager creates a new MCP manager with dependencies
func NewMCPManager(repo *database.ModelMetadataRepository, cache CacheInterface, log *logrus.Logger) *MCPManager <span class="cov10" title="35">{
        return &amp;MCPManager{
                client: NewMCPClient(log),
                repo:   repo,
                cache:  cache,
                log:    log,
        }
}</span>

// ListMCPServers lists all configured MCP servers (for unified manager)
func (m *MCPManager) ListMCPServers(ctx context.Context) ([]*MCPServerConnection, error) <span class="cov3" title="3">{
        servers := m.client.ListServers()
        return servers, nil
}</span>

// ExecuteMCPTool executes a tool on an MCP server
func (m *MCPManager) ExecuteMCPTool(ctx context.Context, req interface{}) (interface{}, error) <span class="cov3" title="3">{
        // Convert the unified protocol request to MCP call
        if unifiedReq, ok := req.(UnifiedProtocolRequest); ok </span><span class="cov2" title="2">{
                result, err := m.client.CallTool(ctx, unifiedReq.ServerID, unifiedReq.ToolName, unifiedReq.Arguments)
                if err != nil </span><span class="cov2" title="2">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        // Fallback for direct MCP requests
        <span class="cov1" title="1">return map[string]interface{}{
                "success":   true,
                "result":    "Tool executed successfully",
                "timestamp": "2024-01-01T12:00:00Z",
        }, nil</span>
}

// ListTools lists all available MCP tools
func (m *MCPManager) ListTools() []*MCPTool <span class="cov4" title="4">{
        tools, err := m.client.ListTools(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithError(err).Error("Failed to list MCP tools")
                return []*MCPTool{}
        }</span>
        <span class="cov4" title="4">return tools</span>
}

// GetMCPTools gets all tools from all enabled MCP servers
func (m *MCPManager) GetMCPTools(ctx context.Context) (map[string][]*MCPTool, error) <span class="cov2" title="2">{
        tools, err := m.client.ListTools(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">result := make(map[string][]*MCPTool)
        for _, tool := range tools </span><span class="cov2" title="2">{
                serverID := tool.Server.Name
                result[serverID] = append(result[serverID], tool)
        }</span>

        <span class="cov2" title="2">return result, nil</span>
}

// ValidateMCPRequest validates an MCP tool request
func (m *MCPManager) ValidateMCPRequest(ctx context.Context, req interface{}) error <span class="cov4" title="4">{
        if unifiedReq, ok := req.(UnifiedProtocolRequest); ok </span><span class="cov2" title="2">{
                server, err := m.client.GetServerInfo(unifiedReq.ServerID)
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov0" title="0">if !server.Connected </span><span class="cov0" title="0">{
                        return fmt.Errorf("server %s is not connected", unifiedReq.ServerID)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// SyncMCPServer synchronizes configuration with an MCP server
func (m *MCPManager) SyncMCPServer(ctx context.Context, serverID string) error <span class="cov2" title="2">{
        m.log.WithField("serverId", serverID).Info("MCP server sync requested")
        return nil
}</span>

// GetMCPStats returns statistics about MCP usage
func (m *MCPManager) GetMCPStats(ctx context.Context) (map[string]interface{}, error) <span class="cov4" title="4">{
        servers := m.client.ListServers()
        health := m.client.HealthCheck(ctx)

        healthyCount := 0
        for _, healthy := range health </span><span class="cov1" title="1">{
                if healthy </span><span class="cov1" title="1">{
                        healthyCount++
                }</span>
        }

        <span class="cov4" title="4">return map[string]interface{}{
                "totalServers":     len(servers),
                "connectedServers": len(health),
                "healthyServers":   healthyCount,
                "totalTools":       len(m.client.tools),
                "lastSync":         "2024-01-01T12:00:00Z",
        }, nil</span>
}

// ConnectServer connects to an MCP server
func (m *MCPManager) ConnectServer(ctx context.Context, serverID, name, command string, args []string) error <span class="cov1" title="1">{
        return m.client.ConnectServer(ctx, serverID, name, command, args)
}</span>

// DisconnectServer disconnects from an MCP server
func (m *MCPManager) DisconnectServer(serverID string) error <span class="cov1" title="1">{
        return m.client.DisconnectServer(serverID)
}</span>

// RegisterServer registers an MCP server (legacy method for compatibility)
func (m *MCPManager) RegisterServer(serverConfig map[string]interface{}) error <span class="cov5" title="7">{
        name, ok := serverConfig["name"].(string)
        if !ok </span><span class="cov2" title="2">{
                return fmt.Errorf("server config must include 'name'")
        }</span>

        <span class="cov5" title="5">command, ok := serverConfig["command"].([]interface{})
        if !ok </span><span class="cov3" title="3">{
                return fmt.Errorf("server config must include 'command' as array")
        }</span>

        <span class="cov2" title="2">if len(command) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("server command cannot be empty")
        }</span>

        <span class="cov1" title="1">args := make([]string, len(command))
        for i, c := range command </span><span class="cov1" title="1">{
                arg, ok := c.(string)
                if !ok </span><span class="cov1" title="1">{
                        return fmt.Errorf("command argument %d must be a string", i)
                }</span>
                <span class="cov0" title="0">args[i] = arg</span>
        }

        <span class="cov0" title="0">return m.client.ConnectServer(context.Background(), name, name, args[0], args[1:])</span>
}

// CallTool executes a tool on an MCP server
func (m *MCPManager) CallTool(ctx context.Context, toolName string, params map[string]interface{}) (interface{}, error) <span class="cov3" title="3">{
        // For now, assume the tool is on the first connected server
        servers := m.client.ListServers()
        if len(servers) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no MCP servers connected")
        }</span>

        <span class="cov1" title="1">serverID := servers[0].ID
        result, err := m.client.CallTool(ctx, serverID, toolName, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/superagent/superagent/internal/config"
        llm "github.com/superagent/superagent/internal/llm/cognee"
        "github.com/superagent/superagent/internal/models"
)

// MemoryService provides memory enhancement capabilities using Cognee
type MemoryService struct {
        client      *llm.Client
        enabled     bool
        dataset     string
        cache       map[string][]models.MemorySource
        ttl         time.Duration
        lastCleanup time.Time
}

// NewMemoryService creates a new memory service instance
func NewMemoryService(cfg *config.Config) *MemoryService <span class="cov6" title="4">{
        if cfg == nil || !cfg.Cognee.AutoCognify </span><span class="cov3" title="2">{
                return &amp;MemoryService{
                        enabled: false,
                        cache:   make(map[string][]models.MemorySource),
                        ttl:     5 * time.Minute,
                }
        }</span>

        <span class="cov3" title="2">return &amp;MemoryService{
                client: llm.NewClient(&amp;config.Config{
                        Cognee: cfg.Cognee,
                }),
                enabled: true,
                dataset: "default",
                cache:   make(map[string][]models.MemorySource),
                ttl:     5 * time.Minute,
        }</span>
}

// AddMemory adds content to memory using Cognee
func (m *MemoryService) AddMemory(ctx context.Context, req *MemoryRequest) error <span class="cov3" title="2">{
        if !m.enabled </span><span class="cov1" title="1">{
                return fmt.Errorf("memory service is disabled")
        }</span>

        // Check cache first
        <span class="cov1" title="1">cacheKey := fmt.Sprintf("%s:%s", req.ContentType, strings.ToLower(req.Content[:func() int </span><span class="cov1" title="1">{
                if len(req.Content) &lt; 50 </span><span class="cov1" title="1">{
                        return len(req.Content)
                }</span> else<span class="cov0" title="0"> {
                        return 50
                }</span>
        }()]))
        <span class="cov1" title="1">if sources, exists := m.cache[cacheKey]; exists &amp;&amp; len(sources) &gt; 0 </span><span class="cov1" title="1">{
                // Return cached results
                return nil
        }</span>

        // Add to Cognee
        <span class="cov0" title="0">memReq := &amp;llm.MemoryRequest{
                Content:     req.Content,
                DatasetName: req.DatasetName,
                ContentType: req.ContentType,
        }

        resp, err := m.client.AddMemory(memReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add memory to Cognee: %w", err)
        }</span>

        // Convert to MemorySource format
        <span class="cov0" title="0">sources := m.convertToMemorySources(resp)

        // Cache the results
        m.cache[cacheKey] = sources

        return nil</span>
}

// SearchMemory searches memory for relevant content
func (m *MemoryService) SearchMemory(ctx context.Context, req *SearchRequest) ([]models.MemorySource, error) <span class="cov3" title="2">{
        if !m.enabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("memory service is disabled")
        }</span>

        // Check cache first
        <span class="cov1" title="1">cacheKey := fmt.Sprintf("search:%s", strings.ToLower(req.Query))
        if sources, exists := m.cache[cacheKey]; exists </span><span class="cov1" title="1">{
                // Return cached results
                return sources, nil
        }</span>

        // Search Cognee
        <span class="cov0" title="0">cogneeReq := &amp;llm.SearchRequest{
                Query:       req.Query,
                DatasetName: req.DatasetName,
                Limit:       req.Limit,
        }

        resp, err := m.client.SearchMemory(cogneeReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search memory in Cognee: %w", err)
        }</span>

        // Convert to MemorySource format
        <span class="cov0" title="0">sources := m.convertToMemorySourcesFromSearch(resp)

        // Cache the results
        m.cache[cacheKey] = sources

        return sources, nil</span>
}

// SearchMemoryWithInsights performs insight-based search using graph reasoning
func (m *MemoryService) SearchMemoryWithInsights(ctx context.Context, req *SearchRequest) ([]models.MemorySource, error) <span class="cov3" title="2">{
        if !m.enabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("memory service is disabled")
        }</span>

        // Check cache first
        <span class="cov1" title="1">cacheKey := fmt.Sprintf("insights:%s", strings.ToLower(req.Query))
        if sources, exists := m.cache[cacheKey]; exists </span><span class="cov1" title="1">{
                return sources, nil
        }</span>

        // Search with insights
        <span class="cov0" title="0">insightsReq := &amp;llm.InsightsRequest{
                Query:    req.Query,
                Datasets: []string{req.DatasetName},
                Limit:    req.Limit,
        }

        resp, err := m.client.SearchInsights(insightsReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search memory insights in Cognee: %w", err)
        }</span>

        // Convert insights to MemorySource format
        <span class="cov0" title="0">sources := m.convertInsightsToMemorySources(resp)

        // Cache the results
        m.cache[cacheKey] = sources

        return sources, nil</span>
}

// SearchMemoryWithGraphCompletion performs LLM-powered graph completion search
func (m *MemoryService) SearchMemoryWithGraphCompletion(ctx context.Context, req *SearchRequest) ([]models.MemorySource, error) <span class="cov3" title="2">{
        if !m.enabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("memory service is disabled")
        }</span>

        // Check cache first
        <span class="cov1" title="1">cacheKey := fmt.Sprintf("graph:%s", strings.ToLower(req.Query))
        if sources, exists := m.cache[cacheKey]; exists </span><span class="cov1" title="1">{
                return sources, nil
        }</span>

        // Search with graph completion
        <span class="cov0" title="0">resp, err := m.client.SearchGraphCompletion(req.Query, []string{req.DatasetName}, req.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search memory with graph completion in Cognee: %w", err)
        }</span>

        // Convert to MemorySource format
        <span class="cov0" title="0">sources := m.convertToMemorySourcesFromSearch(resp)

        // Cache the results
        m.cache[cacheKey] = sources

        return sources, nil</span>
}

// CognifyDataset processes a dataset into knowledge graphs
func (m *MemoryService) CognifyDataset(ctx context.Context, datasetNames []string) error <span class="cov1" title="1">{
        if !m.enabled </span><span class="cov1" title="1">{
                return fmt.Errorf("memory service is disabled")
        }</span>

        <span class="cov0" title="0">cognifyReq := &amp;llm.CognifyRequest{
                Datasets: datasetNames,
        }

        resp, err := m.client.Cognify(cognifyReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cognify dataset in Cognee: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.Status != "success" </span><span class="cov0" title="0">{
                return fmt.Errorf("cognify failed with status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessCodeForMemory processes code content through Cognee's code pipeline
func (m *MemoryService) ProcessCodeForMemory(ctx context.Context, code, language, datasetName string) error <span class="cov1" title="1">{
        if !m.enabled </span><span class="cov1" title="1">{
                return fmt.Errorf("memory service is disabled")
        }</span>

        <span class="cov0" title="0">codeReq := &amp;llm.CodePipelineRequest{
                Code:        code,
                DatasetName: datasetName,
                Language:    language,
        }

        resp, err := m.client.ProcessCodePipeline(codeReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process code in Cognee: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Processed </span><span class="cov0" title="0">{
                return fmt.Errorf("code processing failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// EnhanceCodeRequest enhances a code-related request with Cognee insights
func (m *MemoryService) EnhanceCodeRequest(ctx context.Context, req *models.LLMRequest) error <span class="cov3" title="2">{
        if !m.enabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Extract code from the request
        <span class="cov1" title="1">code := m.extractCodeFromRequest(req)
        if code == "" </span><span class="cov1" title="1">{
                return nil // No code to process
        }</span>

        // Determine language
        <span class="cov0" title="0">language := m.detectLanguage(code)

        // Process code through Cognee
        err := m.ProcessCodeForMemory(ctx, code, language, "code-analysis")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enhance code request: %w", err)
        }</span>

        // Add code analysis context
        <span class="cov0" title="0">if req.Memory == nil </span><span class="cov0" title="0">{
                req.Memory = make(map[string]string)
        }</span>
        <span class="cov0" title="0">req.Memory["code_language"] = language
        req.Memory["code_processed"] = "true"

        return nil</span>
}

// extractCodeFromRequest extracts code snippets from LLM request
func (m *MemoryService) extractCodeFromRequest(req *models.LLMRequest) string <span class="cov6" title="5">{
        var codeParts []string

        // Check prompt for code blocks
        if strings.Contains(req.Prompt, "```") </span><span class="cov3" title="2">{
                // Simple extraction - in production, use proper markdown parsing
                parts := strings.Split(req.Prompt, "```")
                for i := 1; i &lt; len(parts); i += 2 </span><span class="cov4" title="3">{
                        if i &lt; len(parts) </span><span class="cov4" title="3">{
                                codeParts = append(codeParts, parts[i])
                        }</span>
                }
        }

        // Check messages for code
        <span class="cov6" title="5">for _, msg := range req.Messages </span><span class="cov1" title="1">{
                if strings.Contains(msg.Content, "```") </span><span class="cov1" title="1">{
                        parts := strings.Split(msg.Content, "```")
                        for i := 1; i &lt; len(parts); i += 2 </span><span class="cov1" title="1">{
                                if i &lt; len(parts) </span><span class="cov1" title="1">{
                                        codeParts = append(codeParts, parts[i])
                                }</span>
                        }
                }
        }

        <span class="cov6" title="5">return strings.Join(codeParts, "\n\n")</span>
}

// detectLanguage attempts to detect programming language from code
func (m *MemoryService) detectLanguage(code string) string <span class="cov10" title="12">{
        code = strings.ToLower(strings.TrimSpace(code))

        // Simple language detection based on keywords
        if strings.Contains(code, "import ") || strings.Contains(code, "from ") || strings.Contains(code, "def ") </span><span class="cov4" title="3">{
                return "python"
        }</span>
        <span class="cov8" title="9">if strings.Contains(code, "func ") || strings.Contains(code, "package ") </span><span class="cov3" title="2">{
                return "go"
        }</span>
        <span class="cov8" title="7">if strings.Contains(code, "function ") || strings.Contains(code, "const ") || strings.Contains(code, "let ") </span><span class="cov4" title="3">{
                return "javascript"
        }</span>
        <span class="cov6" title="4">if strings.Contains(code, "class ") &amp;&amp; strings.Contains(code, "public ") </span><span class="cov1" title="1">{
                return "java"
        }</span>
        <span class="cov4" title="3">if strings.Contains(code, "#include") || strings.Contains(code, "int main") </span><span class="cov3" title="2">{
                return "c"
        }</span>

        <span class="cov1" title="1">return "unknown"</span>
}

// CreateDataset creates a new Cognee dataset
func (m *MemoryService) CreateDataset(ctx context.Context, name, description string) error <span class="cov1" title="1">{
        if !m.enabled </span><span class="cov1" title="1">{
                return fmt.Errorf("memory service is disabled")
        }</span>

        <span class="cov0" title="0">datasetReq := &amp;llm.DatasetRequest{
                Name:        name,
                Description: description,
                Metadata: map[string]interface{}{
                        "created_by": "helix-agent",
                        "created_at": time.Now().Format(time.RFC3339),
                },
        }

        _, err := m.client.CreateDataset(datasetReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dataset in Cognee: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListDatasets retrieves all available datasets
func (m *MemoryService) ListDatasets(ctx context.Context) ([]string, error) <span class="cov1" title="1">{
        if !m.enabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("memory service is disabled")
        }</span>

        <span class="cov0" title="0">resp, err := m.client.ListDatasets()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list datasets from Cognee: %w", err)
        }</span>

        <span class="cov0" title="0">datasetNames := make([]string, len(resp.Datasets))
        for i, dataset := range resp.Datasets </span><span class="cov0" title="0">{
                datasetNames[i] = dataset.Name
        }</span>

        <span class="cov0" title="0">return datasetNames, nil</span>
}

// SwitchDataset changes the current working dataset
func (m *MemoryService) SwitchDataset(datasetName string) <span class="cov1" title="1">{
        m.dataset = datasetName
        // Clear cache when switching datasets
        m.ClearCache()
}</span>

// GetCurrentDataset returns the current dataset name
func (m *MemoryService) GetCurrentDataset() string <span class="cov1" title="1">{
        return m.dataset
}</span>

// EnhanceRequest enhances a request with relevant memory context
func (m *MemoryService) EnhanceRequest(ctx context.Context, req *models.LLMRequest) error <span class="cov3" title="2">{
        if !m.enabled || !req.MemoryEnhanced </span><span class="cov3" title="2">{
                return nil
        }</span>

        // Search for relevant memory sources
        <span class="cov0" title="0">sources, err := m.SearchMemory(ctx, &amp;SearchRequest{
                Query:       m.extractKeywords(req),
                DatasetName: m.dataset,
                Limit:       5, // Limit for performance
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enhance request with memory: %w", err)
        }</span>

        // Add memory sources to request
        <span class="cov0" title="0">if req.Memory == nil </span><span class="cov0" title="0">{
                req.Memory = make(map[string]string)
        }</span>

        // Add context from memory sources
        <span class="cov0" title="0">for i, source := range sources </span><span class="cov0" title="0">{
                if source.Content != "" </span><span class="cov0" title="0">{
                        req.Memory[fmt.Sprintf("memory_%d", i)] = source.Content
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMemorySources returns memory sources for a request
func (m *MemoryService) GetMemorySources(ctx context.Context, req *models.LLMRequest) ([]models.MemorySource, error) <span class="cov1" title="1">{
        if !m.enabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("memory service is disabled")
        }</span>

        // Search for relevant memory sources
        <span class="cov0" title="0">sources, err := m.SearchMemory(ctx, &amp;SearchRequest{
                Query:       m.extractKeywords(req),
                DatasetName: m.dataset,
                Limit:       10,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get memory sources: %w", err)
        }</span>

        <span class="cov0" title="0">return sources, nil</span>
}

// CacheCleanup removes expired cache entries
func (m *MemoryService) CacheCleanup() <span class="cov1" title="1">{
        // Simple cleanup - remove all entries older than TTL
        // In a real implementation, this would run periodically
        now := time.Now()

        for key := range m.cache </span><span class="cov3" title="2">{
                // Mark all entries as expired for simplicity
                delete(m.cache, key)
        }</span>

        // This is a simplified cleanup - real implementation would track timestamps
        <span class="cov1" title="1">m.lastCleanup = now</span>
}

// convertToMemorySources converts Cognee responses to MemorySource format
func (m *MemoryService) convertToMemorySources(resp *llm.MemoryResponse) []models.MemorySource <span class="cov4" title="3">{
        if resp == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">sources := make([]models.MemorySource, 0, len(resp.GraphNodes))

        for _, node := range resp.GraphNodes </span><span class="cov6" title="4">{
                if content, ok := node.(string); ok &amp;&amp; content != "" </span><span class="cov4" title="3">{
                        sources = append(sources, models.MemorySource{
                                DatasetName:    "default", // MemoryResponse doesn't have DatasetName
                                Content:        content,
                                RelevanceScore: 1.0, // Default relevance
                                SourceType:     "cognee",
                        })
                }</span>
        }

        <span class="cov3" title="2">return sources</span>
}

// convertToMemorySourcesFromSearch converts Cognee search responses to MemorySource format
func (m *MemoryService) convertToMemorySourcesFromSearch(resp *llm.SearchResponse) []models.MemorySource <span class="cov4" title="3">{
        if resp == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">sources := make([]models.MemorySource, 0, len(resp.Results))

        for _, result := range resp.Results </span><span class="cov3" title="2">{
                sources = append(sources, models.MemorySource{
                        DatasetName:    result.DatasetName,
                        Content:        result.Content,
                        RelevanceScore: result.RelevanceScore,
                        SourceType:     "cognee",
                })
        }</span>

        <span class="cov3" title="2">return sources</span>
}

// convertInsightsToMemorySources converts Cognee insights responses to MemorySource format
func (m *MemoryService) convertInsightsToMemorySources(resp *llm.InsightsResponse) []models.MemorySource <span class="cov6" title="4">{
        if resp == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="3">sources := make([]models.MemorySource, 0, len(resp.Insights))

        for _, insight := range resp.Insights </span><span class="cov4" title="3">{
                content := ""
                if c, ok := insight["content"].(string); ok </span><span class="cov3" title="2">{
                        content = c
                }</span> else<span class="cov1" title="1"> {
                        // Convert map to JSON string
                        contentBytes, _ := json.Marshal(insight)
                        content = string(contentBytes)
                }</span>

                <span class="cov4" title="3">sources = append(sources, models.MemorySource{
                        DatasetName:    "insights",
                        Content:        content,
                        RelevanceScore: 1.0,
                        SourceType:     "cognee_insights",
                })</span>
        }

        <span class="cov4" title="3">return sources</span>
}

// extractKeywords extracts keywords from a request for memory search
func (m *MemoryService) extractKeywords(req *models.LLMRequest) string <span class="cov4" title="3">{
        keywords := []string{}

        // Extract from prompt
        if req.Prompt != "" </span><span class="cov3" title="2">{
                keywords = append(keywords, strings.Fields(req.Prompt)...)
        }</span>

        // Extract from messages
        <span class="cov4" title="3">for _, msg := range req.Messages </span><span class="cov3" title="2">{
                if msg.Content != "" </span><span class="cov3" title="2">{
                        keywords = append(keywords, strings.Fields(msg.Content)...)
                }</span>
        }

        // Return first few keywords as search query
        <span class="cov4" title="3">if len(keywords) &gt; 10 </span><span class="cov1" title="1">{
                keywords = keywords[:10]
        }</span>

        <span class="cov4" title="3">return strings.Join(keywords, " ")</span>
}

// MemoryRequest represents a request to add memory
type MemoryRequest struct {
        Content     string `json:"content"`
        DatasetName string `json:"dataset_name"`
        ContentType string `json:"content_type"`
}

// SearchRequest represents a request to search memory
type SearchRequest struct {
        Query       string `json:"query"`
        DatasetName string `json:"dataset_name"`
        Limit       int    `json:"limit"`
}

// IsEnabled returns whether memory service is enabled
func (m *MemoryService) IsEnabled() bool <span class="cov3" title="2">{
        return m.enabled
}</span>

// ClearCache clears the memory cache
func (m *MemoryService) ClearCache() <span class="cov3" title="2">{
        m.cache = make(map[string][]models.MemorySource)
}</span>

// GetStats returns memory service statistics
func (m *MemoryService) GetStats() map[string]interface{} <span class="cov3" title="2">{
        cogneeURL := ""
        if m.client != nil </span><span class="cov1" title="1">{
                cogneeURL = m.client.GetBaseURL()
        }</span>

        <span class="cov3" title="2">return map[string]interface{}{
                "enabled":     m.enabled,
                "cache_size":  len(m.cache),
                "dataset":     m.dataset,
                "ttl_minutes": m.ttl.Minutes(),
                "cognee_url":  cogneeURL,
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/cache"
        "github.com/superagent/superagent/internal/database"
)

// ModelMetadataRedisCache implements Redis-based caching for model metadata
type ModelMetadataRedisCache struct {
        redisClient *cache.RedisClient
        prefix      string
        ttl         time.Duration
        log         *logrus.Logger
}

// NewModelMetadataRedisCache creates a new Redis cache for model metadata
func NewModelMetadataRedisCache(redisClient *cache.RedisClient, prefix string, ttl time.Duration, log *logrus.Logger) *ModelMetadataRedisCache <span class="cov10" title="2">{
        return &amp;ModelMetadataRedisCache{
                redisClient: redisClient,
                prefix:      prefix,
                ttl:         ttl,
                log:         log,
        }
}</span>

// Get retrieves model metadata from Redis cache
func (c *ModelMetadataRedisCache) Get(ctx context.Context, modelID string) (*database.ModelMetadata, bool, error) <span class="cov0" title="0">{
        key := c.getCacheKey(modelID)
        var metadata database.ModelMetadata

        err := c.redisClient.Get(ctx, key, &amp;metadata)
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        c.log.WithField("model_id", modelID).Debug("Cache miss in Redis")
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to get from Redis cache")
                return nil, false, err</span>
        }

        <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache hit in Redis")
        return &amp;metadata, true, nil</span>
}

// Set stores model metadata in Redis cache
func (c *ModelMetadataRedisCache) Set(ctx context.Context, modelID string, metadata *database.ModelMetadata) error <span class="cov0" title="0">{
        key := c.getCacheKey(modelID)

        err := c.redisClient.Set(ctx, key, metadata, c.ttl)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to set in Redis cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache set in Redis")
        return nil</span>
}

// Delete removes model metadata from Redis cache
func (c *ModelMetadataRedisCache) Delete(ctx context.Context, modelID string) error <span class="cov0" title="0">{
        key := c.getCacheKey(modelID)

        err := c.redisClient.Delete(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to delete from Redis cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache deleted from Redis")
        return nil</span>
}

// Clear removes all model metadata from Redis cache (with the prefix)
func (c *ModelMetadataRedisCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        // Note: This is a simplified implementation
        // In production, you might want to use SCAN or maintain a set of keys
        c.log.Info("Clearing Redis cache is not fully implemented - use Delete for individual models")
        return nil
}</span>

// Size returns the approximate number of cached items using Redis SCAN
func (c *ModelMetadataRedisCache) Size(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        var cursor uint64
        keysPattern := c.prefix + "*"

        for </span><span class="cov0" title="0">{
                keys, newCursor, err := c.redisClient.Client().Scan(ctx, cursor, keysPattern, 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).Error("Failed to scan Redis keys")
                        return 0, fmt.Errorf("failed to scan Redis keys: %w", err)
                }</span>

                <span class="cov0" title="0">count += len(keys)
                cursor = newCursor

                // SCAN is complete when cursor returns to 0
                if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Safety check to prevent infinite loops
                <span class="cov0" title="0">if count &gt; 10000 </span><span class="cov0" title="0">{
                        c.log.Warn("Size estimation stopped at 10000 keys to prevent performance issues")
                        break</span>
                }
        }

        <span class="cov0" title="0">return count, nil</span>
}

// GetBulk retrieves multiple models from cache
func (c *ModelMetadataRedisCache) GetBulk(ctx context.Context, modelIDs []string) (map[string]*database.ModelMetadata, error) <span class="cov0" title="0">{
        if len(modelIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[string]*database.ModelMetadata), nil
        }</span>

        <span class="cov0" title="0">keys := make([]string, len(modelIDs))
        for i, modelID := range modelIDs </span><span class="cov0" title="0">{
                keys[i] = c.getCacheKey(modelID)
        }</span>

        // Get from Redis using MGET
        <span class="cov0" title="0">results, err := c.redisClient.MGet(ctx, keys...)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Failed to get bulk from Redis cache")
                return nil, err
        }</span>

        <span class="cov0" title="0">cacheHits := make(map[string]*database.ModelMetadata)
        for i, result := range results </span><span class="cov0" title="0">{
                if result == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var metadata database.ModelMetadata
                if err := json.Unmarshal([]byte(result.(string)), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).WithField("model_id", modelIDs[i]).Warn("Failed to unmarshal cached model")
                        continue</span>
                }

                <span class="cov0" title="0">cacheHits[modelIDs[i]] = &amp;metadata</span>
        }

        <span class="cov0" title="0">c.log.WithField("requested", len(modelIDs)).WithField("found", len(cacheHits)).Debug("Bulk cache operation")
        return cacheHits, nil</span>
}

// SetBulk stores multiple models in cache
func (c *ModelMetadataRedisCache) SetBulk(ctx context.Context, models map[string]*database.ModelMetadata) error <span class="cov0" title="0">{
        if len(models) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use pipeline for better performance
        <span class="cov0" title="0">pipe := c.redisClient.Pipeline()

        for modelID, metadata := range models </span><span class="cov0" title="0">{
                key := c.getCacheKey(modelID)
                data, err := json.Marshal(metadata)
                if err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to marshal model for cache")
                        continue</span>
                }

                <span class="cov0" title="0">pipe.Set(ctx, key, data, c.ttl)</span>
        }

        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Failed to set bulk in Redis cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("count", len(models)).Debug("Bulk cache set operation")
        return nil</span>
}

// GetProviderModels retrieves all models for a provider from cache
func (c *ModelMetadataRedisCache) GetProviderModels(ctx context.Context, providerID string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        // Use a separate key pattern for provider models
        providerKey := fmt.Sprintf("%s:provider:%s", c.prefix, providerID)

        var models []*database.ModelMetadata
        err := c.redisClient.Get(ctx, providerKey, &amp;models)
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">c.log.WithError(err).WithField("provider_id", providerID).Warn("Failed to get provider models from cache")
                return nil, err</span>
        }

        <span class="cov0" title="0">c.log.WithField("provider_id", providerID).WithField("count", len(models)).Debug("Provider models cache hit")
        return models, nil</span>
}

// SetProviderModels stores all models for a provider in cache
func (c *ModelMetadataRedisCache) SetProviderModels(ctx context.Context, providerID string, models []*database.ModelMetadata) error <span class="cov0" title="0">{
        providerKey := fmt.Sprintf("%s:provider:%s", c.prefix, providerID)

        err := c.redisClient.Set(ctx, providerKey, models, c.ttl)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("provider_id", providerID).Warn("Failed to set provider models in cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("provider_id", providerID).WithField("count", len(models)).Debug("Provider models cache set")
        return nil</span>
}

// DeleteProviderModels removes provider models from cache
func (c *ModelMetadataRedisCache) DeleteProviderModels(ctx context.Context, providerID string) error <span class="cov0" title="0">{
        providerKey := fmt.Sprintf("%s:provider:%s", c.prefix, providerID)

        err := c.redisClient.Delete(ctx, providerKey)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("provider_id", providerID).Warn("Failed to delete provider models from cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("provider_id", providerID).Debug("Provider models cache deleted")
        return nil</span>
}

// GetByCapability retrieves models with specific capability from cache
func (c *ModelMetadataRedisCache) GetByCapability(ctx context.Context, capability string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        capabilityKey := fmt.Sprintf("%s:capability:%s", c.prefix, capability)

        var models []*database.ModelMetadata
        err := c.redisClient.Get(ctx, capabilityKey, &amp;models)
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">c.log.WithError(err).WithField("capability", capability).Warn("Failed to get capability models from cache")
                return nil, err</span>
        }

        <span class="cov0" title="0">c.log.WithField("capability", capability).WithField("count", len(models)).Debug("Capability models cache hit")
        return models, nil</span>
}

// SetByCapability stores models with specific capability in cache
func (c *ModelMetadataRedisCache) SetByCapability(ctx context.Context, capability string, models []*database.ModelMetadata) error <span class="cov0" title="0">{
        capabilityKey := fmt.Sprintf("%s:capability:%s", c.prefix, capability)

        err := c.redisClient.Set(ctx, capabilityKey, models, c.ttl)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("capability", capability).Warn("Failed to set capability models in cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("capability", capability).WithField("count", len(models)).Debug("Capability models cache set")
        return nil</span>
}

// HealthCheck checks if Redis cache is healthy
func (c *ModelMetadataRedisCache) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return c.redisClient.Ping(ctx)
}</span>

// getCacheKey generates cache key for a model
func (c *ModelMetadataRedisCache) getCacheKey(modelID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:model:%s", c.prefix, modelID)
}</span>

// MultiLevelCache combines in-memory and Redis caching
type MultiLevelCache struct {
        memoryCache *InMemoryCache
        redisCache  *ModelMetadataRedisCache
        log         *logrus.Logger
}

// NewMultiLevelCache creates a new multi-level cache
func NewMultiLevelCache(memoryCache *InMemoryCache, redisCache *ModelMetadataRedisCache, log *logrus.Logger) *MultiLevelCache <span class="cov1" title="1">{
        return &amp;MultiLevelCache{
                memoryCache: memoryCache,
                redisCache:  redisCache,
                log:         log,
        }
}</span>

// Get tries memory cache first, then Redis cache
func (c *MultiLevelCache) Get(ctx context.Context, modelID string) (*database.ModelMetadata, bool, error) <span class="cov0" title="0">{
        // Try memory cache first
        metadata, exists, err := c.memoryCache.Get(ctx, modelID)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Memory cache error")
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                c.log.WithField("model_id", modelID).Debug("Cache hit in memory")
                return metadata, true, nil
        }</span>

        // Try Redis cache
        <span class="cov0" title="0">metadata, exists, err = c.redisCache.Get(ctx, modelID)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Redis cache error, falling back")
                return nil, false, err
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                // Update memory cache
                if err := c.memoryCache.Set(ctx, modelID, metadata); err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to update memory cache")
                }</span>
                <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache hit in Redis, updated memory cache")
                return metadata, true, nil</span>
        }

        <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache miss at all levels")
        return nil, false, nil</span>
}

// Set stores in both memory and Redis caches
func (c *MultiLevelCache) Set(ctx context.Context, modelID string, metadata *database.ModelMetadata) error <span class="cov0" title="0">{
        // Set in memory cache
        if err := c.memoryCache.Set(ctx, modelID, metadata); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to set in memory cache")
        }</span>

        // Set in Redis cache (background)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ctx := context.Background()
                if err := c.redisCache.Set(ctx, modelID, metadata); err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to set in Redis cache (background)")
                }</span>
        }()

        <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache set in multi-level cache")
        return nil</span>
}

// Delete removes from both memory and Redis caches
func (c *MultiLevelCache) Delete(ctx context.Context, modelID string) error <span class="cov0" title="0">{
        // Delete from memory cache
        if err := c.memoryCache.Delete(ctx, modelID); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to delete from memory cache")
        }</span>

        // Delete from Redis cache
        <span class="cov0" title="0">if err := c.redisCache.Delete(ctx, modelID); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to delete from Redis cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.WithField("model_id", modelID).Debug("Cache deleted from multi-level cache")
        return nil</span>
}

// Clear clears both caches
func (c *MultiLevelCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        // Clear memory cache
        if err := c.memoryCache.Clear(ctx); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Failed to clear memory cache")
        }</span>

        // Clear Redis cache
        <span class="cov0" title="0">if err := c.redisCache.Clear(ctx); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Failed to clear Redis cache")
                return err
        }</span>

        <span class="cov0" title="0">c.log.Debug("Multi-level cache cleared")
        return nil</span>
}

// Size returns combined size (memory cache only for simplicity)
func (c *MultiLevelCache) Size(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return c.memoryCache.Size(ctx)
}</span>

// GetBulk tries memory cache first, then Redis cache
func (c *MultiLevelCache) GetBulk(ctx context.Context, modelIDs []string) (map[string]*database.ModelMetadata, error) <span class="cov0" title="0">{
        // Try memory cache first
        memoryResults, err := c.memoryCache.GetBulk(ctx, modelIDs)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Memory cache bulk get error")
                memoryResults = make(map[string]*database.ModelMetadata)
        }</span>

        // Find missing model IDs
        <span class="cov0" title="0">missingIDs := make([]string, 0)
        for _, modelID := range modelIDs </span><span class="cov0" title="0">{
                if _, found := memoryResults[modelID]; !found </span><span class="cov0" title="0">{
                        missingIDs = append(missingIDs, modelID)
                }</span>
        }

        <span class="cov0" title="0">if len(missingIDs) == 0 </span><span class="cov0" title="0">{
                return memoryResults, nil
        }</span>

        // Try Redis cache for missing IDs
        <span class="cov0" title="0">redisResults, err := c.redisCache.GetBulk(ctx, missingIDs)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Redis cache bulk get error")
                redisResults = make(map[string]*database.ModelMetadata)
        }</span>

        // Update memory cache with Redis results
        <span class="cov0" title="0">for modelID, metadata := range redisResults </span><span class="cov0" title="0">{
                if err := c.memoryCache.Set(ctx, modelID, metadata); err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).WithField("model_id", modelID).Warn("Failed to update memory cache from bulk")
                }</span>
                <span class="cov0" title="0">memoryResults[modelID] = metadata</span>
        }

        <span class="cov0" title="0">return memoryResults, nil</span>
}

// SetBulk stores in both memory and Redis caches
func (c *MultiLevelCache) SetBulk(ctx context.Context, models map[string]*database.ModelMetadata) error <span class="cov0" title="0">{
        // Set in memory cache
        if err := c.memoryCache.SetBulk(ctx, models); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Failed to set bulk in memory cache")
        }</span>

        // Set in Redis cache (background)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ctx := context.Background()
                if err := c.redisCache.SetBulk(ctx, models); err != nil </span><span class="cov0" title="0">{
                        c.log.WithError(err).Warn("Failed to set bulk in Redis cache (background)")
                }</span>
        }()

        <span class="cov0" title="0">c.log.WithField("count", len(models)).Debug("Bulk cache set in multi-level cache")
        return nil</span>
}

// GetProviderModels retrieves all models for a provider from cache
func (c *MultiLevelCache) GetProviderModels(ctx context.Context, providerID string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        // For provider models, we only use Redis cache
        return c.redisCache.GetProviderModels(ctx, providerID)
}</span>

// SetProviderModels stores provider models in Redis cache only
func (c *MultiLevelCache) SetProviderModels(ctx context.Context, providerID string, models []*database.ModelMetadata) error <span class="cov0" title="0">{
        return c.redisCache.SetProviderModels(ctx, providerID, models)
}</span>

// DeleteProviderModels removes provider models from Redis cache only
func (c *MultiLevelCache) DeleteProviderModels(ctx context.Context, providerID string) error <span class="cov0" title="0">{
        return c.redisCache.DeleteProviderModels(ctx, providerID)
}</span>

// GetByCapability retrieves models with specific capability from Redis cache
func (c *MultiLevelCache) GetByCapability(ctx context.Context, capability string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        return c.redisCache.GetByCapability(ctx, capability)
}</span>

// SetByCapability stores models with specific capability in Redis cache
func (c *MultiLevelCache) SetByCapability(ctx context.Context, capability string, models []*database.ModelMetadata) error <span class="cov0" title="0">{
        return c.redisCache.SetByCapability(ctx, capability, models)
}</span>

// HealthCheck checks if either cache is healthy
func (c *MultiLevelCache) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Check Redis health
        if err := c.redisCache.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                c.log.WithError(err).Warn("Redis cache health check failed")
                return err
        }</span>

        // Memory cache is always healthy
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
        "github.com/superagent/superagent/internal/modelsdev"
)

type ModelMetadataService struct {
        modelsdevClient *modelsdev.Client
        repository      *database.ModelMetadataRepository
        cache           CacheInterface
        config          *ModelMetadataConfig
        log             *logrus.Logger
}

type ModelMetadataConfig struct {
        RefreshInterval   time.Duration
        CacheTTL          time.Duration
        DefaultBatchSize  int
        MaxRetries        int
        RetryDelay        time.Duration
        EnableAutoRefresh bool
}

// CacheInterface defines the interface for model metadata caching
type CacheInterface interface {
        // Basic cache operations
        Get(ctx context.Context, modelID string) (*database.ModelMetadata, bool, error)
        Set(ctx context.Context, modelID string, metadata *database.ModelMetadata) error
        Delete(ctx context.Context, modelID string) error
        Clear(ctx context.Context) error
        Size(ctx context.Context) (int, error)

        // Bulk operations
        GetBulk(ctx context.Context, modelIDs []string) (map[string]*database.ModelMetadata, error)
        SetBulk(ctx context.Context, models map[string]*database.ModelMetadata) error

        // Provider and capability operations
        GetProviderModels(ctx context.Context, providerID string) ([]*database.ModelMetadata, error)
        SetProviderModels(ctx context.Context, providerID string, models []*database.ModelMetadata) error
        DeleteProviderModels(ctx context.Context, providerID string) error
        GetByCapability(ctx context.Context, capability string) ([]*database.ModelMetadata, error)
        SetByCapability(ctx context.Context, capability string, models []*database.ModelMetadata) error

        // Health check
        HealthCheck(ctx context.Context) error
}

func NewModelMetadataService(
        client *modelsdev.Client,
        repo *database.ModelMetadataRepository,
        cache CacheInterface,
        config *ModelMetadataConfig,
        log *logrus.Logger,
) *ModelMetadataService <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = getDefaultModelMetadataConfig()
        }</span>

        <span class="cov0" title="0">service := &amp;ModelMetadataService{
                modelsdevClient: client,
                repository:      repo,
                cache:           cache,
                config:          config,
                log:             log,
        }

        if config.EnableAutoRefresh </span><span class="cov0" title="0">{
                go service.startAutoRefresh()
        }</span>

        <span class="cov0" title="0">return service</span>
}

func getDefaultModelMetadataConfig() *ModelMetadataConfig <span class="cov1" title="1">{
        return &amp;ModelMetadataConfig{
                RefreshInterval:   24 * time.Hour,
                CacheTTL:          1 * time.Hour,
                DefaultBatchSize:  100,
                MaxRetries:        3,
                RetryDelay:        5 * time.Second,
                EnableAutoRefresh: true,
        }
}</span>

func (s *ModelMetadataService) GetModel(ctx context.Context, modelID string) (*database.ModelMetadata, error) <span class="cov0" title="0">{
        if cached, exists, err := s.cache.Get(ctx, modelID); err == nil &amp;&amp; exists </span><span class="cov0" title="0">{
                s.log.WithField("model_id", modelID).Debug("Cache hit for model")
                return cached, nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).WithField("model_id", modelID).Warn("Cache error, falling back to database")
        }</span>

        <span class="cov0" title="0">metadata, err := s.repository.GetModelMetadata(ctx, modelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get model metadata: %w", err)
        }</span>

        // Store in cache (async to not block the request)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ctx := context.Background()
                if err := s.cache.Set(ctx, modelID, metadata); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("model_id", modelID).Warn("Failed to set cache")
                }</span>
        }()

        <span class="cov0" title="0">return metadata, nil</span>
}

func (s *ModelMetadataService) ListModels(ctx context.Context, providerID string, modelType string, page int, limit int) ([]*database.ModelMetadata, int, error) <span class="cov0" title="0">{
        offset := 0
        if page &gt; 0 </span><span class="cov0" title="0">{
                offset = (page - 1) * limit
        }</span>

        <span class="cov0" title="0">models, total, err := s.repository.ListModels(ctx, providerID, modelType, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list models: %w", err)
        }</span>

        // Store in cache (async to not block the request)
        <span class="cov0" title="0">go func(models []*database.ModelMetadata) </span><span class="cov0" title="0">{
                ctx := context.Background()
                cacheEntries := make(map[string]*database.ModelMetadata)
                for _, model := range models </span><span class="cov0" title="0">{
                        cacheEntries[model.ModelID] = model
                }</span>

                <span class="cov0" title="0">if err := s.cache.SetBulk(ctx, cacheEntries); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).Warn("Failed to set bulk cache")
                }</span>
        }(models)

        <span class="cov0" title="0">return models, total, nil</span>
}

func (s *ModelMetadataService) SearchModels(ctx context.Context, query string, page int, limit int) ([]*database.ModelMetadata, int, error) <span class="cov0" title="0">{
        offset := 0
        if page &gt; 0 </span><span class="cov0" title="0">{
                offset = (page - 1) * limit
        }</span>

        <span class="cov0" title="0">models, total, err := s.repository.SearchModels(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to search models: %w", err)
        }</span>

        // Store in cache (async to not block the request)
        <span class="cov0" title="0">go func(models []*database.ModelMetadata) </span><span class="cov0" title="0">{
                ctx := context.Background()
                cacheEntries := make(map[string]*database.ModelMetadata)
                for _, model := range models </span><span class="cov0" title="0">{
                        cacheEntries[model.ModelID] = model
                }</span>

                <span class="cov0" title="0">if err := s.cache.SetBulk(ctx, cacheEntries); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).Warn("Failed to set bulk cache")
                }</span>
        }(models)

        <span class="cov0" title="0">return models, total, nil</span>
}

func (s *ModelMetadataService) RefreshModels(ctx context.Context) error <span class="cov0" title="0">{
        s.log.Info("Starting models refresh")

        history := &amp;database.ModelsRefreshHistory{
                RefreshType: "full",
                Status:      "in_progress",
                StartedAt:   time.Now(),
                Metadata:    make(map[string]interface{}),
        }

        if err := s.repository.CreateRefreshHistory(ctx, history); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create refresh history: %w", err)
        }</span>

        <span class="cov0" title="0">providers, err := s.modelsdevClient.ListProviders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.completeRefreshHistory(ctx, history, "failed", 0, 0, err.Error())
                return fmt.Errorf("failed to list providers: %w", err)
        }</span>

        <span class="cov0" title="0">totalModels := 0
        failedModels := 0

        for _, provider := range providers.Providers </span><span class="cov0" title="0">{
                s.log.WithField("provider", provider.ID).Info("Refreshing models for provider")

                providerModels, err := s.refreshProviderModels(ctx, provider.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("provider", provider.ID).Error("Failed to refresh provider models")
                        failedModels++
                        continue</span>
                }

                <span class="cov0" title="0">totalModels += providerModels

                if err := s.repository.UpdateProviderSyncInfo(ctx, provider.ID, providerModels, providerModels); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("provider", provider.ID).Error("Failed to update provider sync info")
                }</span>
        }

        <span class="cov0" title="0">history.ModelsRefreshed = totalModels
        history.ModelsFailed = failedModels
        history.Status = "completed"

        completedAt := time.Now()
        history.CompletedAt = &amp;completedAt
        duration := int(completedAt.Sub(history.StartedAt).Seconds())
        history.DurationSeconds = &amp;duration

        if err := s.repository.CreateRefreshHistory(ctx, history); err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).Error("Failed to update refresh history")
        }</span>

        <span class="cov0" title="0">s.log.WithFields(logrus.Fields{
                "total_models":  totalModels,
                "failed_models": failedModels,
                "duration":      history.DurationSeconds,
        }).Info("Models refresh completed")

        return nil</span>
}

func (s *ModelMetadataService) RefreshProviderModels(ctx context.Context, providerID string) error <span class="cov0" title="0">{
        s.log.WithField("provider", providerID).Info("Refreshing models for provider")

        history := &amp;database.ModelsRefreshHistory{
                RefreshType: "provider",
                Status:      "in_progress",
                StartedAt:   time.Now(),
                Metadata:    map[string]interface{}{"provider_id": providerID},
        }

        if err := s.repository.CreateRefreshHistory(ctx, history); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create refresh history: %w", err)
        }</span>

        <span class="cov0" title="0">modelCount, err := s.refreshProviderModels(ctx, providerID)
        if err != nil </span><span class="cov0" title="0">{
                s.completeRefreshHistory(ctx, history, "failed", 0, modelCount, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">history.ModelsRefreshed = modelCount
        history.Status = "completed"

        completedAt := time.Now()
        history.CompletedAt = &amp;completedAt
        duration := int(completedAt.Sub(history.StartedAt).Seconds())
        history.DurationSeconds = &amp;duration

        if err := s.repository.CreateRefreshHistory(ctx, history); err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).Error("Failed to update refresh history")
        }</span>

        <span class="cov0" title="0">if err := s.repository.UpdateProviderSyncInfo(ctx, providerID, modelCount, modelCount); err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).Error("Failed to update provider sync info")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ModelMetadataService) GetRefreshHistory(ctx context.Context, limit int) ([]*database.ModelsRefreshHistory, error) <span class="cov0" title="0">{
        histories, err := s.repository.GetLatestRefreshHistory(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get refresh history: %w", err)
        }</span>

        <span class="cov0" title="0">return histories, nil</span>
}

func (s *ModelMetadataService) GetProviderModels(ctx context.Context, providerID string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        models, _, err := s.repository.ListModels(ctx, providerID, "", 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider models: %w", err)
        }</span>

        <span class="cov0" title="0">return models, nil</span>
}

func (s *ModelMetadataService) CompareModels(ctx context.Context, modelIDs []string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        models := make([]*database.ModelMetadata, 0, len(modelIDs))

        for _, modelID := range modelIDs </span><span class="cov0" title="0">{
                metadata, err := s.GetModel(ctx, modelID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("model_id", modelID).Warn("Failed to get model for comparison")
                        continue</span>
                }
                <span class="cov0" title="0">models = append(models, metadata)</span>
        }

        <span class="cov0" title="0">if len(models) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid models found for comparison")
        }</span>

        <span class="cov0" title="0">return models, nil</span>
}

func (s *ModelMetadataService) GetModelsByCapability(ctx context.Context, capability string) ([]*database.ModelMetadata, error) <span class="cov0" title="0">{
        allModels, _, err := s.repository.ListModels(ctx, "", "", 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list models: %w", err)
        }</span>

        <span class="cov0" title="0">filtered := make([]*database.ModelMetadata, 0)
        for _, model := range allModels </span><span class="cov0" title="0">{
                var hasCapability bool

                switch capability </span>{
                case "vision":<span class="cov0" title="0">
                        hasCapability = model.SupportsVision</span>
                case "function_calling":<span class="cov0" title="0">
                        hasCapability = model.SupportsFunctionCalling</span>
                case "streaming":<span class="cov0" title="0">
                        hasCapability = model.SupportsStreaming</span>
                case "json_mode":<span class="cov0" title="0">
                        hasCapability = model.SupportsJSONMode</span>
                case "image_generation":<span class="cov0" title="0">
                        hasCapability = model.SupportsImageGeneration</span>
                case "audio":<span class="cov0" title="0">
                        hasCapability = model.SupportsAudio</span>
                case "code_generation":<span class="cov0" title="0">
                        hasCapability = model.SupportsCodeGeneration</span>
                case "reasoning":<span class="cov0" title="0">
                        hasCapability = model.SupportsReasoning</span>
                }

                <span class="cov0" title="0">if hasCapability </span><span class="cov0" title="0">{
                        filtered = append(filtered, model)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

func (s *ModelMetadataService) refreshProviderModels(ctx context.Context, providerID string) (int, error) <span class="cov0" title="0">{
        opts := &amp;modelsdev.ListModelsOptions{
                Provider: providerID,
                Limit:    s.config.DefaultBatchSize,
        }

        allModels := make([]modelsdev.ModelInfo, 0)
        page := 1

        for </span><span class="cov0" title="0">{
                opts.Page = page
                response, err := s.modelsdevClient.ListModels(ctx, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to list models for provider %s: %w", providerID, err)
                }</span>

                <span class="cov0" title="0">allModels = append(allModels, response.Models...)

                if len(response.Models) &lt; opts.Limit </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">page++</span>
        }

        <span class="cov0" title="0">for _, modelInfo := range allModels </span><span class="cov0" title="0">{
                metadata := s.convertModelInfoToMetadata(modelInfo, providerID)

                if err := s.repository.CreateModelMetadata(ctx, metadata); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("model_id", modelInfo.ID).Error("Failed to store model metadata")
                        continue</span>
                }

                <span class="cov0" title="0">if modelInfo.Performance != nil &amp;&amp; len(modelInfo.Performance.Benchmarks) &gt; 0 </span><span class="cov0" title="0">{
                        s.storeBenchmarks(ctx, modelInfo.ID, modelInfo.Performance.Benchmarks)
                }</span>

                <span class="cov0" title="0">go func(modelID string, metadata *database.ModelMetadata) </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        if err := s.cache.Set(ctx, modelID, metadata); err != nil </span><span class="cov0" title="0">{
                                s.log.WithError(err).WithField("model_id", modelID).Warn("Failed to set cache")
                        }</span>
                }(modelInfo.ID, metadata)
        }

        <span class="cov0" title="0">return len(allModels), nil</span>
}

func (s *ModelMetadataService) storeBenchmarks(ctx context.Context, modelID string, benchmarks map[string]float64) error <span class="cov0" title="0">{
        for name, score := range benchmarks </span><span class="cov0" title="0">{
                benchmark := &amp;database.ModelBenchmark{
                        ModelID:       modelID,
                        BenchmarkName: name,
                        Score:         &amp;score,
                }

                if err := s.repository.CreateBenchmark(ctx, benchmark); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithFields(logrus.Fields{
                                "model_id":  modelID,
                                "benchmark": name,
                        }).Error("Failed to store benchmark")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ModelMetadataService) convertModelInfoToMetadata(info modelsdev.ModelInfo, providerID string) *database.ModelMetadata <span class="cov0" title="0">{
        var pricingInput, pricingOutput *float64
        if info.Pricing != nil </span><span class="cov0" title="0">{
                pricingInput = &amp;info.Pricing.InputPrice
                pricingOutput = &amp;info.Pricing.OutputPrice
        }</span>

        <span class="cov0" title="0">var benchmarkScore, reliabilityScore *float64
        var popularityScore *int
        if info.Performance != nil </span><span class="cov0" title="0">{
                benchmarkScore = &amp;info.Performance.BenchmarkScore
                popularityScore = &amp;info.Performance.PopularityScore
                reliabilityScore = &amp;info.Performance.ReliabilityScore
        }</span>

        <span class="cov0" title="0">modelFamily := &amp;info.Family
        if info.Family == "" </span><span class="cov0" title="0">{
                modelFamily = nil
        }</span>

        <span class="cov0" title="0">version := &amp;info.Version
        if info.Version == "" </span><span class="cov0" title="0">{
                version = nil
        }</span>

        <span class="cov0" title="0">return &amp;database.ModelMetadata{
                ModelID:                 info.ID,
                ModelName:               info.Name,
                ProviderID:              providerID,
                ProviderName:            info.Provider,
                Description:             info.Description,
                ContextWindow:           &amp;info.ContextWindow,
                MaxTokens:               &amp;info.MaxTokens,
                PricingInput:            pricingInput,
                PricingOutput:           pricingOutput,
                PricingCurrency:         "USD",
                SupportsVision:          info.Capabilities.Vision,
                SupportsFunctionCalling: info.Capabilities.FunctionCalling,
                SupportsStreaming:       info.Capabilities.Streaming,
                SupportsJSONMode:        info.Capabilities.JSONMode,
                SupportsImageGeneration: info.Capabilities.ImageGeneration,
                SupportsAudio:           info.Capabilities.Audio,
                SupportsCodeGeneration:  info.Capabilities.CodeGeneration,
                SupportsReasoning:       info.Capabilities.Reasoning,
                BenchmarkScore:          benchmarkScore,
                PopularityScore:         popularityScore,
                ReliabilityScore:        reliabilityScore,
                ModelFamily:             modelFamily,
                Version:                 version,
                Tags:                    info.Tags,
                ModelsDevURL:            &amp;info.ID,
                ModelsDevID:             &amp;info.ID,
                RawMetadata:             info.Metadata,
                LastRefreshedAt:         time.Now(),
        }</span>
}

func (s *ModelMetadataService) completeRefreshHistory(ctx context.Context, history *database.ModelsRefreshHistory, status string, modelsRefreshed, modelsFailed int, errorMessage string) <span class="cov0" title="0">{
        history.Status = status
        history.ModelsRefreshed = modelsRefreshed
        history.ModelsFailed = modelsFailed
        history.ErrorMessage = &amp;errorMessage

        completedAt := time.Now()
        history.CompletedAt = &amp;completedAt
        duration := int(completedAt.Sub(history.StartedAt).Seconds())
        history.DurationSeconds = &amp;duration

        if err := s.repository.CreateRefreshHistory(ctx, history); err != nil </span><span class="cov0" title="0">{
                s.log.WithError(err).Error("Failed to complete refresh history")
        }</span>
}

func (s *ModelMetadataService) startAutoRefresh() <span class="cov0" title="0">{
        ticker := time.NewTicker(s.config.RefreshInterval)
        defer ticker.Stop()

        s.log.WithField("interval", s.config.RefreshInterval).Info("Starting auto refresh")

        for range ticker.C </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
                if err := s.RefreshModels(ctx); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).Error("Auto refresh failed")
                }</span>
                <span class="cov0" title="0">cancel()</span>
        }
}

// InMemoryCache implements CacheInterface for in-memory caching
type InMemoryCache struct {
        mu     sync.RWMutex
        models map[string]*database.ModelMetadata
        ttl    time.Duration
        timers map[string]*time.Timer
}

func NewInMemoryCache(ttl time.Duration) *InMemoryCache <span class="cov10" title="14">{
        return &amp;InMemoryCache{
                models: make(map[string]*database.ModelMetadata),
                ttl:    ttl,
                timers: make(map[string]*time.Timer),
        }
}</span>

func (c *InMemoryCache) Get(ctx context.Context, modelID string) (*database.ModelMetadata, bool, error) <span class="cov8" title="9">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        model, exists := c.models[modelID]
        return model, exists, nil
}</span>

func (c *InMemoryCache) Set(ctx context.Context, modelID string, metadata *database.ModelMetadata) error <span class="cov8" title="9">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if timer, exists := c.timers[modelID]; exists </span><span class="cov0" title="0">{
                timer.Stop()
        }</span>

        <span class="cov8" title="9">c.models[modelID] = metadata
        c.timers[modelID] = time.AfterFunc(c.ttl, func() </span><span class="cov1" title="1">{
                ctx := context.Background()
                c.Delete(ctx, modelID)
        }</span>)

        <span class="cov8" title="9">return nil</span>
}

func (c *InMemoryCache) Delete(ctx context.Context, modelID string) error <span class="cov4" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.models, modelID)
        delete(c.timers, modelID)
        return nil
}</span>

func (c *InMemoryCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for _, timer := range c.timers </span><span class="cov4" title="3">{
                timer.Stop()
        }</span>

        <span class="cov1" title="1">c.models = make(map[string]*database.ModelMetadata)
        c.timers = make(map[string]*time.Timer)
        return nil</span>
}

func (c *InMemoryCache) Size(ctx context.Context) (int, error) <span class="cov3" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.models), nil
}</span>

func (c *InMemoryCache) GetBulk(ctx context.Context, modelIDs []string) (map[string]*database.ModelMetadata, error) <span class="cov1" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        result := make(map[string]*database.ModelMetadata)
        for _, modelID := range modelIDs </span><span class="cov4" title="3">{
                if model, exists := c.models[modelID]; exists </span><span class="cov3" title="2">{
                        result[modelID] = model
                }</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

func (c *InMemoryCache) SetBulk(ctx context.Context, models map[string]*database.ModelMetadata) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for modelID, metadata := range models </span><span class="cov3" title="2">{
                if timer, exists := c.timers[modelID]; exists </span><span class="cov0" title="0">{
                        timer.Stop()
                }</span>
                <span class="cov3" title="2">c.models[modelID] = metadata
                c.timers[modelID] = time.AfterFunc(c.ttl, func() </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        c.Delete(ctx, modelID)
                }</span>)
        }

        <span class="cov1" title="1">return nil</span>
}

func (c *InMemoryCache) GetProviderModels(ctx context.Context, providerID string) ([]*database.ModelMetadata, error) <span class="cov1" title="1">{
        // In-memory cache doesn't support provider-specific queries
        return nil, nil
}</span>

func (c *InMemoryCache) SetProviderModels(ctx context.Context, providerID string, models []*database.ModelMetadata) error <span class="cov1" title="1">{
        // In-memory cache doesn't support provider-specific caching
        return nil
}</span>

func (c *InMemoryCache) DeleteProviderModels(ctx context.Context, providerID string) error <span class="cov1" title="1">{
        // In-memory cache doesn't support provider-specific deletion
        return nil
}</span>

func (c *InMemoryCache) GetByCapability(ctx context.Context, capability string) ([]*database.ModelMetadata, error) <span class="cov1" title="1">{
        // In-memory cache doesn't support capability-specific queries
        return nil, nil
}</span>

func (c *InMemoryCache) SetByCapability(ctx context.Context, capability string, models []*database.ModelMetadata) error <span class="cov1" title="1">{
        // In-memory cache doesn't support capability-specific caching
        return nil
}</span>

func (c *InMemoryCache) HealthCheck(ctx context.Context) error <span class="cov1" title="1">{
        // In-memory cache is always healthy
        return nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package services

import (
        "context"
        "fmt"
        "math/rand"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// HighAvailabilityManager provides high availability features with load balancing and failover
type HighAvailabilityManager struct {
        mu              sync.RWMutex
        instances       map[string]*ServiceInstance
        loadBalancer    LoadBalancer
        failoverManager *FailoverManager
        healthChecker   *HealthChecker
        logger          *logrus.Logger
        stopChan        chan struct{}
}

// ServiceInstance represents a service instance in the HA cluster
type ServiceInstance struct {
        ID         string
        Address    string
        Port       int
        Protocol   string
        Status     InstanceStatus
        LastHealth time.Time
        LoadScore  int // 0-100, higher means more loaded
        Metadata   map[string]interface{}
}

// InstanceStatus represents the status of a service instance
type InstanceStatus int

const (
        StatusStarting InstanceStatus = iota
        StatusHealthy
        StatusDegraded
        StatusUnhealthy
        StatusDown
)

// LoadBalancer handles load distribution across instances
type LoadBalancer interface {
        SelectInstance(protocol string, instances []*ServiceInstance) *ServiceInstance
        UpdateLoad(instanceID string, loadScore int)
}

// RoundRobinLoadBalancer implements round-robin load balancing
type RoundRobinLoadBalancer struct {
        mu       sync.Mutex
        lastUsed map[string]int // protocol -&gt; last used index
}

// LeastLoadedLoadBalancer implements least-loaded load balancing
type LeastLoadedLoadBalancer struct {
        mu sync.RWMutex
}

// FailoverManager handles automatic failover
type FailoverManager struct {
        mu                sync.RWMutex
        failoverGroups    map[string][]*ServiceInstance
        activeInstances   map[string]*ServiceInstance
        failoverThreshold time.Duration
        logger            *logrus.Logger
}

// HealthChecker performs health checks on service instances
type HealthChecker struct {
        mu                 sync.RWMutex
        checkInterval      time.Duration
        timeout            time.Duration
        unhealthyThreshold int
        healthChecks       map[string]*HealthStatus
        logger             *logrus.Logger
}

// HealthStatus represents the health status of an instance
type HealthStatus struct {
        InstanceID          string
        LastCheck           time.Time
        ConsecutiveFailures int
        IsHealthy           bool
        ResponseTime        time.Duration
        Error               string
}

// NewHighAvailabilityManager creates a new HA manager
func NewHighAvailabilityManager(logger *logrus.Logger) *HighAvailabilityManager <span class="cov8" title="12">{
        return &amp;HighAvailabilityManager{
                instances:       make(map[string]*ServiceInstance),
                loadBalancer:    &amp;LeastLoadedLoadBalancer{},
                failoverManager: NewFailoverManager(logger),
                healthChecker:   NewHealthChecker(logger),
                logger:          logger,
                stopChan:        make(chan struct{}),
        }
}</span>

// RegisterInstance registers a new service instance
func (ham *HighAvailabilityManager) RegisterInstance(instance *ServiceInstance) error <span class="cov8" title="11">{
        ham.mu.Lock()
        defer ham.mu.Unlock()

        if _, exists := ham.instances[instance.ID]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("instance %s already registered", instance.ID)
        }</span>

        <span class="cov7" title="10">instance.Status = StatusStarting
        instance.LastHealth = time.Now()
        ham.instances[instance.ID] = instance

        // Register with failover manager
        ham.failoverManager.RegisterInstance(instance)

        // Register with health checker
        ham.healthChecker.RegisterInstance(instance.ID, instance.Address, instance.Port)

        ham.logger.WithFields(logrus.Fields{
                "instanceId": instance.ID,
                "protocol":   instance.Protocol,
                "address":    instance.Address,
                "port":       instance.Port,
        }).Info("Service instance registered")

        return nil</span>
}

// UnregisterInstance removes a service instance
func (ham *HighAvailabilityManager) UnregisterInstance(instanceID string) error <span class="cov3" title="2">{
        ham.mu.Lock()
        defer ham.mu.Unlock()

        if _, exists := ham.instances[instanceID]; !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("instance %s not registered", instanceID)
        }</span>

        <span class="cov1" title="1">delete(ham.instances, instanceID)

        // Unregister from failover manager
        ham.failoverManager.UnregisterInstance(instanceID)

        // Unregister from health checker
        ham.healthChecker.UnregisterInstance(instanceID)

        ham.logger.WithField("instanceId", instanceID).Info("Service instance unregistered")
        return nil</span>
}

// GetInstance selects an available instance for a protocol
func (ham *HighAvailabilityManager) GetInstance(protocol string) (*ServiceInstance, error) <span class="cov3" title="2">{
        ham.mu.RLock()
        var instances []*ServiceInstance
        for _, instance := range ham.instances </span><span class="cov1" title="1">{
                if instance.Protocol == protocol &amp;&amp; instance.Status == StatusHealthy </span><span class="cov1" title="1">{
                        instances = append(instances, instance)
                }</span>
        }
        <span class="cov3" title="2">ham.mu.RUnlock()

        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no healthy instances available for protocol %s", protocol)
        }</span>

        <span class="cov1" title="1">selected := ham.loadBalancer.SelectInstance(protocol, instances)

        ham.logger.WithFields(logrus.Fields{
                "protocol":   protocol,
                "instanceId": selected.ID,
                "address":    selected.Address,
                "port":       selected.Port,
        }).Debug("Instance selected by load balancer")

        return selected, nil</span>
}

// UpdateInstanceLoad updates the load score for an instance
func (ham *HighAvailabilityManager) UpdateInstanceLoad(instanceID string, loadScore int) error <span class="cov3" title="2">{
        ham.mu.Lock()
        defer ham.mu.Unlock()

        instance, exists := ham.instances[instanceID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("instance %s not found", instanceID)
        }</span>

        <span class="cov1" title="1">instance.LoadScore = loadScore
        ham.loadBalancer.UpdateLoad(instanceID, loadScore)

        return nil</span>
}

// GetAllInstances returns all registered instances
func (ham *HighAvailabilityManager) GetAllInstances() []*ServiceInstance <span class="cov3" title="2">{
        ham.mu.RLock()
        defer ham.mu.RUnlock()

        instances := make([]*ServiceInstance, 0, len(ham.instances))
        for _, instance := range ham.instances </span><span class="cov1" title="1">{
                instances = append(instances, instance)
        }</span>

        <span class="cov3" title="2">return instances</span>
}

// GetInstancesByProtocol returns instances for a specific protocol
func (ham *HighAvailabilityManager) GetInstancesByProtocol(protocol string) []*ServiceInstance <span class="cov4" title="3">{
        ham.mu.RLock()
        defer ham.mu.RUnlock()

        var instances []*ServiceInstance
        for _, instance := range ham.instances </span><span class="cov7" title="9">{
                if instance.Protocol == protocol </span><span class="cov4" title="3">{
                        instances = append(instances, instance)
                }</span>
        }

        <span class="cov4" title="3">return instances</span>
}

// Start begins the HA management processes
func (ham *HighAvailabilityManager) Start(ctx context.Context) error <span class="cov1" title="1">{
        ham.logger.Info("Starting High Availability Manager")

        // Start health checker
        go ham.healthChecker.Start(ctx, ham.handleHealthUpdate)

        // Start failover manager
        go ham.failoverManager.Start(ctx)

        return nil
}</span>

// Stop stops the HA management processes
func (ham *HighAvailabilityManager) Stop() <span class="cov3" title="2">{
        ham.logger.Info("Stopping High Availability Manager")

        close(ham.stopChan)
        ham.healthChecker.Stop()
        ham.failoverManager.Stop()
}</span>

// Private methods

func (ham *HighAvailabilityManager) handleHealthUpdate(instanceID string, healthy bool) <span class="cov5" title="5">{
        ham.mu.Lock()
        defer ham.mu.Unlock()

        instance, exists := ham.instances[instanceID]
        if !exists </span><span class="cov3" title="2">{
                return
        }</span>

        <span class="cov4" title="3">oldStatus := instance.Status

        if healthy </span><span class="cov3" title="2">{
                if instance.Status != StatusHealthy </span><span class="cov3" title="2">{
                        instance.Status = StatusHealthy
                        ham.logger.WithField("instanceId", instanceID).Info("Instance became healthy")
                }</span>
        } else<span class="cov1" title="1"> {
                if instance.Status == StatusHealthy </span><span class="cov0" title="0">{
                        instance.Status = StatusUnhealthy
                        ham.logger.WithField("instanceId", instanceID).Warn("Instance became unhealthy")

                        // Trigger failover
                        go ham.failoverManager.HandleInstanceFailure(instance)
                }</span>
        }

        <span class="cov4" title="3">instance.LastHealth = time.Now()

        if oldStatus != instance.Status </span><span class="cov3" title="2">{
                ham.logger.WithFields(logrus.Fields{
                        "instanceId": instanceID,
                        "oldStatus":  oldStatus,
                        "newStatus":  instance.Status,
                }).Info("Instance status changed")
        }</span>
}

// LoadBalancer implementations

// SelectInstance selects an instance using round-robin
func (rr *RoundRobinLoadBalancer) SelectInstance(protocol string, instances []*ServiceInstance) *ServiceInstance <span class="cov6" title="7">{
        rr.mu.Lock()
        defer rr.mu.Unlock()

        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="6">if rr.lastUsed == nil </span><span class="cov1" title="1">{
                rr.lastUsed = make(map[string]int)
        }</span>

        <span class="cov6" title="6">lastIndex := rr.lastUsed[protocol]
        nextIndex := (lastIndex + 1) % len(instances)
        rr.lastUsed[protocol] = nextIndex

        return instances[nextIndex]</span>
}

// UpdateLoad updates load information (no-op for round-robin)
func (rr *RoundRobinLoadBalancer) UpdateLoad(instanceID string, loadScore int) {<span class="cov1" title="1">
        // Round-robin doesn't use load scores
}</span>

// SelectInstance selects the least loaded instance
func (ll *LeastLoadedLoadBalancer) SelectInstance(protocol string, instances []*ServiceInstance) *ServiceInstance <span class="cov4" title="3">{
        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Find instance with lowest load score
        <span class="cov3" title="2">var selected *ServiceInstance
        minLoad := 101 // Higher than max possible load score

        for _, instance := range instances </span><span class="cov5" title="4">{
                if instance.LoadScore &lt; minLoad </span><span class="cov4" title="3">{
                        minLoad = instance.LoadScore
                        selected = instance
                }</span>
        }

        <span class="cov3" title="2">return selected</span>
}

// UpdateLoad updates load information
func (ll *LeastLoadedLoadBalancer) UpdateLoad(instanceID string, loadScore int) {<span class="cov3" title="2">
        // Load scores are stored in the instances themselves
}</span>

// FailoverManager implementation

// NewFailoverManager creates a new failover manager
func NewFailoverManager(logger *logrus.Logger) *FailoverManager <span class="cov9" title="18">{
        return &amp;FailoverManager{
                failoverGroups:    make(map[string][]*ServiceInstance),
                activeInstances:   make(map[string]*ServiceInstance),
                failoverThreshold: 30 * time.Second,
                logger:            logger,
        }
}</span>

// RegisterInstance registers an instance with the failover manager
func (fm *FailoverManager) RegisterInstance(instance *ServiceInstance) <span class="cov9" title="16">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        protocol := instance.Protocol
        fm.failoverGroups[protocol] = append(fm.failoverGroups[protocol], instance)

        // If this is the first instance or current active is unhealthy, make it active
        if _, exists := fm.activeInstances[protocol]; !exists </span><span class="cov8" title="12">{
                fm.activeInstances[protocol] = instance
                fm.logger.WithFields(logrus.Fields{
                        "protocol":   protocol,
                        "instanceId": instance.ID,
                }).Info("Instance set as active for protocol")
        }</span>
}

// UnregisterInstance removes an instance from failover management
func (fm *FailoverManager) UnregisterInstance(instanceID string) <span class="cov3" title="2">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        // Remove from all failover groups
        for protocol, instances := range fm.failoverGroups </span><span class="cov3" title="2">{
                for i, instance := range instances </span><span class="cov3" title="2">{
                        if instance.ID == instanceID </span><span class="cov3" title="2">{
                                fm.failoverGroups[protocol] = append(instances[:i], instances[i+1:]...)

                                // If this was the active instance, promote another
                                if active, exists := fm.activeInstances[protocol]; exists &amp;&amp; active.ID == instanceID </span><span class="cov3" title="2">{
                                        fm.promoteNewActive(protocol)
                                }</span>
                                <span class="cov3" title="2">break</span>
                        }
                }
        }
}

// HandleInstanceFailure handles failure of an instance
func (fm *FailoverManager) HandleInstanceFailure(instance *ServiceInstance) <span class="cov1" title="1">{
        fm.mu.Lock()
        defer fm.mu.Unlock()

        protocol := instance.Protocol

        // If this was the active instance, promote a backup
        if active, exists := fm.activeInstances[protocol]; exists &amp;&amp; active.ID == instance.ID </span><span class="cov1" title="1">{
                fm.logger.WithFields(logrus.Fields{
                        "protocol":   protocol,
                        "instanceId": instance.ID,
                }).Warn("Active instance failed, promoting backup")

                fm.promoteNewActive(protocol)
        }</span>
}

// Start begins failover monitoring
func (fm *FailoverManager) Start(ctx context.Context) <span class="cov1" title="1">{
        // Periodic check for failed instances
        go func() </span><span class="cov1" title="1">{
                ticker := time.NewTicker(10 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov1" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                fm.checkFailoverStatus()</span>
                        }
                }
        }()
}

// Stop stops failover monitoring
func (fm *FailoverManager) Stop() {<span class="cov4" title="3">
        // Cleanup handled by context cancellation
}</span>

func (fm *FailoverManager) promoteNewActive(protocol string) <span class="cov4" title="3">{
        instances := fm.failoverGroups[protocol]

        // Find a healthy backup instance
        for _, instance := range instances </span><span class="cov3" title="2">{
                if instance.Status == StatusHealthy </span><span class="cov1" title="1">{
                        fm.activeInstances[protocol] = instance
                        fm.logger.WithFields(logrus.Fields{
                                "protocol":   protocol,
                                "instanceId": instance.ID,
                        }).Info("New active instance promoted")
                        return
                }</span>
        }

        <span class="cov3" title="2">fm.logger.WithField("protocol", protocol).Error("No healthy backup instances available")</span>
}

func (fm *FailoverManager) checkFailoverStatus() <span class="cov3" title="2">{
        fm.mu.RLock()
        defer fm.mu.RUnlock()

        for protocol, active := range fm.activeInstances </span><span class="cov3" title="2">{
                if active.Status != StatusHealthy </span><span class="cov1" title="1">{
                        // Active instance is not healthy, should have been handled by failure detection
                        fm.logger.WithFields(logrus.Fields{
                                "protocol":       protocol,
                                "activeInstance": active.ID,
                                "status":         active.Status,
                        }).Warn("Active instance is not healthy")
                }</span>
        }
}

// HealthChecker implementation

// NewHealthChecker creates a new health checker
func NewHealthChecker(logger *logrus.Logger) *HealthChecker <span class="cov9" title="18">{
        return &amp;HealthChecker{
                checkInterval:      30 * time.Second,
                timeout:            5 * time.Second,
                unhealthyThreshold: 3,
                healthChecks:       make(map[string]*HealthStatus),
                logger:             logger,
        }
}</span>

// RegisterInstance registers an instance for health checking
func (hc *HealthChecker) RegisterInstance(instanceID, address string, port int) <span class="cov8" title="13">{
        hc.mu.Lock()
        defer hc.mu.Unlock()

        hc.healthChecks[instanceID] = &amp;HealthStatus{
                InstanceID: instanceID,
                LastCheck:  time.Now(),
                IsHealthy:  true, // Assume healthy initially
        }
}</span>

// UnregisterInstance removes an instance from health checking
func (hc *HealthChecker) UnregisterInstance(instanceID string) <span class="cov3" title="2">{
        hc.mu.Lock()
        defer hc.mu.Unlock()

        delete(hc.healthChecks, instanceID)
}</span>

// Start begins health checking
func (hc *HealthChecker) Start(ctx context.Context, healthUpdateFunc func(string, bool)) <span class="cov1" title="1">{
        go func() </span><span class="cov1" title="1">{
                ticker := time.NewTicker(hc.checkInterval)
                defer ticker.Stop()

                for </span><span class="cov1" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                hc.performHealthChecks(healthUpdateFunc)</span>
                        }
                }
        }()
}

// Stop stops health checking
func (hc *HealthChecker) Stop() {<span class="cov4" title="3">
        // Cleanup handled by context cancellation
}</span>

func (hc *HealthChecker) performHealthChecks(healthUpdateFunc func(string, bool)) <span class="cov1" title="1">{
        hc.mu.Lock()
        instances := make(map[string]*HealthStatus)
        for k, v := range hc.healthChecks </span><span class="cov1" title="1">{
                instances[k] = v
        }</span>
        <span class="cov1" title="1">hc.mu.Unlock()

        for instanceID, status := range instances </span><span class="cov1" title="1">{
                healthy := hc.checkInstanceHealth(instanceID)
                oldHealthy := status.IsHealthy

                if healthy </span><span class="cov1" title="1">{
                        status.ConsecutiveFailures = 0
                        status.IsHealthy = true
                }</span> else<span class="cov0" title="0"> {
                        status.ConsecutiveFailures++
                        if status.ConsecutiveFailures &gt;= hc.unhealthyThreshold </span><span class="cov0" title="0">{
                                status.IsHealthy = false
                        }</span>
                }

                <span class="cov1" title="1">status.LastCheck = time.Now()

                // Notify if health status changed
                if oldHealthy != status.IsHealthy </span><span class="cov0" title="0">{
                        healthUpdateFunc(instanceID, status.IsHealthy)
                }</span>
        }
}

func (hc *HealthChecker) checkInstanceHealth(instanceID string) bool <span class="cov8" title="12">{
        // Simplified health check - in real implementation, this would:
        // 1. Make HTTP request to /health endpoint
        // 2. Check TCP connectivity
        // 3. Perform protocol-specific health checks

        // For demo, randomly succeed/fail
        return rand.Intn(10) &gt; 1 // 80% success rate
}</span>

// Circuit Breaker for fault tolerance

type CircuitBreaker struct {
        mu                   sync.Mutex
        state                CircuitState
        failureThreshold     int
        successThreshold     int
        timeout              time.Duration
        consecutiveFailures  int
        consecutiveSuccesses int
        lastFailure          time.Time
}

type CircuitState int

const (
        StateClosed CircuitState = iota
        StateOpen
        StateHalfOpen
)

// String returns the string representation of CircuitState
func (s CircuitState) String() string <span class="cov5" title="4">{
        switch s </span>{
        case StateClosed:<span class="cov1" title="1">
                return "closed"</span>
        case StateOpen:<span class="cov1" title="1">
                return "open"</span>
        case StateHalfOpen:<span class="cov1" title="1">
                return "half-open"</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(failureThreshold, successThreshold int, timeout time.Duration) *CircuitBreaker <span class="cov10" title="20">{
        return &amp;CircuitBreaker{
                state:            StateClosed,
                failureThreshold: failureThreshold,
                successThreshold: successThreshold,
                timeout:          timeout,
        }
}</span>

// Call executes a function with circuit breaker protection
func (cb *CircuitBreaker) Call(fn func() error) error <span class="cov9" title="18">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        if cb.state == StateOpen </span><span class="cov4" title="3">{
                if time.Since(cb.lastFailure) &lt; cb.timeout </span><span class="cov1" title="1">{
                        return fmt.Errorf("circuit breaker is open")
                }</span>
                <span class="cov3" title="2">cb.state = StateHalfOpen</span>
        }

        <span class="cov9" title="17">err := fn()

        if err != nil </span><span class="cov7" title="10">{
                cb.onFailure()
                return err
        }</span>

        <span class="cov6" title="7">cb.onSuccess()
        return nil</span>
}

// GetState returns the current circuit breaker state
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov7" title="9">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        return cb.state
}</span>

// GetFailureCount returns the current consecutive failure count
func (cb *CircuitBreaker) GetFailureCount() int <span class="cov4" title="3">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        return cb.consecutiveFailures
}</span>

// GetLastFailure returns the timestamp of the last failure
func (cb *CircuitBreaker) GetLastFailure() *time.Time <span class="cov3" title="2">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        if cb.lastFailure.IsZero() </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">t := cb.lastFailure
        return &amp;t</span>
}

func (cb *CircuitBreaker) onFailure() <span class="cov7" title="10">{
        cb.consecutiveFailures++
        cb.lastFailure = time.Now()

        if cb.consecutiveFailures &gt;= cb.failureThreshold </span><span class="cov5" title="4">{
                cb.state = StateOpen
                cb.consecutiveSuccesses = 0
        }</span>
}

func (cb *CircuitBreaker) onSuccess() <span class="cov6" title="7">{
        cb.consecutiveSuccesses++

        if cb.state == StateHalfOpen &amp;&amp; cb.consecutiveSuccesses &gt;= cb.successThreshold </span><span class="cov1" title="1">{
                cb.state = StateClosed
                cb.consecutiveFailures = 0
                cb.consecutiveSuccesses = 0
        }</span>
}

// Service Registry for service discovery

type ServiceRegistry struct {
        mu       sync.RWMutex
        services map[string][]*ServiceEndpoint
        logger   *logrus.Logger
}

type ServiceEndpoint struct {
        ID       string
        Address  string
        Port     int
        Protocol string
        Metadata map[string]interface{}
}

// NewServiceRegistry creates a new service registry
func NewServiceRegistry(logger *logrus.Logger) *ServiceRegistry <span class="cov5" title="4">{
        return &amp;ServiceRegistry{
                services: make(map[string][]*ServiceEndpoint),
                logger:   logger,
        }
}</span>

// RegisterService registers a service endpoint
func (sr *ServiceRegistry) RegisterService(serviceType string, endpoint *ServiceEndpoint) <span class="cov5" title="5">{
        sr.mu.Lock()
        defer sr.mu.Unlock()

        sr.services[serviceType] = append(sr.services[serviceType], endpoint)

        sr.logger.WithFields(logrus.Fields{
                "serviceType": serviceType,
                "endpointId":  endpoint.ID,
                "address":     endpoint.Address,
                "port":        endpoint.Port,
        }).Info("Service endpoint registered")
}</span>

// UnregisterService removes a service endpoint
func (sr *ServiceRegistry) UnregisterService(serviceType, endpointID string) <span class="cov1" title="1">{
        sr.mu.Lock()
        defer sr.mu.Unlock()

        endpoints := sr.services[serviceType]
        for i, endpoint := range endpoints </span><span class="cov1" title="1">{
                if endpoint.ID == endpointID </span><span class="cov1" title="1">{
                        sr.services[serviceType] = append(endpoints[:i], endpoints[i+1:]...)
                        break</span>
                }
        }
}

// DiscoverServices discovers service endpoints
func (sr *ServiceRegistry) DiscoverServices(serviceType string) []*ServiceEndpoint <span class="cov5" title="5">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        endpoints := sr.services[serviceType]
        result := make([]*ServiceEndpoint, len(endpoints))
        copy(result, endpoints)

        return result
}</span>

// Load Balancer Strategies

// WeightedRoundRobinLoadBalancer implements weighted round-robin
type WeightedRoundRobinLoadBalancer struct {
        mu      sync.Mutex
        current map[string]int
        weights map[string]int
}

// RandomLoadBalancer implements random load balancing
type RandomLoadBalancer struct{}

// SelectInstance selects a random instance
func (rl *RandomLoadBalancer) SelectInstance(protocol string, instances []*ServiceInstance) *ServiceInstance <span class="cov3" title="2">{
        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">return instances[rand.Intn(len(instances))]</span>
}

// UpdateLoad updates load information (no-op for random)
func (rl *RandomLoadBalancer) UpdateLoad(instanceID string, loadScore int) {<span class="cov1" title="1">
        // Random load balancer doesn't use load scores
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package services

import (
        "context"
        "fmt"
        "sort"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolAnalyticsService provides comprehensive analytics for protocol usage
type ProtocolAnalyticsService struct {
        mu               sync.RWMutex
        metrics          map[string]*AnalyticsProtocolMetrics
        performanceData  map[string]*AnalyticsPerformanceStats
        usagePatterns    map[string]*AnalyticsUsagePattern
        logger           *logrus.Logger
        collectionWindow time.Duration
        retentionPeriod  time.Duration
}

// AnalyticsProtocolMetrics represents usage metrics for a protocol
type AnalyticsProtocolMetrics struct {
        Protocol           string
        TotalRequests      int64
        SuccessfulRequests int64
        FailedRequests     int64
        AverageLatency     time.Duration
        PeakLatency        time.Duration
        MinLatency         time.Duration
        ErrorRate          float64
        Throughput         float64 // requests per second
        LastUsed           time.Time
        ActiveConnections  int32
}

// AnalyticsPerformanceStats represents detailed performance statistics
type AnalyticsPerformanceStats struct {
        Protocol      string
        ResponseTimes []time.Duration
        ErrorCounts   map[string]int64
        SuccessCounts map[string]int64
        PeakUsageTime time.Time
        LowUsageTime  time.Time
        AverageLoad   float64
}

// AnalyticsUsagePattern represents usage patterns over time
type AnalyticsUsagePattern struct {
        Protocol       string
        HourlyUsage    [24]int64
        DailyUsage     [7]int64
        MonthlyUsage   [12]int64
        PeakHours      []int
        PeakDays       []time.Weekday
        TrendDirection string // "increasing", "decreasing", "stable"
}

// AnalyticsConfig represents configuration for the analytics service
type AnalyticsConfig struct {
        CollectionWindow  time.Duration
        RetentionPeriod   time.Duration
        MaxMetricsHistory int
        SamplingRate      float64
        EnableRealTime    bool
}

// NewProtocolAnalyticsService creates a new protocol analytics service
func NewProtocolAnalyticsService(config *AnalyticsConfig, logger *logrus.Logger) *ProtocolAnalyticsService <span class="cov4" title="13">{
        if config == nil </span><span class="cov4" title="11">{
                config = &amp;AnalyticsConfig{
                        CollectionWindow:  1 * time.Hour,
                        RetentionPeriod:   30 * 24 * time.Hour,
                        MaxMetricsHistory: 1000,
                        SamplingRate:      1.0,
                        EnableRealTime:    true,
                }
        }</span>

        <span class="cov4" title="13">return &amp;ProtocolAnalyticsService{
                metrics:          make(map[string]*AnalyticsProtocolMetrics),
                performanceData:  make(map[string]*AnalyticsPerformanceStats),
                usagePatterns:    make(map[string]*AnalyticsUsagePattern),
                logger:           logger,
                collectionWindow: config.CollectionWindow,
                retentionPeriod:  config.RetentionPeriod,
        }</span>
}

// RecordRequest records a protocol request for analytics
func (a *ProtocolAnalyticsService) RecordRequest(ctx context.Context, protocol string, method string, duration time.Duration, success bool, errorType string) error <span class="cov10" title="588">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Initialize metrics if not exists
        if _, exists := a.metrics[protocol]; !exists </span><span class="cov5" title="23">{
                a.metrics[protocol] = &amp;AnalyticsProtocolMetrics{
                        Protocol:   protocol,
                        MinLatency: time.Hour, // Initialize to high value
                        LastUsed:   time.Now(),
                }
                a.performanceData[protocol] = &amp;AnalyticsPerformanceStats{
                        Protocol:      protocol,
                        ResponseTimes: make([]time.Duration, 0, 1000),
                        ErrorCounts:   make(map[string]int64),
                        SuccessCounts: make(map[string]int64),
                }
                a.usagePatterns[protocol] = &amp;AnalyticsUsagePattern{
                        Protocol: protocol,
                }
        }</span>

        <span class="cov10" title="588">metrics := a.metrics[protocol]
        perfStats := a.performanceData[protocol]
        usagePattern := a.usagePatterns[protocol]

        // Update basic metrics
        metrics.TotalRequests++
        metrics.LastUsed = time.Now()

        if success </span><span class="cov9" title="485">{
                metrics.SuccessfulRequests++
                perfStats.SuccessCounts[method]++
        }</span> else<span class="cov7" title="103"> {
                metrics.FailedRequests++
                perfStats.ErrorCounts[errorType]++
        }</span>

        // Update latency statistics
        <span class="cov10" title="588">if duration &gt; 0 </span><span class="cov10" title="588">{
                metrics.AverageLatency = time.Duration((int64(metrics.AverageLatency)*int64(metrics.TotalRequests-1) + int64(duration)) / int64(metrics.TotalRequests))

                if duration &gt; metrics.PeakLatency </span><span class="cov5" title="25">{
                        metrics.PeakLatency = duration
                }</span>

                <span class="cov10" title="588">if duration &lt; metrics.MinLatency </span><span class="cov5" title="23">{
                        metrics.MinLatency = duration
                }</span>

                // Keep response times for detailed analysis (limit to last 1000)
                <span class="cov10" title="588">perfStats.ResponseTimes = append(perfStats.ResponseTimes, duration)
                if len(perfStats.ResponseTimes) &gt; 1000 </span><span class="cov0" title="0">{
                        perfStats.ResponseTimes = perfStats.ResponseTimes[1:]
                }</span>
        }

        // Update error rate
        <span class="cov10" title="588">if metrics.TotalRequests &gt; 0 </span><span class="cov10" title="588">{
                metrics.ErrorRate = float64(metrics.FailedRequests) / float64(metrics.TotalRequests)
        }</span>

        // Update usage patterns
        <span class="cov10" title="588">now := time.Now()
        hour := now.Hour()
        day := int(now.Weekday())
        month := int(now.Month()) - 1

        usagePattern.HourlyUsage[hour]++
        usagePattern.DailyUsage[day]++
        usagePattern.MonthlyUsage[month]++

        // Update throughput (requests per second over last minute)
        // This is a simplified calculation - in production you'd want more sophisticated tracking
        metrics.Throughput = float64(metrics.TotalRequests) / time.Since(metrics.LastUsed).Seconds()

        a.logger.WithFields(logrus.Fields{
                "protocol": protocol,
                "method":   method,
                "duration": duration,
                "success":  success,
        }).Debug("Recorded protocol request")

        return nil</span>
}

// GetProtocolMetrics returns metrics for a specific protocol
func (a *ProtocolAnalyticsService) GetProtocolMetrics(protocol string) (*AnalyticsProtocolMetrics, error) <span class="cov4" title="13">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        metrics, exists := a.metrics[protocol]
        if !exists </span><span class="cov2" title="4">{
                return nil, fmt.Errorf("no metrics found for protocol: %s", protocol)
        }</span>

        // Return a copy to avoid race conditions
        <span class="cov4" title="9">metricsCopy := *metrics
        return &amp;metricsCopy, nil</span>
}

// GetAllProtocolMetrics returns metrics for all protocols
func (a *ProtocolAnalyticsService) GetAllProtocolMetrics() map[string]*AnalyticsProtocolMetrics <span class="cov1" title="1">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        result := make(map[string]*AnalyticsProtocolMetrics)
        for protocol, metrics := range a.metrics </span><span class="cov2" title="3">{
                metricsCopy := *metrics
                result[protocol] = &amp;metricsCopy
        }</span>

        <span class="cov1" title="1">return result</span>
}

// GetPerformanceStats returns detailed performance statistics
func (a *ProtocolAnalyticsService) GetPerformanceStats(protocol string) (*AnalyticsPerformanceStats, error) <span class="cov3" title="6">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        stats, exists := a.performanceData[protocol]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no performance stats found for protocol: %s", protocol)
        }</span>

        // Return a copy
        <span class="cov3" title="5">statsCopy := *stats
        statsCopy.ResponseTimes = make([]time.Duration, len(stats.ResponseTimes))
        copy(statsCopy.ResponseTimes, stats.ResponseTimes)

        statsCopy.ErrorCounts = make(map[string]int64)
        for k, v := range stats.ErrorCounts </span><span class="cov1" title="2">{
                statsCopy.ErrorCounts[k] = v
        }</span>

        <span class="cov3" title="5">statsCopy.SuccessCounts = make(map[string]int64)
        for k, v := range stats.SuccessCounts </span><span class="cov3" title="5">{
                statsCopy.SuccessCounts[k] = v
        }</span>

        <span class="cov3" title="5">return &amp;statsCopy, nil</span>
}

// GetUsagePatterns returns usage patterns for a protocol
func (a *ProtocolAnalyticsService) GetUsagePatterns(protocol string) (*AnalyticsUsagePattern, error) <span class="cov2" title="3">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        pattern, exists := a.usagePatterns[protocol]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no usage patterns found for protocol: %s", protocol)
        }</span>

        // Return a copy
        <span class="cov1" title="2">patternCopy := *pattern
        patternCopy.PeakHours = make([]int, len(pattern.PeakHours))
        copy(patternCopy.PeakHours, pattern.PeakHours)

        patternCopy.PeakDays = make([]time.Weekday, len(pattern.PeakDays))
        copy(patternCopy.PeakDays, pattern.PeakDays)

        return &amp;patternCopy, nil</span>
}

// AnalyzePerformance provides performance analysis and recommendations
func (a *ProtocolAnalyticsService) AnalyzePerformance(protocol string) (*PerformanceAnalysis, error) <span class="cov3" title="5">{
        metrics, err := a.GetProtocolMetrics(protocol)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="4">perfStats, err := a.GetPerformanceStats(protocol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="4">analysis := &amp;PerformanceAnalysis{
                Protocol:          protocol,
                OverallHealth:     "healthy",
                Bottlenecks:       []string{},
                Recommendations:   []string{},
                OptimizationScore: 100,
        }

        // Analyze error rate
        if metrics.ErrorRate &gt; 0.1 </span><span class="cov1" title="1">{
                analysis.Bottlenecks = append(analysis.Bottlenecks, "High error rate")
                analysis.Recommendations = append(analysis.Recommendations, "Investigate error patterns and improve error handling")
                analysis.OptimizationScore -= 20
                analysis.OverallHealth = "degraded"
        }</span>

        // Analyze latency
        <span class="cov2" title="4">if metrics.AverageLatency &gt; 5*time.Second </span><span class="cov1" title="2">{
                analysis.Bottlenecks = append(analysis.Bottlenecks, "High average latency")
                analysis.Recommendations = append(analysis.Recommendations, "Consider implementing caching or optimizing request processing")
                analysis.OptimizationScore -= 15
        }</span>

        <span class="cov2" title="4">if metrics.PeakLatency &gt; 30*time.Second </span><span class="cov1" title="1">{
                analysis.Bottlenecks = append(analysis.Bottlenecks, "Extreme latency spikes")
                analysis.Recommendations = append(analysis.Recommendations, "Implement circuit breakers and request timeouts")
                analysis.OptimizationScore -= 25
                analysis.OverallHealth = "critical"
        }</span>

        // Analyze throughput
        <span class="cov2" title="4">if metrics.Throughput &lt; 10 </span><span class="cov0" title="0">{
                analysis.Recommendations = append(analysis.Recommendations, "Consider implementing connection pooling and request batching")
                analysis.OptimizationScore -= 10
        }</span>

        // Check for error patterns
        <span class="cov2" title="4">if len(perfStats.ErrorCounts) &gt; 0 </span><span class="cov1" title="1">{
                analysis.Recommendations = append(analysis.Recommendations, "Review error distribution and implement targeted fixes")
        }</span>

        // Ensure score doesn't go below 0
        <span class="cov2" title="4">if analysis.OptimizationScore &lt; 0 </span><span class="cov0" title="0">{
                analysis.OptimizationScore = 0
        }</span>

        <span class="cov2" title="4">return analysis, nil</span>
}

// PerformanceAnalysis represents the result of performance analysis
type PerformanceAnalysis struct {
        Protocol          string
        OverallHealth     string
        Bottlenecks       []string
        Recommendations   []string
        OptimizationScore int // 0-100
}

// GetTopProtocols returns the most used protocols
func (a *ProtocolAnalyticsService) GetTopProtocols(limit int) []*AnalyticsProtocolMetrics <span class="cov2" title="3">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        var protocols []*AnalyticsProtocolMetrics
        for _, metrics := range a.metrics </span><span class="cov3" title="8">{
                metricsCopy := *metrics
                protocols = append(protocols, &amp;metricsCopy)
        }</span>

        // Sort by total requests (descending)
        <span class="cov2" title="3">sort.Slice(protocols, func(i, j int) bool </span><span class="cov3" title="5">{
                return protocols[i].TotalRequests &gt; protocols[j].TotalRequests
        }</span>)

        <span class="cov2" title="3">if len(protocols) &gt; limit </span><span class="cov1" title="1">{
                protocols = protocols[:limit]
        }</span>

        <span class="cov2" title="3">return protocols</span>
}

// GenerateUsageReport generates a comprehensive usage report
func (a *ProtocolAnalyticsService) GenerateUsageReport() *UsageReport <span class="cov1" title="1">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        report := &amp;UsageReport{
                GeneratedAt:     time.Now(),
                TotalProtocols:  len(a.metrics),
                ProtocolMetrics: make(map[string]*AnalyticsProtocolMetrics),
                TopProtocols:    make([]*AnalyticsProtocolMetrics, 0),
                Summary:         &amp;UsageSummary{},
        }

        totalRequests := int64(0)
        totalErrors := int64(0)
        totalLatency := time.Duration(0)

        for protocol, metrics := range a.metrics </span><span class="cov1" title="2">{
                metricsCopy := *metrics
                report.ProtocolMetrics[protocol] = &amp;metricsCopy

                totalRequests += metrics.TotalRequests
                totalErrors += metrics.FailedRequests
                totalLatency += metrics.AverageLatency
        }</span>

        <span class="cov1" title="1">report.Summary.TotalRequests = totalRequests
        report.Summary.TotalErrors = totalErrors
        report.Summary.AverageLatency = totalLatency / time.Duration(len(a.metrics))

        // Get top 5 protocols
        report.TopProtocols = a.GetTopProtocols(5)

        return report</span>
}

// UsageReport represents a comprehensive usage report
type UsageReport struct {
        GeneratedAt     time.Time
        TotalProtocols  int
        ProtocolMetrics map[string]*AnalyticsProtocolMetrics
        TopProtocols    []*AnalyticsProtocolMetrics
        Summary         *UsageSummary
}

// UsageSummary represents summary statistics
type UsageSummary struct {
        TotalRequests  int64
        TotalErrors    int64
        AverageLatency time.Duration
        ErrorRate      float64
}

// UpdateConnectionCount updates the active connection count for a protocol
func (a *ProtocolAnalyticsService) UpdateConnectionCount(protocol string, count int32) <span class="cov1" title="2">{
        a.mu.Lock()
        defer a.mu.Unlock()

        if metrics, exists := a.metrics[protocol]; exists </span><span class="cov1" title="1">{
                metrics.ActiveConnections = count
        }</span>
}

// CleanOldData removes old analytics data beyond retention period
func (a *ProtocolAnalyticsService) CleanOldData() error <span class="cov1" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        for protocol, metrics := range a.metrics </span><span class="cov1" title="1">{
                if time.Since(metrics.LastUsed) &gt; a.retentionPeriod </span><span class="cov1" title="1">{
                        delete(a.metrics, protocol)
                        delete(a.performanceData, protocol)
                        delete(a.usagePatterns, protocol)

                        a.logger.WithField("protocol", protocol).Info("Cleaned old analytics data")
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// GetHealthStatus returns overall health status of protocol ecosystem
func (a *ProtocolAnalyticsService) GetHealthStatus() *AnalyticsHealthStatus <span class="cov1" title="2">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        status := &amp;AnalyticsHealthStatus{
                OverallStatus:    "healthy",
                ProtocolStatuses: make(map[string]string),
                Alerts:           []string{},
                LastUpdated:      time.Now(),
        }

        totalErrorRate := 0.0
        protocolCount := 0

        for protocol, metrics := range a.metrics </span><span class="cov2" title="3">{
                protocolCount++

                // Determine protocol health
                protocolStatus := "healthy"
                if metrics.ErrorRate &gt; 0.1 </span><span class="cov1" title="1">{
                        protocolStatus = "degraded"
                        status.Alerts = append(status.Alerts, fmt.Sprintf("%s has high error rate: %.2f%%", protocol, metrics.ErrorRate*100))
                }</span>
                <span class="cov2" title="3">if metrics.AverageLatency &gt; 10*time.Second </span><span class="cov0" title="0">{
                        protocolStatus = "critical"
                        status.Alerts = append(status.Alerts, fmt.Sprintf("%s has high latency: %v", protocol, metrics.AverageLatency))
                }</span>

                <span class="cov2" title="3">status.ProtocolStatuses[protocol] = protocolStatus
                totalErrorRate += metrics.ErrorRate</span>
        }

        // Determine overall status
        <span class="cov1" title="2">if protocolCount &gt; 0 </span><span class="cov1" title="2">{
                avgErrorRate := totalErrorRate / float64(protocolCount)
                if avgErrorRate &gt; 0.05 </span><span class="cov1" title="1">{
                        status.OverallStatus = "degraded"
                }</span>
                <span class="cov1" title="2">if avgErrorRate &gt; 0.15 </span><span class="cov1" title="1">{
                        status.OverallStatus = "critical"
                }</span>
        }

        <span class="cov1" title="2">return status</span>
}

// AnalyticsHealthStatus represents the health status of the protocol ecosystem
type AnalyticsHealthStatus struct {
        OverallStatus    string
        ProtocolStatuses map[string]string
        Alerts           []string
        LastUpdated      time.Time
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolCache provides advanced caching for protocol operations
type ProtocolCache struct {
        mu           sync.RWMutex
        cache        map[string]*CacheEntry
        invalidators map[string][]CacheInvalidator
        maxSize      int
        ttl          time.Duration
        log          *logrus.Logger
        stopCh       chan struct{}
        stopped      bool
}

// CacheEntry represents a cached item with metadata
type CacheEntry struct {
        Key        string
        Data       interface{}
        Tags       []string
        CreatedAt  time.Time
        AccessedAt time.Time
        TTL        time.Duration
        Hits       int
        Size       int
}

// CacheInvalidator defines invalidation rules
type CacheInvalidator struct {
        Pattern string
        Tags    []string
        TTL     time.Duration
}

// CacheStats represents cache statistics
type CacheStats struct {
        TotalEntries int
        TotalSize    int
        HitRate      float64
        MissRate     float64
        Evictions    int
        TotalHits    int
        TotalMisses  int
}

// NewProtocolCache creates a new protocol-aware cache
func NewProtocolCache(maxSize int, ttl time.Duration, logger *logrus.Logger) *ProtocolCache <span class="cov4" title="19">{
        cache := &amp;ProtocolCache{
                cache:        make(map[string]*CacheEntry),
                invalidators: make(map[string][]CacheInvalidator),
                maxSize:      maxSize,
                ttl:          ttl,
                log:          logger,
                stopCh:       make(chan struct{}),
                stopped:      false,
        }

        // Start cleanup goroutine
        go cache.cleanupRoutine()

        return cache
}</span>

// Stop stops the cleanup goroutine gracefully
func (c *ProtocolCache) Stop() <span class="cov4" title="20">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.stopped </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="19">c.stopped = true
        close(c.stopCh)
        c.log.Info("Protocol cache stopped")</span>
}

// Get retrieves an item from cache
func (c *ProtocolCache) Get(ctx context.Context, key string) (interface{}, bool, error) <span class="cov4" title="23">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov3" title="6">{
                return nil, false, nil
        }</span>

        // Check TTL
        <span class="cov4" title="17">if time.Since(entry.CreatedAt) &gt; entry.TTL </span><span class="cov1" title="1">{
                go c.evict(key) // Async eviction
                return nil, false, nil
        }</span>

        // Update access time and hit count
        <span class="cov4" title="16">entry.AccessedAt = time.Now()
        entry.Hits++

        c.log.WithFields(logrus.Fields{
                "key":  key,
                "hits": entry.Hits,
                "size": entry.Size,
        }).Debug("Cache hit")

        return entry.Data, true, nil</span>
}

// Set stores an item in cache with tags
func (c *ProtocolCache) Set(ctx context.Context, key string, data interface{}, tags []string, ttl time.Duration) error <span class="cov5" title="28">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Calculate data size
        size := c.calculateSize(data)

        // Check if we need to evict entries
        for len(c.cache) &gt;= c.maxSize </span><span class="cov1" title="1">{
                c.evictLRU()
        }</span>

        // Use default TTL if not specified
        <span class="cov5" title="28">if ttl == 0 </span><span class="cov4" title="22">{
                ttl = c.ttl
        }</span>

        <span class="cov5" title="28">entry := &amp;CacheEntry{
                Key:        key,
                Data:       data,
                Tags:       tags,
                CreatedAt:  time.Now(),
                AccessedAt: time.Now(),
                TTL:        ttl,
                Hits:       0,
                Size:       size,
        }

        c.cache[key] = entry

        c.log.WithFields(logrus.Fields{
                "key":  key,
                "tags": tags,
                "size": size,
                "ttl":  ttl,
        }).Debug("Cache set")

        return nil</span>
}

// Delete removes an item from cache
func (c *ProtocolCache) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, key)
        c.log.WithField("key", key).Debug("Cache delete")

        return nil
}</span>

// InvalidateByTags invalidates cache entries by tags
func (c *ProtocolCache) InvalidateByTags(ctx context.Context, tags []string) error <span class="cov1" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        invalidated := 0
        for key, entry := range c.cache </span><span class="cov2" title="4">{
                if c.hasMatchingTags(entry.Tags, tags) </span><span class="cov1" title="2">{
                        delete(c.cache, key)
                        invalidated++
                }</span>
        }

        <span class="cov1" title="2">c.log.WithFields(logrus.Fields{
                "tags":        tags,
                "invalidated": invalidated,
        }).Info("Cache invalidation by tags")

        return nil</span>
}

// InvalidateByPattern invalidates cache entries matching a pattern
func (c *ProtocolCache) InvalidateByPattern(ctx context.Context, pattern string) error <span class="cov2" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        invalidated := 0
        for key := range c.cache </span><span class="cov3" title="6">{
                if c.matchesPattern(key, pattern) </span><span class="cov2" title="4">{
                        delete(c.cache, key)
                        invalidated++
                }</span>
        }

        <span class="cov2" title="3">c.log.WithFields(logrus.Fields{
                "pattern":     pattern,
                "invalidated": invalidated,
        }).Info("Cache invalidation by pattern")

        return nil</span>
}

// Clear clears all cache entries
func (c *ProtocolCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        count := len(c.cache)
        c.cache = make(map[string]*CacheEntry)

        c.log.WithField("entries", count).Info("Cache cleared")

        return nil
}</span>

// GetStats returns cache statistics
func (c *ProtocolCache) GetStats() CacheStats <span class="cov2" title="5">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        totalHits := 0
        totalMisses := 0
        totalSize := 0

        for _, entry := range c.cache </span><span class="cov2" title="5">{
                totalHits += entry.Hits
                totalSize += entry.Size
        }</span>

        <span class="cov2" title="5">totalRequests := totalHits + totalMisses
        hitRate := float64(0)
        if totalRequests &gt; 0 </span><span class="cov1" title="2">{
                hitRate = float64(totalHits) / float64(totalRequests)
        }</span>

        <span class="cov2" title="5">return CacheStats{
                TotalEntries: len(c.cache),
                TotalSize:    totalSize,
                HitRate:      hitRate,
                MissRate:     1.0 - hitRate,
                TotalHits:    totalHits,
                TotalMisses:  totalMisses,
        }</span>
}

// SetInvalidator sets an invalidation rule
func (c *ProtocolCache) SetInvalidator(key string, invalidator CacheInvalidator) <span class="cov1" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.invalidators[key] = append(c.invalidators[key], invalidator)
}</span>

// RemoveInvalidator removes an invalidation rule
func (c *ProtocolCache) RemoveInvalidator(key string) <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.invalidators, key)
}</span>

// Warmup pre-populates cache with common data
func (c *ProtocolCache) Warmup(ctx context.Context, data map[string]interface{}) error <span class="cov1" title="1">{
        for key, value := range data </span><span class="cov1" title="2">{
                tags := []string{"warmup"}
                if err := c.Set(ctx, key, value, tags, c.ttl); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to warmup cache entry %s: %w", key, err)
                }</span>
        }

        <span class="cov1" title="1">c.log.WithField("entries", len(data)).Info("Cache warmup completed")
        return nil</span>
}

// Private methods

func (c *ProtocolCache) cleanupRoutine() <span class="cov4" title="19">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov4" title="19">{
                select </span>{
                case &lt;-c.stopCh:<span class="cov4" title="19">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.cleanupExpired()</span>
                }
        }
}

func (c *ProtocolCache) cleanupExpired() <span class="cov2" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        expired := 0
        for key, entry := range c.cache </span><span class="cov2" title="4">{
                if time.Since(entry.CreatedAt) &gt; entry.TTL </span><span class="cov1" title="1">{
                        delete(c.cache, key)
                        expired++
                }</span>
        }

        <span class="cov2" title="3">if expired &gt; 0 </span><span class="cov1" title="1">{
                c.log.WithField("expired", expired).Debug("Cache cleanup completed")
        }</span>
}

func (c *ProtocolCache) evictLRU() <span class="cov1" title="1">{
        var oldestKey string
        var oldestTime time.Time
        first := true

        for key, entry := range c.cache </span><span class="cov2" title="3">{
                if first || entry.AccessedAt.Before(oldestTime) </span><span class="cov1" title="2">{
                        oldestKey = key
                        oldestTime = entry.AccessedAt
                        first = false
                }</span>
        }

        <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                delete(c.cache, oldestKey)
                c.log.WithField("key", oldestKey).Debug("Cache LRU eviction")
        }</span>
}

func (c *ProtocolCache) evict(key string) <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.cache, key)
}</span>

func (c *ProtocolCache) hasMatchingTags(entryTags, queryTags []string) bool <span class="cov2" title="4">{
        if len(queryTags) == 0 </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov2" title="3">for _, queryTag := range queryTags </span><span class="cov2" title="3">{
                for _, entryTag := range entryTags </span><span class="cov2" title="4">{
                        if entryTag == queryTag </span><span class="cov1" title="2">{
                                return true
                        }</span>
                }
        }

        <span class="cov1" title="1">return false</span>
}

func (c *ProtocolCache) matchesPattern(key, pattern string) bool <span class="cov3" title="6">{
        // Empty pattern matches nothing
        if pattern == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        // Full wildcard matches everything
        <span class="cov2" title="5">if pattern == "*" </span><span class="cov1" title="2">{
                return true
        }</span>

        // Use glob-style pattern matching with wildcards
        <span class="cov2" title="3">return matchGlob(pattern, key)</span>
}

// matchGlob performs glob-style pattern matching supporting:
// - '*' matches any sequence of characters (including empty)
// - '?' matches exactly one character
// - All other characters must match exactly
func matchGlob(pattern, text string) bool <span class="cov4" title="27">{
        // dp[i][j] represents whether pattern[0:i] matches text[0:j]
        // Using bottom-up dynamic programming for efficiency

        pLen := len(pattern)
        tLen := len(text)

        // Create DP table
        // dp[i][j] = true if pattern[0:i] matches text[0:j]
        dp := make([][]bool, pLen+1)
        for i := range dp </span><span class="cov7" title="184">{
                dp[i] = make([]bool, tLen+1)
        }</span>

        // Empty pattern matches empty text
        <span class="cov4" title="27">dp[0][0] = true

        // Handle patterns that start with * (can match empty string)
        for i := 1; i &lt;= pLen; i++ </span><span class="cov7" title="157">{
                if pattern[i-1] == '*' </span><span class="cov4" title="25">{
                        dp[i][0] = dp[i-1][0]
                }</span>
        }

        // Fill the DP table
        <span class="cov4" title="27">for i := 1; i &lt;= pLen; i++ </span><span class="cov7" title="157">{
                for j := 1; j &lt;= tLen; j++ </span><span class="cov10" title="1743">{
                        p := pattern[i-1]
                        t := text[j-1]

                        switch p </span>{
                        case '*':<span class="cov7" title="259">
                                // '*' can match:
                                // - Zero characters: dp[i-1][j] (skip the *)
                                // - One or more characters: dp[i][j-1] (consume one char from text, keep *)
                                dp[i][j] = dp[i-1][j] || dp[i][j-1]</span>
                        case '?':<span class="cov4" title="23">
                                // '?' matches exactly one character
                                dp[i][j] = dp[i-1][j-1]</span>
                        default:<span class="cov9" title="1461">
                                // Regular character must match exactly
                                dp[i][j] = dp[i-1][j-1] &amp;&amp; p == t</span>
                        }
                }
        }

        <span class="cov4" title="27">return dp[pLen][tLen]</span>
}

func (c *ProtocolCache) calculateSize(data interface{}) int <span class="cov5" title="33">{
        // Rough size estimation
        switch v := data.(type) </span>{
        case string:<span class="cov4" title="26">
                return len(v)</span>
        case []byte:<span class="cov1" title="1">
                return len(v)</span>
        case map[string]interface{}:<span class="cov2" title="4">
                jsonData, _ := json.Marshal(v)
                return len(jsonData)</span>
        case []interface{}:<span class="cov1" title="1">
                jsonData, _ := json.Marshal(v)
                return len(jsonData)</span>
        default:<span class="cov1" title="1">
                jsonData, _ := json.Marshal(v)
                return len(jsonData)</span>
        }
}

// GenerateCacheKey generates a consistent cache key
func GenerateCacheKey(protocol, operation string, params map[string]interface{}) string <span class="cov3" title="7">{
        // Create a deterministic key from parameters
        paramStr := ""
        if params != nil </span><span class="cov2" title="4">{
                paramBytes, _ := json.Marshal(params)
                paramStr = string(paramBytes)
        }</span>

        <span class="cov3" title="7">key := fmt.Sprintf("%s:%s:%s", protocol, operation, paramStr)
        return fmt.Sprintf("%x", md5.Sum([]byte(key)))</span>
}

// Protocol-aware cache keys
const (
        CacheKeyMCPServer = "mcp:server:%s"
        CacheKeyMCPTools  = "mcp:tools:%s"
        CacheKeyMCPResult = "mcp:result:%s:%s"
        CacheKeyLSPServer = "lsp:server:%s"
        CacheKeyLSPResult = "lsp:result:%s:%s"
        CacheKeyACPServer = "acp:server:%s"
        CacheKeyACPResult = "acp:result:%s:%s"
        CacheKeyEmbedding = "embedding:%s"
)

// Cache tags for invalidation
const (
        CacheTagMCP       = "mcp"
        CacheTagLSP       = "lsp"
        CacheTagACP       = "acp"
        CacheTagEmbedding = "embedding"
        CacheTagServer    = "server"
        CacheTagTools     = "tools"
        CacheTagResults   = "results"
)
</pre>
		
		<pre class="file" id="file26" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// ProtocolCacheManager handles caching for MCP, LSP, ACP, and Embedding protocols
type ProtocolCacheManager struct {
        repo  *database.ModelMetadataRepository
        cache *ProtocolCache
        log   *logrus.Logger
}

// ProtocolCacheEntry represents a cached protocol response
type ProtocolCacheEntry struct {
        Key       string      `json:"key"`
        Data      interface{} `json:"data"`
        ExpiresAt *time.Time  `json:"expiresAt"`
        Protocol  string      `json:"protocol"` // "mcp", "lsp", "acp", "embedding"
        Timestamp time.Time   `json:"timestamp"`
}

// NewProtocolCacheManager creates a new protocol cache manager
func NewProtocolCacheManager(repo *database.ModelMetadataRepository, cache *ProtocolCache, log *logrus.Logger) *ProtocolCacheManager <span class="cov0" title="0">{
        return &amp;ProtocolCacheManager{
                repo:  repo,
                cache: cache,
                log:   log,
        }
}</span>

// Set stores data in cache with TTL
func (p *ProtocolCacheManager) Set(ctx context.Context, protocol, key string, data interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        p.log.WithFields(logrus.Fields{
                "protocol": protocol,
                "key":      key,
                "ttl":      ttl,
        }).Debug("Setting protocol cache entry")

        cacheKey := fmt.Sprintf("protocol_cache_%s_%s", protocol, key)
        tags := []string{protocol, CacheTagResults}

        if err := p.cache.Set(ctx, cacheKey, data, tags, ttl); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get retrieves data from cache
func (p *ProtocolCacheManager) Get(ctx context.Context, protocol, key string) (interface{}, bool, error) <span class="cov0" title="0">{
        p.log.WithFields(logrus.Fields{
                "protocol": protocol,
                "key":      key,
        }).Debug("Getting protocol cache entry")

        cacheKey := fmt.Sprintf("protocol_cache_%s_%s", protocol, key)
        data, found, err := p.cache.Get(ctx, cacheKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("failed to get cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">return data, found, nil</span>
}

// Delete removes a cache entry
func (p *ProtocolCacheManager) Delete(ctx context.Context, protocol, key string) error <span class="cov0" title="0">{
        p.log.WithFields(logrus.Fields{
                "protocol": protocol,
                "key":      key,
        }).Debug("Deleting protocol cache entry")

        cacheKey := fmt.Sprintf("protocol_cache_%s_%s", protocol, key)
        if err := p.cache.Delete(ctx, cacheKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupExpired removes expired cache entries
// Note: ProtocolCache already runs automatic cleanup in background,
// this method is for manual/on-demand cleanup
func (p *ProtocolCacheManager) CleanupExpired(ctx context.Context) error <span class="cov0" title="0">{
        p.log.Info("Cleaning up expired protocol cache entries")

        // Clear all protocol entries - the ProtocolCache handles TTL automatically
        // For a full cleanup, we invalidate by pattern
        for _, protocol := range []string{CacheTagMCP, CacheTagLSP, CacheTagACP, CacheTagEmbedding} </span><span class="cov0" title="0">{
                if err := p.cache.InvalidateByTags(ctx, []string{protocol}); err != nil </span><span class="cov0" title="0">{
                        p.log.WithError(err).Warnf("Failed to cleanup %s cache entries", protocol)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetCacheStats returns statistics about cache usage
func (p *ProtocolCacheManager) GetCacheStats(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        cacheStats := p.cache.GetStats()

        stats := map[string]interface{}{
                "cacheType":    "protocol",
                "timestamp":    time.Now(),
                "totalEntries": cacheStats.TotalEntries,
                "totalSize":    cacheStats.TotalSize,
                "hitRate":      cacheStats.HitRate,
                "missRate":     cacheStats.MissRate,
                "totalHits":    cacheStats.TotalHits,
                "totalMisses":  cacheStats.TotalMisses,
                "evictions":    cacheStats.Evictions,
        }

        p.log.WithFields(logrus.Fields{
                "entries": cacheStats.TotalEntries,
                "hitRate": cacheStats.HitRate,
        }).Debug("Protocol cache statistics retrieved")

        return stats, nil
}</span>

// InvalidateByPattern removes cache entries matching a pattern
func (p *ProtocolCacheManager) InvalidateByPattern(ctx context.Context, protocol, pattern string) error <span class="cov0" title="0">{
        p.log.WithFields(logrus.Fields{
                "protocol": protocol,
                "pattern":  pattern,
        }).Info("Invalidating cache entries by pattern")

        // Build the full pattern with protocol prefix
        fullPattern := fmt.Sprintf("protocol_cache_%s_%s", protocol, pattern)
        if err := p.cache.InvalidateByPattern(ctx, fullPattern); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to invalidate cache by pattern: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetWithInvalidation marks cache entries as invalid (for cache invalidation)
func (p *ProtocolCacheManager) SetWithInvalidation(ctx context.Context, protocol, key string, data interface{}, ttl time.Duration, invalidateOn string) error <span class="cov0" title="0">{
        err := p.Set(ctx, protocol, key, data, ttl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Mark related cache entries for invalidation
        <span class="cov0" title="0">for _, pattern := range strings.Split(invalidateOn, ",") </span><span class="cov0" title="0">{
                err = p.Delete(ctx, protocol, pattern)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.WithError(err).Error("Failed to mark cache entries for invalidation")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// WarmupCache warms up cache with frequently accessed data
func (p *ProtocolCacheManager) WarmupCache(ctx context.Context) error <span class="cov0" title="0">{
        p.log.Info("Warming up protocol cache with frequently accessed data")

        // Pre-populate with empty protocol registries for faster first access
        warmupData := map[string]interface{}{
                "protocol_cache_mcp_registry":       map[string]interface{}{"initialized": true},
                "protocol_cache_lsp_registry":       map[string]interface{}{"initialized": true},
                "protocol_cache_acp_registry":       map[string]interface{}{"initialized": true},
                "protocol_cache_embedding_registry": map[string]interface{}{"initialized": true},
        }

        if err := p.cache.Warmup(ctx, warmupData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to warmup cache: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocolsWithCache returns cache entries grouped by protocol
func (p *ProtocolCacheManager) GetProtocolsWithCache(ctx context.Context) (map[string]map[string]interface{}, error) <span class="cov0" title="0">{
        p.log.Info("Retrieving cache entries grouped by protocol")

        result := make(map[string]map[string]interface{})

        // Check each protocol for cached data
        protocols := []string{CacheTagMCP, CacheTagLSP, CacheTagACP, CacheTagEmbedding}
        for _, protocol := range protocols </span><span class="cov0" title="0">{
                registryKey := fmt.Sprintf("protocol_cache_%s_registry", protocol)
                data, found, err := p.cache.Get(ctx, registryKey)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.WithError(err).Warnf("Failed to get %s registry", protocol)
                        continue</span>
                }
                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                        if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                result[protocol] = dataMap
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// MonitorCacheHealth monitors cache health and performance
func (p *ProtocolCacheManager) MonitorCacheHealth(ctx context.Context) error <span class="cov0" title="0">{
        p.log.Info("Monitoring protocol cache health")

        stats := p.cache.GetStats()

        // Log health metrics
        p.log.WithFields(logrus.Fields{
                "entries":  stats.TotalEntries,
                "size":     stats.TotalSize,
                "hitRate":  stats.HitRate,
                "missRate": stats.MissRate,
        }).Info("Cache health status")

        // Check for concerning metrics
        if stats.HitRate &lt; 0.5 &amp;&amp; stats.TotalHits &gt; 100 </span><span class="cov0" title="0">{
                p.log.Warn("Cache hit rate is below 50% - consider increasing cache size or TTL")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/gorilla/websocket"
        "github.com/sirupsen/logrus"
)

// ACPClient implements a real Agent Client Protocol client
type ACPClient struct {
        agents    map[string]*ACPAgentConnection
        messageID int
        mu        sync.RWMutex
        logger    *logrus.Logger
}

// ACPAgentConnection represents a live connection to an ACP agent
type ACPAgentConnection struct {
        ID           string
        Name         string
        Transport    ACPTransport
        Capabilities map[string]interface{}
        Connected    bool
        LastUsed     time.Time
}

// ACPTransport defines the interface for ACP communication
type ACPTransport interface {
        Send(ctx context.Context, message interface{}) error
        Receive(ctx context.Context) (interface{}, error)
        Close() error
        IsConnected() bool
}

// WebSocketACPTransport implements ACP transport over WebSocket
type WebSocketACPTransport struct {
        conn      *websocket.Conn
        connected bool
        mu        sync.Mutex
}

// HTTPACPTransport implements ACP transport over HTTP
type HTTPACPTransport struct {
        baseURL    string
        httpClient *http.Client
        connected  bool
        mu         sync.Mutex
}

// ACPMessage represents a JSON-RPC message for ACP
type ACPMessage struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id,omitempty"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
        Result  interface{} `json:"result,omitempty"`
        Error   *ACPError   `json:"error,omitempty"`
}

// ACPError represents an ACP error
type ACPError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// ACP request/response types
type ACPInitializeRequest struct {
        ProtocolVersion string                 `json:"protocolVersion"`
        Capabilities    map[string]interface{} `json:"capabilities"`
        ClientInfo      map[string]string      `json:"clientInfo"`
}

type ACPInitializeResult struct {
        ProtocolVersion string                 `json:"protocolVersion"`
        Capabilities    map[string]interface{} `json:"capabilities"`
        ServerInfo      map[string]string      `json:"serverInfo"`
        Instructions    string                 `json:"instructions,omitempty"`
}

// ACP operation types
type ACPActionRequest struct {
        Action  string                 `json:"action"`
        Params  map[string]interface{} `json:"params,omitempty"`
        Context map[string]interface{} `json:"context,omitempty"`
}

type ACPActionResult struct {
        Success bool        `json:"success"`
        Result  interface{} `json:"result,omitempty"`
        Error   string      `json:"error,omitempty"`
}

// NewACPClient creates a new ACP client
func NewACPClient(logger *logrus.Logger) *ACPClient <span class="cov10" title="34">{
        return &amp;ACPClient{
                agents:    make(map[string]*ACPAgentConnection),
                messageID: 1,
                logger:    logger,
        }
}</span>

// ConnectAgent connects to an ACP agent
func (c *ACPClient) ConnectAgent(ctx context.Context, agentID, name, endpoint string) error <span class="cov3" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, exists := c.agents[agentID]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("ACP agent %s already connected", agentID)
        }</span>

        // Create transport based on endpoint
        <span class="cov2" title="2">var transport ACPTransport
        var err error

        if strings.HasPrefix(endpoint, "ws://") || strings.HasPrefix(endpoint, "wss://") </span><span class="cov0" title="0">{
                transport, err = c.createWebSocketTransport(endpoint)
        }</span> else<span class="cov2" title="2"> if strings.HasPrefix(endpoint, "http://") || strings.HasPrefix(endpoint, "https://") </span><span class="cov0" title="0">{
                transport, err = c.createHTTPTransport(endpoint)
        }</span> else<span class="cov2" title="2"> {
                return fmt.Errorf("unsupported endpoint protocol: %s", endpoint)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create transport: %w", err)
        }</span>

        <span class="cov0" title="0">connection := &amp;ACPAgentConnection{
                ID:           agentID,
                Name:         name,
                Transport:    transport,
                Connected:    true,
                LastUsed:     time.Now(),
                Capabilities: make(map[string]interface{}),
        }

        // Initialize the agent
        if err := c.initializeAgent(ctx, connection); err != nil </span><span class="cov0" title="0">{
                transport.Close()
                return fmt.Errorf("failed to initialize ACP agent: %w", err)
        }</span>

        <span class="cov0" title="0">c.agents[agentID] = connection
        c.logger.WithFields(logrus.Fields{
                "agentId":  agentID,
                "endpoint": endpoint,
        }).Info("Connected to ACP agent")

        return nil</span>
}

// DisconnectAgent disconnects from an ACP agent
func (c *ACPClient) DisconnectAgent(agentID string) error <span class="cov4" title="4">{
        c.mu.Lock()
        defer c.mu.Unlock()

        connection, exists := c.agents[agentID]
        if !exists </span><span class="cov2" title="2">{
                return fmt.Errorf("ACP agent %s not connected", agentID)
        }</span>

        <span class="cov2" title="2">if err := connection.Transport.Close(); err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).Warn("Error closing ACP transport")
        }</span>

        <span class="cov2" title="2">delete(c.agents, agentID)

        c.logger.WithField("agentId", agentID).Info("Disconnected from ACP agent")
        return nil</span>
}

// ExecuteAction executes an action on an ACP agent
func (c *ACPClient) ExecuteAction(ctx context.Context, agentID, action string, params map[string]interface{}) (*ACPActionResult, error) <span class="cov5" title="6">{
        c.mu.RLock()
        connection, exists := c.agents[agentID]
        c.mu.RUnlock()

        if !exists </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("ACP agent %s not connected", agentID)
        }</span>

        <span class="cov4" title="4">if !connection.Connected </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ACP agent %s not connected", agentID)
        }</span>

        <span class="cov4" title="4">actionRequest := ACPActionRequest{
                Action: action,
                Params: params,
                Context: map[string]interface{}{
                        "timestamp": time.Now().Unix(),
                        "requestId": fmt.Sprintf("req-%d", c.nextMessageID()),
                },
        }

        actionReq := ACPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "execute_action",
                Params:  actionRequest,
        }

        if err := connection.Transport.Send(ctx, actionReq); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send action request: %w", err)
        }</span>

        <span class="cov4" title="4">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive action response: %w", err)
        }</span>

        <span class="cov4" title="4">var actionMsg ACPMessage
        if err := c.unmarshalMessage(response, &amp;actionMsg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal action response: %w", err)
        }</span>

        <span class="cov4" title="4">result := &amp;ACPActionResult{
                Success: true,
        }

        if actionMsg.Error != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = actionMsg.Error.Message
        }</span> else<span class="cov4" title="4"> {
                result.Result = actionMsg.Result
        }</span>

        <span class="cov4" title="4">connection.LastUsed = time.Now()
        return result, nil</span>
}

// GetAgentCapabilities returns capabilities for an agent
func (c *ACPClient) GetAgentCapabilities(agentID string) (map[string]interface{}, error) <span class="cov4" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        connection, exists := c.agents[agentID]
        if !exists </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("ACP agent %s not connected", agentID)
        }</span>

        <span class="cov2" title="2">return connection.Capabilities, nil</span>
}

// ListAgents returns all connected ACP agents
func (c *ACPClient) ListAgents() []*ACPAgentConnection <span class="cov4" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        agents := make([]*ACPAgentConnection, 0, len(c.agents))
        for _, agent := range c.agents </span><span class="cov4" title="4">{
                agents = append(agents, agent)
        }</span>

        <span class="cov4" title="4">return agents</span>
}

// HealthCheck performs health checks on all connected agents
func (c *ACPClient) HealthCheck(ctx context.Context) map[string]bool <span class="cov4" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        results := make(map[string]bool)
        for agentID, connection := range c.agents </span><span class="cov2" title="2">{
                results[agentID] = connection.Transport.IsConnected()
        }</span>

        <span class="cov4" title="4">return results</span>
}

// GetAgentStatus returns detailed status for an agent
func (c *ACPClient) GetAgentStatus(ctx context.Context, agentID string) (map[string]interface{}, error) <span class="cov4" title="4">{
        c.mu.RLock()
        connection, exists := c.agents[agentID]
        c.mu.RUnlock()

        if !exists </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("ACP agent %s not found", agentID)
        }</span>

        <span class="cov2" title="2">status := map[string]interface{}{
                "id":           connection.ID,
                "name":         connection.Name,
                "connected":    connection.Connected,
                "lastUsed":     connection.LastUsed,
                "capabilities": connection.Capabilities,
        }

        // Add transport-specific status
        if wsTransport, ok := connection.Transport.(*WebSocketACPTransport); ok </span><span class="cov0" title="0">{
                status["transport"] = "websocket"
                status["connected"] = wsTransport.IsConnected()
        }</span> else<span class="cov2" title="2"> if httpTransport, ok := connection.Transport.(*HTTPACPTransport); ok </span><span class="cov0" title="0">{
                status["transport"] = "http"
                status["connected"] = httpTransport.IsConnected()
        }</span>

        <span class="cov2" title="2">return status, nil</span>
}

// BroadcastAction broadcasts an action to all connected agents
func (c *ACPClient) BroadcastAction(ctx context.Context, action string, params map[string]interface{}) map[string]*ACPActionResult <span class="cov3" title="3">{
        c.mu.RLock()
        agents := make(map[string]*ACPAgentConnection)
        for k, v := range c.agents </span><span class="cov2" title="2">{
                agents[k] = v
        }</span>
        <span class="cov3" title="3">c.mu.RUnlock()

        results := make(map[string]*ACPActionResult)

        for agentID, agent := range agents </span><span class="cov2" title="2">{
                if !agent.Connected </span><span class="cov0" title="0">{
                        results[agentID] = &amp;ACPActionResult{
                                Success: false,
                                Error:   "agent not connected",
                        }
                        continue</span>
                }

                <span class="cov2" title="2">result, err := c.ExecuteAction(ctx, agentID, action, params)
                if err != nil </span><span class="cov0" title="0">{
                        results[agentID] = &amp;ACPActionResult{
                                Success: false,
                                Error:   err.Error(),
                        }
                }</span> else<span class="cov2" title="2"> {
                        results[agentID] = result
                }</span>
        }

        <span class="cov3" title="3">return results</span>
}

// Private methods

func (c *ACPClient) createWebSocketTransport(endpoint string) (ACPTransport, error) <span class="cov0" title="0">{
        u, err := url.Parse(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid endpoint URL: %w", err)
        }</span>

        <span class="cov0" title="0">dialer := websocket.DefaultDialer
        dialer.HandshakeTimeout = 10 * time.Second

        conn, _, err := dialer.Dial(u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to WebSocket: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;WebSocketACPTransport{
                conn:      conn,
                connected: true,
        }, nil</span>
}

func (c *ACPClient) createHTTPTransport(endpoint string) (ACPTransport, error) <span class="cov0" title="0">{
        return &amp;HTTPACPTransport{
                baseURL:    endpoint,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                connected:  true,
        }, nil
}</span>

func (c *ACPClient) initializeAgent(ctx context.Context, connection *ACPAgentConnection) error <span class="cov0" title="0">{
        initRequest := ACPInitializeRequest{
                ProtocolVersion: "1.0.0",
                Capabilities:    map[string]interface{}{},
                ClientInfo: map[string]string{
                        "name":    "superagent",
                        "version": "1.0.0",
                },
        }

        initializeReq := ACPMessage{
                JSONRPC: "2.0",
                ID:      c.nextMessageID(),
                Method:  "initialize",
                Params:  initRequest,
        }

        if err := connection.Transport.Send(ctx, initializeReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send initialize request: %w", err)
        }</span>

        <span class="cov0" title="0">response, err := connection.Transport.Receive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">var initializeMsg ACPMessage
        if err := c.unmarshalMessage(response, &amp;initializeMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">if initializeMsg.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initialize failed: %s", initializeMsg.Error.Message)
        }</span>

        <span class="cov0" title="0">var result ACPInitializeResult
        if err := c.unmarshalResult(initializeMsg.Result, &amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal initialize result: %w", err)
        }</span>

        <span class="cov0" title="0">connection.Capabilities = result.Capabilities

        return nil</span>
}

func (c *ACPClient) nextMessageID() int <span class="cov7" title="11">{
        c.messageID++
        return c.messageID
}</span>

func (c *ACPClient) unmarshalMessage(data interface{}, message *ACPMessage) error <span class="cov5" title="6">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">return json.Unmarshal(jsonData, message)</span>
}

func (c *ACPClient) unmarshalResult(result interface{}, target interface{}) error <span class="cov2" title="2">{
        jsonData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">return json.Unmarshal(jsonData, target)</span>
}

// WebSocketACPTransport implementation

func (t *WebSocketACPTransport) Send(ctx context.Context, message interface{}) error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return fmt.Errorf("transport not connected")
        }</span>

        <span class="cov0" title="0">return t.conn.WriteJSON(message)</span>
}

func (t *WebSocketACPTransport) Receive(ctx context.Context) (interface{}, error) <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transport not connected")
        }</span>

        <span class="cov0" title="0">var message interface{}
        err := t.conn.ReadJSON(&amp;message)
        if err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return nil, err
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func (t *WebSocketACPTransport) Close() error <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.connected = false

        if t.conn != nil </span><span class="cov0" title="0">{
                return t.conn.Close()
        }</span>

        <span class="cov2" title="2">return nil</span>
}

func (t *WebSocketACPTransport) IsConnected() bool <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov2" title="2">{
                return false
        }</span>

        // Simple ping to check connection
        <span class="cov0" title="0">return t.conn != nil</span>
}

// HTTPACPTransport implementation

func (t *HTTPACPTransport) Send(ctx context.Context, message interface{}) error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return fmt.Errorf("transport not connected")
        }</span>

        <span class="cov0" title="0">jsonData, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", t.baseURL+"/rpc", strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := t.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                t.connected = false
                return fmt.Errorf("HTTP request failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t *HTTPACPTransport) Receive(ctx context.Context) (interface{}, error) <span class="cov1" title="1">{
        // HTTP transport is request-response, so this is not applicable
        // In a real implementation, you might use long polling or server-sent events
        return nil, fmt.Errorf("HTTP transport does not support receive")
}</span>

func (t *HTTPACPTransport) Close() error <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.connected = false
        return nil
}</span>

func (t *HTTPACPTransport) IsConnected() bool <span class="cov3" title="3">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if !t.connected </span><span class="cov1" title="1">{
                return false
        }</span>

        // Simple health check
        <span class="cov2" title="2">req, err := http.NewRequest("GET", t.baseURL+"/health", nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="2">resp, err := t.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                t.connected = false
                return false
        }</span>
        <span class="cov2" title="2">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "context"
        "fmt"
        "net"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolDiscovery provides automatic discovery of protocol servers
type ProtocolDiscovery struct {
        discoveredServers map[string]*DiscoveredServer
        discoveryMethods  []DiscoveryMethod
        mu                sync.RWMutex
        logger            *logrus.Logger
        stopChan          chan struct{}
}

// DiscoveredServer represents a discovered protocol server
type DiscoveredServer struct {
        ID           string
        Protocol     string
        Address      string
        Port         int
        Name         string
        Type         string
        Capabilities map[string]interface{}
        LastSeen     time.Time
        Status       ServerStatus
}

// ServerStatus represents the status of a discovered server
type ServerStatus int

const (
        StatusUnknown ServerStatus = iota
        StatusOnline
        StatusOffline
        StatusError
)

// DiscoveryMethod defines an interface for server discovery
type DiscoveryMethod interface {
        Name() string
        Discover(ctx context.Context) ([]*DiscoveredServer, error)
        Start(ctx context.Context) error
        Stop() error
}

// NetworkDiscovery implements network-based discovery (UDP broadcasts, mDNS)
type NetworkDiscovery struct {
        port     int
        protocol string
        services map[string]*DiscoveredServer
        logger   *logrus.Logger
}

// DNSDiscovery implements DNS-based service discovery
type DNSDiscovery struct {
        domain   string
        services map[string]*DiscoveredServer
        logger   *logrus.Logger
}

// ConfigurationDiscovery implements configuration-based discovery
type ConfigurationDiscovery struct {
        config   map[string]interface{}
        services map[string]*DiscoveredServer
        logger   *logrus.Logger
}

// NewProtocolDiscovery creates a new protocol discovery service
func NewProtocolDiscovery(logger *logrus.Logger) *ProtocolDiscovery <span class="cov0" title="0">{
        discovery := &amp;ProtocolDiscovery{
                discoveredServers: make(map[string]*DiscoveredServer),
                discoveryMethods:  []DiscoveryMethod{},
                stopChan:          make(chan struct{}),
                logger:            logger,
        }

        // Add default discovery methods
        discovery.AddDiscoveryMethod(&amp;NetworkDiscovery{
                port:     9999,
                protocol: "udp",
                services: make(map[string]*DiscoveredServer),
                logger:   logger,
        })

        discovery.AddDiscoveryMethod(&amp;DNSDiscovery{
                domain:   "local",
                services: make(map[string]*DiscoveredServer),
                logger:   logger,
        })

        discovery.AddDiscoveryMethod(&amp;ConfigurationDiscovery{
                config:   make(map[string]interface{}),
                services: make(map[string]*DiscoveredServer),
                logger:   logger,
        })

        return discovery
}</span>

// AddDiscoveryMethod adds a discovery method
func (d *ProtocolDiscovery) AddDiscoveryMethod(method DiscoveryMethod) <span class="cov0" title="0">{
        d.discoveryMethods = append(d.discoveryMethods, method)
}</span>

// Start begins the discovery process
func (d *ProtocolDiscovery) Start(ctx context.Context) error <span class="cov0" title="0">{
        d.logger.Info("Starting protocol discovery")

        for _, method := range d.discoveryMethods </span><span class="cov0" title="0">{
                if err := method.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        d.logger.WithError(err).WithField("method", method.Name()).Warn("Failed to start discovery method")
                }</span>
        }

        // Start periodic discovery
        <span class="cov0" title="0">go d.periodicDiscovery()

        return nil</span>
}

// Stop stops the discovery process
func (d *ProtocolDiscovery) Stop() <span class="cov0" title="0">{
        d.logger.Info("Stopping protocol discovery")

        close(d.stopChan)

        for _, method := range d.discoveryMethods </span><span class="cov0" title="0">{
                if err := method.Stop(); err != nil </span><span class="cov0" title="0">{
                        d.logger.WithError(err).WithField("method", method.Name()).Warn("Failed to stop discovery method")
                }</span>
        }
}

// DiscoverServers performs a discovery scan
func (d *ProtocolDiscovery) DiscoverServers(ctx context.Context) error <span class="cov0" title="0">{
        d.logger.Info("Performing protocol server discovery")

        for _, method := range d.discoveryMethods </span><span class="cov0" title="0">{
                servers, err := method.Discover(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.WithError(err).WithField("method", method.Name()).Warn("Discovery method failed")
                        continue</span>
                }

                <span class="cov0" title="0">for _, server := range servers </span><span class="cov0" title="0">{
                        d.addOrUpdateServer(server)
                }</span>
        }

        <span class="cov0" title="0">d.logger.WithField("totalServers", len(d.discoveredServers)).Info("Discovery scan completed")
        return nil</span>
}

// GetDiscoveredServers returns all discovered servers
func (d *ProtocolDiscovery) GetDiscoveredServers() []*DiscoveredServer <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        servers := make([]*DiscoveredServer, 0, len(d.discoveredServers))
        for _, server := range d.discoveredServers </span><span class="cov0" title="0">{
                servers = append(servers, server)
        }</span>

        <span class="cov0" title="0">return servers</span>
}

// GetServersByProtocol returns servers for a specific protocol
func (d *ProtocolDiscovery) GetServersByProtocol(protocol string) []*DiscoveredServer <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        var servers []*DiscoveredServer
        for _, server := range d.discoveredServers </span><span class="cov0" title="0">{
                if server.Protocol == protocol </span><span class="cov0" title="0">{
                        servers = append(servers, server)
                }</span>
        }

        <span class="cov0" title="0">return servers</span>
}

// GetServerByID returns a server by ID
func (d *ProtocolDiscovery) GetServerByID(serverID string) (*DiscoveredServer, error) <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        server, exists := d.discoveredServers[serverID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server %s not found", serverID)
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// RegisterServer manually registers a server
func (d *ProtocolDiscovery) RegisterServer(protocol, address string, port int, name string) error <span class="cov0" title="0">{
        server := &amp;DiscoveredServer{
                ID:           fmt.Sprintf("%s-%s-%d", protocol, address, port),
                Protocol:     protocol,
                Address:      address,
                Port:         port,
                Name:         name,
                Type:         "manual",
                Status:       StatusOnline,
                LastSeen:     time.Now(),
                Capabilities: make(map[string]interface{}),
        }

        d.addOrUpdateServer(server)
        d.logger.WithFields(logrus.Fields{
                "serverId": server.ID,
                "protocol": protocol,
                "address":  address,
                "port":     port,
        }).Info("Server manually registered")

        return nil
}</span>

// UnregisterServer removes a server
func (d *ProtocolDiscovery) UnregisterServer(serverID string) error <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if _, exists := d.discoveredServers[serverID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("server %s not found", serverID)
        }</span>

        <span class="cov0" title="0">delete(d.discoveredServers, serverID)
        d.logger.WithField("serverId", serverID).Info("Server unregistered")

        return nil</span>
}

// HealthCheck performs health checks on discovered servers
func (d *ProtocolDiscovery) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        d.mu.RLock()
        servers := make(map[string]*DiscoveredServer)
        for k, v := range d.discoveredServers </span><span class="cov0" title="0">{
                servers[k] = v
        }</span>
        <span class="cov0" title="0">d.mu.RUnlock()

        for serverID, server := range servers </span><span class="cov0" title="0">{
                status := d.checkServerHealth(ctx, server)
                d.updateServerStatus(serverID, status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Private methods

func (d *ProtocolDiscovery) addOrUpdateServer(server *DiscoveredServer) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        existing, exists := d.discoveredServers[server.ID]
        if exists </span><span class="cov0" title="0">{
                // Update existing server
                existing.LastSeen = time.Now()
                existing.Status = server.Status
                existing.Capabilities = server.Capabilities
        }</span> else<span class="cov0" title="0"> {
                // Add new server
                d.discoveredServers[server.ID] = server
                d.logger.WithFields(logrus.Fields{
                        "serverId": server.ID,
                        "protocol": server.Protocol,
                        "address":  server.Address,
                }).Info("New server discovered")
        }</span>
}

func (d *ProtocolDiscovery) updateServerStatus(serverID string, status ServerStatus) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if server, exists := d.discoveredServers[serverID]; exists </span><span class="cov0" title="0">{
                server.Status = status
                server.LastSeen = time.Now()
        }</span>
}

func (d *ProtocolDiscovery) checkServerHealth(ctx context.Context, server *DiscoveredServer) ServerStatus <span class="cov0" title="0">{
        timeout := 5 * time.Second
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        address := fmt.Sprintf("%s:%d", server.Address, server.Port)

        switch server.Protocol </span>{
        case "mcp":<span class="cov0" title="0">
                // For MCP, try to connect via stdio or network
                conn, err := net.DialTimeout("tcp", address, timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return StatusOffline
                }</span>
                <span class="cov0" title="0">conn.Close()
                return StatusOnline</span>

        case "lsp":<span class="cov0" title="0">
                // LSP servers typically listen on TCP
                conn, err := net.DialTimeout("tcp", address, timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return StatusOffline
                }</span>
                <span class="cov0" title="0">conn.Close()
                return StatusOnline</span>

        case "acp":<span class="cov0" title="0">
                // ACP agents might use WebSocket or HTTP
                // Try TCP connection first
                conn, err := net.DialTimeout("tcp", address, timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return StatusOffline
                }</span>
                <span class="cov0" title="0">conn.Close()
                return StatusOnline</span>

        default:<span class="cov0" title="0">
                return StatusUnknown</span>
        }
}

func (d *ProtocolDiscovery) periodicDiscovery() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.stopChan:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        d.DiscoverServers(ctx)
                        d.HealthCheck(ctx)
                        cancel()</span>
                }
        }
}

// NetworkDiscovery implementation

func (n *NetworkDiscovery) Name() string <span class="cov0" title="0">{
        return "network"
}</span>

func (n *NetworkDiscovery) Discover(ctx context.Context) ([]*DiscoveredServer, error) <span class="cov0" title="0">{
        // UDP broadcast discovery
        addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", n.port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">conn, err := net.ListenUDP("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Send discovery broadcast
        broadcastAddr, _ := net.ResolveUDPAddr("udp", fmt.Sprintf("255.255.255.255:%d", n.port))
        message := []byte("DISCOVER_PROTOCOL_SERVERS")
        conn.WriteToUDP(message, broadcastAddr)

        // Listen for responses with timeout
        conn.SetReadDeadline(time.Now().Add(2 * time.Second))

        var servers []*DiscoveredServer
        buffer := make([]byte, 1024)

        for </span><span class="cov0" title="0">{
                _, remoteAddr, err := conn.ReadFromUDP(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                                break</span> // Timeout, stop listening
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">response := string(buffer)
                if strings.HasPrefix(response, "PROTOCOL_SERVER:") </span><span class="cov0" title="0">{
                        parts := strings.Split(response, ":")
                        if len(parts) &gt;= 4 </span><span class="cov0" title="0">{
                                port, _ := strconv.Atoi(parts[3])
                                server := &amp;DiscoveredServer{
                                        ID:       fmt.Sprintf("net-%s-%s", remoteAddr.IP.String(), parts[1]),
                                        Protocol: parts[1],
                                        Address:  remoteAddr.IP.String(),
                                        Port:     port,
                                        Name:     parts[2],
                                        Type:     "network",
                                        Status:   StatusOnline,
                                        LastSeen: time.Now(),
                                }
                                servers = append(servers, server)
                        }</span>
                }
        }

        <span class="cov0" title="0">return servers, nil</span>
}

func (n *NetworkDiscovery) Start(ctx context.Context) error <span class="cov0" title="0">{
        n.logger.Info("Starting network discovery")
        return nil
}</span>

func (n *NetworkDiscovery) Stop() error <span class="cov0" title="0">{
        n.logger.Info("Stopping network discovery")
        return nil
}</span>

// DNSDiscovery implementation

func (dns *DNSDiscovery) Name() string <span class="cov0" title="0">{
        return "dns"
}</span>

func (dns *DNSDiscovery) Discover(ctx context.Context) ([]*DiscoveredServer, error) <span class="cov0" title="0">{
        var servers []*DiscoveredServer

        // Look for common protocol service names
        serviceNames := []string{
                "_mcp._tcp",
                "_lsp._tcp",
                "_acp._tcp",
                "_protocols._tcp",
        }

        for _, serviceName := range serviceNames </span><span class="cov0" title="0">{
                protocol := strings.TrimSuffix(strings.TrimPrefix(serviceName, "_"), "._tcp")

                // In a real implementation, you would use DNS-SD/mDNS discovery
                // For this demo, we'll simulate finding some services
                if protocol == "mcp" </span><span class="cov0" title="0">{
                        server := &amp;DiscoveredServer{
                                ID:       fmt.Sprintf("dns-mcp-%s", dns.domain),
                                Protocol: "mcp",
                                Address:  "localhost",
                                Port:     3000,
                                Name:     "MCP Server",
                                Type:     "dns",
                                Status:   StatusOnline,
                                LastSeen: time.Now(),
                        }
                        servers = append(servers, server)
                }</span>
        }

        <span class="cov0" title="0">return servers, nil</span>
}

func (dns *DNSDiscovery) Start(ctx context.Context) error <span class="cov0" title="0">{
        dns.logger.Info("Starting DNS discovery")
        return nil
}</span>

func (dns *DNSDiscovery) Stop() error <span class="cov0" title="0">{
        dns.logger.Info("Stopping DNS discovery")
        return nil
}</span>

// ConfigurationDiscovery implementation

func (c *ConfigurationDiscovery) Name() string <span class="cov0" title="0">{
        return "config"
}</span>

func (c *ConfigurationDiscovery) Discover(ctx context.Context) ([]*DiscoveredServer, error) <span class="cov0" title="0">{
        var servers []*DiscoveredServer

        // Read from configuration
        if mcpConfig, ok := c.config["mcp"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if serversConfig, ok := mcpConfig["servers"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, serverConfig := range serversConfig </span><span class="cov0" title="0">{
                                if serverMap, ok := serverConfig.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        server := &amp;DiscoveredServer{
                                                ID:       fmt.Sprintf("config-mcp-%s", serverMap["name"]),
                                                Protocol: "mcp",
                                                Address:  "localhost", // Default
                                                Port:     3000,        // Default
                                                Name:     serverMap["name"].(string),
                                                Type:     "config",
                                                Status:   StatusOnline,
                                                LastSeen: time.Now(),
                                        }
                                        servers = append(servers, server)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return servers, nil</span>
}

func (c *ConfigurationDiscovery) Start(ctx context.Context) error <span class="cov0" title="0">{
        c.logger.Info("Starting configuration discovery")
        return nil
}</span>

func (c *ConfigurationDiscovery) Stop() error <span class="cov0" title="0">{
        c.logger.Info("Stopping configuration discovery")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolMonitor provides performance monitoring and alerting for protocols
type ProtocolMonitor struct {
        mu        sync.RWMutex
        metrics   map[string]*ProtocolMetrics
        alerts    []*AlertRule
        alertChan chan *Alert
        stopChan  chan struct{}
        logger    *logrus.Logger
}

// ProtocolMetrics represents performance metrics for a protocol
type ProtocolMetrics struct {
        Protocol           string
        TotalRequests      int64
        SuccessfulRequests int64
        FailedRequests     int64
        AverageLatency     time.Duration
        MinLatency         time.Duration
        MaxLatency         time.Duration
        Throughput         float64 // requests per second
        LastRequestTime    time.Time
        ErrorRate          float64
        ActiveConnections  int
        CacheHitRate       float64
        ResourceUsage      SystemResourceUsage
}

// SystemResourceUsage represents system resource utilization
type SystemResourceUsage struct {
        MemoryMB     float64
        CPUPercent   float64
        NetworkBytes int64
        DiskUsageMB  float64
}

// AlertRule defines alerting conditions
type AlertRule struct {
        ID          string
        Name        string
        Description string
        Protocol    string
        Condition   AlertCondition
        Threshold   float64
        Severity    AlertSeverity
        Cooldown    time.Duration
        LastAlert   time.Time
        Enabled     bool
}

// AlertCondition defines when to trigger an alert
type AlertCondition int

const (
        ConditionGreaterThan AlertCondition = iota
        ConditionLessThan
        ConditionEqual
        ConditionRateAbove
        ConditionErrorRateAbove
        ConditionLatencyAbove
)

// AlertSeverity defines alert severity levels
type AlertSeverity int

const (
        SeverityInfo AlertSeverity = iota
        SeverityWarning
        SeverityError
        SeverityCritical
)

// Alert represents an alert event
type Alert struct {
        ID         string
        RuleID     string
        Protocol   string
        Message    string
        Severity   AlertSeverity
        Value      float64
        Threshold  float64
        Timestamp  time.Time
        Resolved   bool
        ResolvedAt *time.Time
}

// NewProtocolMonitor creates a new protocol monitor
func NewProtocolMonitor(logger *logrus.Logger) *ProtocolMonitor <span class="cov10" title="26">{
        monitor := &amp;ProtocolMonitor{
                metrics:   make(map[string]*ProtocolMetrics),
                alerts:    []*AlertRule{},
                alertChan: make(chan *Alert, 100),
                stopChan:  make(chan struct{}),
                logger:    logger,
        }

        // Start monitoring goroutines
        go monitor.metricsCollector()
        go monitor.alertChecker()

        return monitor
}</span>

// RecordRequest records a protocol request
func (m *ProtocolMonitor) RecordRequest(ctx context.Context, protocol string, duration time.Duration, success bool, errorMsg string) <span class="cov8" title="17">{
        m.mu.Lock()
        defer m.mu.Unlock()

        metrics, exists := m.metrics[protocol]
        if !exists </span><span class="cov8" title="15">{
                metrics = &amp;ProtocolMetrics{
                        Protocol:   protocol,
                        MinLatency: time.Hour, // Initialize to a large value
                }
                m.metrics[protocol] = metrics
        }</span>

        <span class="cov8" title="17">metrics.TotalRequests++
        metrics.LastRequestTime = time.Now()

        if success </span><span class="cov8" title="13">{
                metrics.SuccessfulRequests++
        }</span> else<span class="cov4" title="4"> {
                metrics.FailedRequests++
        }</span>

        // Update latency statistics
        <span class="cov8" title="17">metrics.AverageLatency = time.Duration(
                (int64(metrics.AverageLatency)*int64(metrics.TotalRequests-1) + int64(duration)) / int64(metrics.TotalRequests),
        )

        if duration &lt; metrics.MinLatency </span><span class="cov8" title="15">{
                metrics.MinLatency = duration
        }</span>
        <span class="cov8" title="17">if duration &gt; metrics.MaxLatency </span><span class="cov8" title="16">{
                metrics.MaxLatency = duration
        }</span>

        // Calculate error rate
        <span class="cov8" title="17">if metrics.TotalRequests &gt; 0 </span><span class="cov8" title="17">{
                metrics.ErrorRate = float64(metrics.FailedRequests) / float64(metrics.TotalRequests)
        }</span>

        // Calculate throughput (requests per second over last minute)
        // This is a simplified calculation
        <span class="cov8" title="17">metrics.Throughput = float64(metrics.TotalRequests) / 60.0

        m.logger.WithFields(logrus.Fields{
                "protocol": protocol,
                "duration": duration,
                "success":  success,
                "latency":  duration,
        }).Debug("Protocol request recorded")</span>
}

// UpdateConnections updates connection count for a protocol
func (m *ProtocolMonitor) UpdateConnections(protocol string, count int) <span class="cov2" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        metrics, exists := m.metrics[protocol]
        if !exists </span><span class="cov1" title="1">{
                metrics = &amp;ProtocolMetrics{Protocol: protocol}
                m.metrics[protocol] = metrics
        }</span>

        <span class="cov2" title="2">metrics.ActiveConnections = count</span>
}

// UpdateCacheStats updates cache statistics
func (m *ProtocolMonitor) UpdateCacheStats(protocol string, hitRate float64) <span class="cov2" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        metrics, exists := m.metrics[protocol]
        if !exists </span><span class="cov2" title="2">{
                metrics = &amp;ProtocolMetrics{Protocol: protocol}
                m.metrics[protocol] = metrics
        }</span>

        <span class="cov2" title="2">metrics.CacheHitRate = hitRate</span>
}

// UpdateResourceUsage updates resource usage statistics
func (m *ProtocolMonitor) UpdateResourceUsage(protocol string, usage SystemResourceUsage) <span class="cov2" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        metrics, exists := m.metrics[protocol]
        if !exists </span><span class="cov1" title="1">{
                metrics = &amp;ProtocolMetrics{Protocol: protocol}
                m.metrics[protocol] = metrics
        }</span>

        <span class="cov2" title="2">metrics.ResourceUsage = usage</span>
}

// GetMetrics returns metrics for a protocol
func (m *ProtocolMonitor) GetMetrics(protocol string) (*ProtocolMetrics, error) <span class="cov7" title="11">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        metrics, exists := m.metrics[protocol]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no metrics found for protocol: %s", protocol)
        }</span>

        // Return a copy to avoid race conditions
        <span class="cov7" title="10">return &amp;ProtocolMetrics{
                Protocol:           metrics.Protocol,
                TotalRequests:      metrics.TotalRequests,
                SuccessfulRequests: metrics.SuccessfulRequests,
                FailedRequests:     metrics.FailedRequests,
                AverageLatency:     metrics.AverageLatency,
                MinLatency:         metrics.MinLatency,
                MaxLatency:         metrics.MaxLatency,
                Throughput:         metrics.Throughput,
                LastRequestTime:    metrics.LastRequestTime,
                ErrorRate:          metrics.ErrorRate,
                ActiveConnections:  metrics.ActiveConnections,
                CacheHitRate:       metrics.CacheHitRate,
                ResourceUsage:      metrics.ResourceUsage,
        }, nil</span>
}

// GetAllMetrics returns metrics for all protocols
func (m *ProtocolMonitor) GetAllMetrics() map[string]*ProtocolMetrics <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make(map[string]*ProtocolMetrics)
        for protocol, metrics := range m.metrics </span><span class="cov4" title="3">{
                result[protocol] = &amp;ProtocolMetrics{
                        Protocol:           metrics.Protocol,
                        TotalRequests:      metrics.TotalRequests,
                        SuccessfulRequests: metrics.SuccessfulRequests,
                        FailedRequests:     metrics.FailedRequests,
                        AverageLatency:     metrics.AverageLatency,
                        MinLatency:         metrics.MinLatency,
                        MaxLatency:         metrics.MaxLatency,
                        Throughput:         metrics.Throughput,
                        LastRequestTime:    metrics.LastRequestTime,
                        ErrorRate:          metrics.ErrorRate,
                        ActiveConnections:  metrics.ActiveConnections,
                        CacheHitRate:       metrics.CacheHitRate,
                        ResourceUsage:      metrics.ResourceUsage,
                }
        }</span>

        <span class="cov1" title="1">return result</span>
}

// AddAlertRule adds an alert rule
func (m *ProtocolMonitor) AddAlertRule(rule *AlertRule) <span class="cov2" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.alerts = append(m.alerts, rule)
        m.logger.WithFields(logrus.Fields{
                "ruleId":   rule.ID,
                "name":     rule.Name,
                "protocol": rule.Protocol,
        }).Info("Alert rule added")
}</span>

// RemoveAlertRule removes an alert rule
func (m *ProtocolMonitor) RemoveAlertRule(ruleID string) <span class="cov2" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for i, rule := range m.alerts </span><span class="cov1" title="1">{
                if rule.ID == ruleID </span><span class="cov1" title="1">{
                        m.alerts = append(m.alerts[:i], m.alerts[i+1:]...)
                        m.logger.WithField("ruleId", ruleID).Info("Alert rule removed")
                        return
                }</span>
        }
}

// GetAlerts returns recent alerts
func (m *ProtocolMonitor) GetAlerts(limit int) []*Alert <span class="cov1" title="1">{
        // For simplicity, return alerts from the channel
        // In a real implementation, you'd store alerts in a database
        alerts := make([]*Alert, 0, limit)

        // Non-blocking read from channel
        for i := 0; i &lt; limit; i++ </span><span class="cov7" title="10">{
                select </span>{
                case alert := &lt;-m.alertChan:<span class="cov0" title="0">
                        alerts = append(alerts, alert)</span>
                default:<span class="cov7" title="10">
                        break</span>
                }
        }

        <span class="cov1" title="1">return alerts</span>
}

// Alerts returns a channel for receiving alerts
func (m *ProtocolMonitor) Alerts() &lt;-chan *Alert <span class="cov1" title="1">{
        return m.alertChan
}</span>

// Stop stops the monitor
func (m *ProtocolMonitor) Stop() <span class="cov7" title="12">{
        close(m.stopChan)
}</span>

// Private methods

func (m *ProtocolMonitor) metricsCollector() <span class="cov10" title="26">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov10" title="26">{
                select </span>{
                case &lt;-m.stopChan:<span class="cov7" title="12">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.collectSystemMetrics()</span>
                }
        }
}

func (m *ProtocolMonitor) collectSystemMetrics() <span class="cov0" title="0">{
        // Collect system-level metrics
        // This is a placeholder - in a real implementation, you'd collect
        // actual system metrics like memory usage, CPU, etc.

        for protocol := range m.metrics </span><span class="cov0" title="0">{
                usage := SystemResourceUsage{
                        MemoryMB:   100.0, // Placeholder
                        CPUPercent: 5.0,   // Placeholder
                }
                m.UpdateResourceUsage(protocol, usage)
        }</span>
}

func (m *ProtocolMonitor) alertChecker() <span class="cov10" title="26">{
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov10" title="26">{
                select </span>{
                case &lt;-m.stopChan:<span class="cov7" title="12">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.checkAlerts()</span>
                }
        }
}

func (m *ProtocolMonitor) checkAlerts() <span class="cov0" title="0">{
        m.mu.RLock()
        alerts := make([]*AlertRule, len(m.alerts))
        copy(alerts, m.alerts)
        m.mu.RUnlock()

        for _, rule := range alerts </span><span class="cov0" title="0">{
                if !rule.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check cooldown
                <span class="cov0" title="0">if time.Since(rule.LastAlert) &lt; rule.Cooldown </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">metrics, exists := m.metrics[rule.Protocol]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var currentValue float64
                var triggered bool

                switch rule.Condition </span>{
                case ConditionErrorRateAbove:<span class="cov0" title="0">
                        currentValue = metrics.ErrorRate
                        triggered = currentValue &gt; rule.Threshold</span>
                case ConditionLatencyAbove:<span class="cov0" title="0">
                        currentValue = float64(metrics.AverageLatency.Nanoseconds()) / 1e6 // Convert to milliseconds
                        triggered = currentValue &gt; rule.Threshold</span>
                case ConditionGreaterThan:<span class="cov0" title="0">
                        currentValue = float64(metrics.TotalRequests)
                        triggered = currentValue &gt; rule.Threshold</span>
                }

                <span class="cov0" title="0">if triggered </span><span class="cov0" title="0">{
                        alert := &amp;Alert{
                                ID:        fmt.Sprintf("%s-%d", rule.ID, time.Now().Unix()),
                                RuleID:    rule.ID,
                                Protocol:  rule.Protocol,
                                Message:   fmt.Sprintf("%s: %s (%.2f &gt; %.2f)", rule.Name, rule.Description, currentValue, rule.Threshold),
                                Severity:  rule.Severity,
                                Value:     currentValue,
                                Threshold: rule.Threshold,
                                Timestamp: time.Now(),
                        }

                        select </span>{
                        case m.alertChan &lt;- alert:<span class="cov0" title="0">
                                rule.LastAlert = time.Now()
                                m.logger.WithFields(logrus.Fields{
                                        "alertId":   alert.ID,
                                        "ruleId":    rule.ID,
                                        "protocol":  rule.Protocol,
                                        "value":     currentValue,
                                        "threshold": rule.Threshold,
                                }).Warn("Alert triggered")</span>
                        default:<span class="cov0" title="0">
                                m.logger.Warn("Alert channel full, dropping alert")</span>
                        }
                }
        }
}

// Predefined alert rules

// NewErrorRateAlertRule creates an alert rule for high error rates
func NewErrorRateAlertRule(protocol string, threshold float64) *AlertRule <span class="cov1" title="1">{
        return &amp;AlertRule{
                ID:          fmt.Sprintf("error-rate-%s", protocol),
                Name:        fmt.Sprintf("%s Error Rate Alert", protocol),
                Description: "Error rate exceeded threshold",
                Protocol:    protocol,
                Condition:   ConditionErrorRateAbove,
                Threshold:   threshold,
                Severity:    SeverityError,
                Cooldown:    5 * time.Minute,
                Enabled:     true,
        }
}</span>

// NewLatencyAlertRule creates an alert rule for high latency
func NewLatencyAlertRule(protocol string, thresholdMs float64) *AlertRule <span class="cov1" title="1">{
        return &amp;AlertRule{
                ID:          fmt.Sprintf("latency-%s", protocol),
                Name:        fmt.Sprintf("%s Latency Alert", protocol),
                Description: "Average latency exceeded threshold",
                Protocol:    protocol,
                Condition:   ConditionLatencyAbove,
                Threshold:   thresholdMs,
                Severity:    SeverityWarning,
                Cooldown:    2 * time.Minute,
                Enabled:     true,
        }
}</span>

// NewHighTrafficAlertRule creates an alert rule for high traffic
func NewHighTrafficAlertRule(protocol string, threshold int64) *AlertRule <span class="cov1" title="1">{
        return &amp;AlertRule{
                ID:          fmt.Sprintf("traffic-%s", protocol),
                Name:        fmt.Sprintf("%s High Traffic Alert", protocol),
                Description: "Request volume exceeded threshold",
                Protocol:    protocol,
                Condition:   ConditionGreaterThan,
                Threshold:   float64(threshold),
                Severity:    SeverityInfo,
                Cooldown:    10 * time.Minute,
                Enabled:     true,
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "fmt"
        "plugin"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolPluginSystem manages third-party protocol plugins
type ProtocolPluginSystem struct {
        mu            sync.RWMutex
        plugins       map[string]*ProtocolPlugin
        pluginDir     string
        loadedPlugins map[string]*loadedProtocolPlugin
        logger        *logrus.Logger
}

// ProtocolPlugin represents a protocol plugin
type ProtocolPlugin struct {
        ID          string
        Name        string
        Version     string
        Description string
        Protocol    string
        Author      string
        License     string
        Homepage    string
        Metadata    map[string]interface{}
}

// loadedProtocolPlugin represents a loaded plugin instance
type loadedProtocolPlugin struct {
        plugin   *plugin.Plugin
        instance ProtocolPluginExecutor
        config   map[string]interface{}
        active   bool
}

// ProtocolPluginExecutor interface for executing plugin operations
type ProtocolPluginExecutor interface {
        Execute(ctx context.Context, operation string, params map[string]interface{}) (interface{}, error)
        GetCapabilities() map[string]interface{}
        ValidateConfig(config map[string]interface{}) error
        Initialize(ctx context.Context) error
        Shutdown(ctx context.Context) error
}

// NewProtocolPluginSystem creates a new protocol plugin system
func NewProtocolPluginSystem(pluginDir string, logger *logrus.Logger) *ProtocolPluginSystem <span class="cov9" title="12">{
        return &amp;ProtocolPluginSystem{
                plugins:       make(map[string]*ProtocolPlugin),
                pluginDir:     pluginDir,
                loadedPlugins: make(map[string]*loadedProtocolPlugin),
                logger:        logger,
        }
}</span>

// LoadPlugin loads a plugin from the specified path
func (ps *ProtocolPluginSystem) LoadPlugin(path string) error <span class="cov5" title="4">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        // Load the plugin
        p, err := plugin.Open(path)
        if err != nil </span><span class="cov5" title="4">{
                return fmt.Errorf("failed to open plugin %s: %w", path, err)
        }</span>

        // Look for plugin metadata symbol
        <span class="cov0" title="0">metaSym, err := p.Lookup("PluginMetadata")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin %s missing PluginMetadata symbol: %w", path, err)
        }</span>

        <span class="cov0" title="0">metadata, ok := metaSym.(*ProtocolPlugin)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin %s PluginMetadata has wrong type", path)
        }</span>

        // Check if plugin already loaded
        <span class="cov0" title="0">if _, exists := ps.plugins[metadata.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin %s already loaded", metadata.ID)
        }</span>

        // Look for plugin instance symbol
        <span class="cov0" title="0">instanceSym, err := p.Lookup("NewPlugin")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin %s missing NewPlugin symbol: %w", path, err)
        }</span>

        <span class="cov0" title="0">newPluginFunc, ok := instanceSym.(func(map[string]interface{}) (ProtocolPluginExecutor, error))
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin %s NewPlugin has wrong signature", path)
        }</span>

        // Create plugin instance with default config
        <span class="cov0" title="0">instance, err := newPluginFunc(make(map[string]interface{}))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create plugin instance: %w", err)
        }</span>

        <span class="cov0" title="0">ps.plugins[metadata.ID] = metadata
        ps.loadedPlugins[metadata.ID] = &amp;loadedProtocolPlugin{
                plugin:   p,
                instance: instance,
                config:   make(map[string]interface{}),
                active:   true,
        }

        ps.logger.WithFields(logrus.Fields{
                "pluginId": metadata.ID,
                "name":     metadata.Name,
                "version":  metadata.Version,
                "protocol": metadata.Protocol,
        }).Info("Protocol plugin loaded successfully")

        return nil</span>
}

// UnloadPlugin unloads a plugin
func (ps *ProtocolPluginSystem) UnloadPlugin(pluginID string) error <span class="cov1" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        loaded, exists := ps.loadedPlugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("plugin %s not loaded", pluginID)
        }</span>

        // Shutdown plugin
        <span class="cov0" title="0">if err := loaded.instance.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                ps.logger.WithError(err).Warn("Error shutting down plugin")
        }</span>

        <span class="cov0" title="0">delete(ps.plugins, pluginID)
        delete(ps.loadedPlugins, pluginID)

        ps.logger.WithField("pluginId", pluginID).Info("Protocol plugin unloaded")
        return nil</span>
}

// GetPlugin returns plugin metadata
func (ps *ProtocolPluginSystem) GetPlugin(pluginID string) (*ProtocolPlugin, error) <span class="cov1" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()

        plugin, exists := ps.plugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("plugin %s not found", pluginID)
        }</span>

        <span class="cov0" title="0">return plugin, nil</span>
}

// ListPlugins returns all loaded plugins
func (ps *ProtocolPluginSystem) ListPlugins() []*ProtocolPlugin <span class="cov1" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()

        plugins := make([]*ProtocolPlugin, 0, len(ps.plugins))
        for _, plugin := range ps.plugins </span><span class="cov0" title="0">{
                plugins = append(plugins, plugin)
        }</span>

        <span class="cov1" title="1">return plugins</span>
}

// EnablePlugin enables a loaded plugin
func (ps *ProtocolPluginSystem) EnablePlugin(pluginID string) error <span class="cov1" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        loaded, exists := ps.loadedPlugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("plugin %s not loaded", pluginID)
        }</span>

        <span class="cov0" title="0">if !loaded.active </span><span class="cov0" title="0">{
                if err := loaded.instance.Initialize(context.Background()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize plugin: %w", err)
                }</span>
                <span class="cov0" title="0">loaded.active = true</span>
        }

        <span class="cov0" title="0">ps.logger.WithField("pluginId", pluginID).Info("Protocol plugin enabled")
        return nil</span>
}

// DisablePlugin disables a loaded plugin
func (ps *ProtocolPluginSystem) DisablePlugin(pluginID string) error <span class="cov1" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        loaded, exists := ps.loadedPlugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("plugin %s not loaded", pluginID)
        }</span>

        <span class="cov0" title="0">if loaded.active </span><span class="cov0" title="0">{
                if err := loaded.instance.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        ps.logger.WithError(err).Warn("Error shutting down plugin")
                }</span>
                <span class="cov0" title="0">loaded.active = false</span>
        }

        <span class="cov0" title="0">ps.logger.WithField("pluginId", pluginID).Info("Protocol plugin disabled")
        return nil</span>
}

// ExecutePluginOperation executes an operation on a plugin
func (ps *ProtocolPluginSystem) ExecutePluginOperation(ctx context.Context, pluginID, operation string, params map[string]interface{}) (interface{}, error) <span class="cov1" title="1">{
        ps.mu.RLock()
        loaded, exists := ps.loadedPlugins[pluginID]
        ps.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("plugin %s not loaded", pluginID)
        }</span>

        <span class="cov0" title="0">if !loaded.active </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("plugin %s is disabled", pluginID)
        }</span>

        <span class="cov0" title="0">result, err := loaded.instance.Execute(ctx, operation, params)
        if err != nil </span><span class="cov0" title="0">{
                ps.logger.WithError(err).WithFields(logrus.Fields{
                        "pluginId":  pluginID,
                        "operation": operation,
                }).Error("Protocol plugin operation failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// GetPluginCapabilities returns plugin capabilities
func (ps *ProtocolPluginSystem) GetPluginCapabilities(pluginID string) (map[string]interface{}, error) <span class="cov1" title="1">{
        ps.mu.RLock()
        loaded, exists := ps.loadedPlugins[pluginID]
        ps.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("plugin %s not loaded", pluginID)
        }</span>

        <span class="cov0" title="0">return loaded.instance.GetCapabilities(), nil</span>
}

// ConfigurePlugin configures a plugin
func (ps *ProtocolPluginSystem) ConfigurePlugin(pluginID string, config map[string]interface{}) error <span class="cov1" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        loaded, exists := ps.loadedPlugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("plugin %s not loaded", pluginID)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := loaded.instance.ValidateConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid plugin configuration: %w", err)
        }</span>

        // Update configuration
        <span class="cov0" title="0">loaded.config = config

        ps.logger.WithField("pluginId", pluginID).Info("Protocol plugin configured")
        return nil</span>
}

// DiscoverPlugins discovers available plugins in the plugin directory
func (ps *ProtocolPluginSystem) DiscoverPlugins() ([]string, error) <span class="cov3" title="2">{
        // In a real implementation, this would scan the plugin directory
        // for .so files and validate them

        // For demo, return some example plugin paths
        return []string{
                ps.pluginDir + "/mcp-custom.so",
                ps.pluginDir + "/lsp-advanced.so",
                ps.pluginDir + "/acp-specialized.so",
        }, nil
}</span>

// AutoLoadPlugins automatically loads all discovered plugins
func (ps *ProtocolPluginSystem) AutoLoadPlugins() error <span class="cov1" title="1">{
        plugins, err := ps.DiscoverPlugins()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to discover plugins: %w", err)
        }</span>

        <span class="cov1" title="1">loadedCount := 0
        for _, pluginPath := range plugins </span><span class="cov4" title="3">{
                if err := ps.LoadPlugin(pluginPath); err != nil </span><span class="cov4" title="3">{
                        ps.logger.WithError(err).WithField("path", pluginPath).Warn("Failed to load protocol plugin")
                }</span> else<span class="cov0" title="0"> {
                        loadedCount++
                }</span>
        }

        <span class="cov1" title="1">ps.logger.WithField("count", loadedCount).Info("Protocol plugins auto-loaded")
        return nil</span>
}

// Protocol Plugin Marketplace and Registry

// ProtocolPluginRegistry manages plugin marketplace and registration
type ProtocolPluginRegistry struct {
        mu      sync.RWMutex
        plugins map[string]*RegistryProtocolPlugin
        logger  *logrus.Logger
}

// RegistryProtocolPlugin represents a plugin in the marketplace registry
type RegistryProtocolPlugin struct {
        ID          string
        Name        string
        Version     string
        Description string
        Protocol    string
        Author      string
        License     string
        Downloads   int
        Rating      float64
        Tags        []string
        Homepage    string
        Repository  string
        CreatedAt   time.Time
        UpdatedAt   time.Time
        Metadata    map[string]interface{}
}

// NewProtocolPluginRegistry creates a new plugin registry
func NewProtocolPluginRegistry(logger *logrus.Logger) *ProtocolPluginRegistry <span class="cov6" title="6">{
        return &amp;ProtocolPluginRegistry{
                plugins: make(map[string]*RegistryProtocolPlugin),
                logger:  logger,
        }
}</span>

// RegisterPlugin registers a plugin in the marketplace registry
func (pr *ProtocolPluginRegistry) RegisterPlugin(plugin *RegistryProtocolPlugin) error <span class="cov9" title="13">{
        pr.mu.Lock()
        defer pr.mu.Unlock()

        if _, exists := pr.plugins[plugin.ID]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("plugin %s already registered", plugin.ID)
        }</span>

        <span class="cov9" title="12">plugin.CreatedAt = time.Now()
        plugin.UpdatedAt = time.Now()

        pr.plugins[plugin.ID] = plugin

        pr.logger.WithFields(logrus.Fields{
                "pluginId": plugin.ID,
                "name":     plugin.Name,
                "version":  plugin.Version,
        }).Info("Plugin registered in marketplace")

        return nil</span>
}

// GetPlugin returns a plugin from the registry
func (pr *ProtocolPluginRegistry) GetPlugin(pluginID string) (*RegistryProtocolPlugin, error) <span class="cov6" title="5">{
        pr.mu.RLock()
        defer pr.mu.RUnlock()

        plugin, exists := pr.plugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("plugin %s not found", pluginID)
        }</span>

        <span class="cov5" title="4">return plugin, nil</span>
}

// SearchPlugins searches for plugins by query
func (pr *ProtocolPluginRegistry) SearchPlugins(query string, protocol string, tags []string) []*RegistryProtocolPlugin <span class="cov6" title="5">{
        pr.mu.RLock()
        defer pr.mu.RUnlock()

        var results []*RegistryProtocolPlugin

        for _, plugin := range pr.plugins </span><span class="cov10" title="15">{
                // Check protocol filter
                if protocol != "" &amp;&amp; plugin.Protocol != protocol </span><span class="cov5" title="4">{
                        continue</span>
                }

                // Check tags filter
                <span class="cov8" title="11">if len(tags) &gt; 0 </span><span class="cov4" title="3">{
                        hasMatchingTag := false
                        for _, searchTag := range tags </span><span class="cov4" title="3">{
                                for _, pluginTag := range plugin.Tags </span><span class="cov6" title="5">{
                                        if pluginTag == searchTag </span><span class="cov1" title="1">{
                                                hasMatchingTag = true
                                                break</span>
                                        }
                                }
                                <span class="cov4" title="3">if hasMatchingTag </span><span class="cov1" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov4" title="3">if !hasMatchingTag </span><span class="cov3" title="2">{
                                continue</span>
                        }
                }

                // Check query
                <span class="cov8" title="9">if query != "" </span><span class="cov4" title="3">{
                        if !strings.Contains(strings.ToLower(plugin.Name), strings.ToLower(query)) &amp;&amp;
                                !strings.Contains(strings.ToLower(plugin.Description), strings.ToLower(query)) </span><span class="cov3" title="2">{
                                continue</span>
                        }
                }

                <span class="cov7" title="7">results = append(results, plugin)</span>
        }

        <span class="cov6" title="5">return results</span>
}

// UpdatePluginStats updates download and rating stats
func (pr *ProtocolPluginRegistry) UpdatePluginStats(pluginID string, downloads int, rating float64) error <span class="cov4" title="3">{
        pr.mu.Lock()
        defer pr.mu.Unlock()

        plugin, exists := pr.plugins[pluginID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("plugin %s not found", pluginID)
        }</span>

        <span class="cov3" title="2">if downloads &gt;= 0 </span><span class="cov1" title="1">{
                plugin.Downloads = downloads
        }</span>
        <span class="cov3" title="2">if rating &gt;= 0 &amp;&amp; rating &lt;= 5.0 </span><span class="cov3" title="2">{
                plugin.Rating = rating
        }</span>

        <span class="cov3" title="2">plugin.UpdatedAt = time.Now()

        return nil</span>
}

// ListPopularPlugins returns most popular plugins
func (pr *ProtocolPluginRegistry) ListPopularPlugins(limit int) []*RegistryProtocolPlugin <span class="cov3" title="2">{
        pr.mu.RLock()
        defer pr.mu.RUnlock()

        var plugins []*RegistryProtocolPlugin
        for _, plugin := range pr.plugins </span><span class="cov8" title="10">{
                plugins = append(plugins, plugin)
        }</span>

        // Sort by downloads (simplified - would use proper sorting)
        <span class="cov3" title="2">if len(plugins) &gt; limit </span><span class="cov1" title="1">{
                plugins = plugins[:limit]
        }</span>

        <span class="cov3" title="2">return plugins</span>
}

// Protocol Integration Templates and Configurations

// ProtocolTemplateManager manages plugin templates for protocol integrations
type ProtocolTemplateManager struct {
        mu        sync.RWMutex
        templates map[string]*ProtocolTemplate
        logger    *logrus.Logger
}

// ProtocolTemplate represents a plugin template for protocol integration
type ProtocolTemplate struct {
        ID           string
        Name         string
        Description  string
        Protocol     string
        Version      string
        Files        map[string]string // filename -&gt; content
        Config       map[string]interface{}
        Tags         []string
        Author       string
        CreatedAt    time.Time
        Category     string
        Requirements []string
}

// NewProtocolTemplateManager creates a new template manager
func NewProtocolTemplateManager(logger *logrus.Logger) *ProtocolTemplateManager <span class="cov7" title="7">{
        return &amp;ProtocolTemplateManager{
                templates: make(map[string]*ProtocolTemplate),
                logger:    logger,
        }
}</span>

// AddTemplate adds a protocol integration template
func (tm *ProtocolTemplateManager) AddTemplate(template *ProtocolTemplate) error <span class="cov9" title="12">{
        tm.mu.Lock()
        defer tm.mu.Unlock()

        if _, exists := tm.templates[template.ID]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("template %s already exists", template.ID)
        }</span>

        <span class="cov8" title="11">template.CreatedAt = time.Now()
        tm.templates[template.ID] = template

        tm.logger.WithFields(logrus.Fields{
                "templateId": template.ID,
                "name":       template.Name,
                "protocol":   template.Protocol,
        }).Info("Protocol template added")

        return nil</span>
}

// GetTemplate returns a template by ID
func (tm *ProtocolTemplateManager) GetTemplate(templateID string) (*ProtocolTemplate, error) <span class="cov5" title="4">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        template, exists := tm.templates[templateID]
        if !exists </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("template %s not found", templateID)
        }</span>

        <span class="cov3" title="2">return template, nil</span>
}

// ListTemplates returns all templates
func (tm *ProtocolTemplateManager) ListTemplates() []*ProtocolTemplate <span class="cov4" title="3">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        templates := make([]*ProtocolTemplate, 0, len(tm.templates))
        for _, template := range tm.templates </span><span class="cov5" title="4">{
                templates = append(templates, template)
        }</span>

        <span class="cov4" title="3">return templates</span>
}

// ListTemplatesByProtocol returns templates for a specific protocol
func (tm *ProtocolTemplateManager) ListTemplatesByProtocol(protocol string) []*ProtocolTemplate <span class="cov6" title="5">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()

        var templates []*ProtocolTemplate
        for _, template := range tm.templates </span><span class="cov9" title="13">{
                if template.Protocol == protocol </span><span class="cov6" title="5">{
                        templates = append(templates, template)
                }</span>
        }

        <span class="cov6" title="5">return templates</span>
}

// GeneratePluginFromTemplate generates a plugin from a template
func (tm *ProtocolTemplateManager) GeneratePluginFromTemplate(templateID string, config map[string]interface{}) (*ProtocolTemplate, error) <span class="cov3" title="2">{
        template, err := tm.GetTemplate(templateID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Create a copy of the template
        <span class="cov1" title="1">generated := &amp;ProtocolTemplate{
                ID:           fmt.Sprintf("%s-generated-%d", template.ID, time.Now().Unix()),
                Name:         template.Name,
                Description:  template.Description,
                Protocol:     template.Protocol,
                Version:      template.Version,
                Files:        make(map[string]string),
                Config:       config,
                Tags:         append([]string{}, template.Tags...),
                Author:       template.Author,
                CreatedAt:    time.Now(),
                Category:     template.Category,
                Requirements: append([]string{}, template.Requirements...),
        }

        // Copy files
        for filename, content := range template.Files </span><span class="cov3" title="2">{
                generated.Files[filename] = content
        }</span>

        <span class="cov1" title="1">tm.logger.WithFields(logrus.Fields{
                "templateId":  templateID,
                "generatedId": generated.ID,
        }).Info("Plugin generated from protocol template")

        return generated, nil</span>
}

// InitializeDefaultTemplates initializes default templates
func (tm *ProtocolTemplateManager) InitializeDefaultTemplates() error <span class="cov1" title="1">{
        // MCP Plugin Template
        mcpTemplate := &amp;ProtocolTemplate{
                ID:          "mcp-basic-integration",
                Name:        "Basic MCP Integration",
                Description: "A basic MCP plugin template with tool calling and resource management",
                Protocol:    "mcp",
                Version:     "1.0.0",
                Files: map[string]string{
                        "main.go": `package main

import (
        "context"
        "fmt"
)

// BasicMCPPlugin implements the MCP plugin
type BasicMCPPlugin struct{}

// NewPlugin creates a new plugin instance
func NewPlugin(config map[string]interface{}) (ProtocolPluginExecutor, error) {
        return &amp;BasicMCPPlugin{}, nil
}

// Execute executes a plugin operation
func (p *BasicMCPPlugin) Execute(ctx context.Context, operation string, params map[string]interface{}) (interface{}, error) {
        switch operation {
        case "list_tools":
                return []map[string]interface{}{
                        {
                                "name":        "calculate",
                                "description": "Perform mathematical calculations",
                        },
                }, nil
        case "call_tool":
                return map[string]interface{}{
                        "result": "calculation completed",
                }, nil
        default:
                return nil, fmt.Errorf("unknown operation: %s", operation)
        }
}

// GetCapabilities returns plugin capabilities
func (p *BasicMCPPlugin) GetCapabilities() map[string]interface{} {
        return map[string]interface{}{
                "tools": []string{"calculate"},
        }
}

// ValidateConfig validates plugin configuration
func (p *BasicMCPPlugin) ValidateConfig(config map[string]interface{}) error {
        return nil
}

// Initialize initializes the plugin
func (p *BasicMCPPlugin) Initialize(ctx context.Context) error {
        fmt.Println("MCP Basic Integration Plugin initialized")
        return nil
}

// Shutdown shuts down the plugin
func (p *BasicMCPPlugin) Shutdown(ctx context.Context) error {
        fmt.Println("MCP Basic Integration Plugin shutdown")
        return nil
}

func main() {
        fmt.Println("MCP Basic Integration Plugin")
}`,
                },
                Config: map[string]interface{}{
                        "enabled": true,
                        "timeout": "30s",
                },
                Tags:         []string{"mcp", "basic", "integration"},
                Author:       "SuperAgent",
                Category:     "integration",
                Requirements: []string{"mcp-client"},
        }

        if err := tm.AddTemplate(mcpTemplate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add MCP template: %w", err)
        }</span>

        // LSP Plugin Template
        <span class="cov1" title="1">lspTemplate := &amp;ProtocolTemplate{
                ID:          "lsp-code-completion",
                Name:        "LSP Code Completion",
                Description: "LSP plugin template for code completion and navigation",
                Protocol:    "lsp",
                Version:     "1.0.0",
                Files: map[string]string{
                        "lsp_plugin.go": `package main

import (
        "context"
        "fmt"
)

// LSPCompletionPlugin provides LSP code completion
type LSPCompletionPlugin struct {
        language string
}

// NewPlugin creates a new LSP plugin instance
func NewPlugin(config map[string]interface{}) (ProtocolPluginExecutor, error) {
        language := "go"
        if lang, ok := config["language"].(string); ok {
                language = lang
        }
        return &amp;LSPCompletionPlugin{language: language}, nil
}

// Execute executes LSP operations
func (p *LSPCompletionPlugin) Execute(ctx context.Context, operation string, params map[string]interface{}) (interface{}, error) {
        switch operation {
        case "completion":
                return []map[string]interface{}{
                        {"label": "fmt.Println", "kind": 3},
                }, nil
        case "hover":
                return map[string]interface{}{
                        "contents": "Function documentation",
                }, nil
        default:
                return nil, fmt.Errorf("unsupported operation: %s", operation)
        }
}

// GetCapabilities returns LSP capabilities
func (p *LSPCompletionPlugin) GetCapabilities() map[string]interface{} {
        return map[string]interface{}{
                "completionProvider": true,
                "hoverProvider":      true,
                "language":          p.language,
        }
}

// ValidateConfig validates LSP plugin configuration
func (p *LSPCompletionPlugin) ValidateConfig(config map[string]interface{}) error {
        return nil
}

// Initialize initializes the LSP plugin
func (p *LSPCompletionPlugin) Initialize(ctx context.Context) error {
        fmt.Printf("LSP Plugin initialized for %s\n", p.language)
        return nil
}

// Shutdown shuts down the LSP plugin
func (p *LSPCompletionPlugin) Shutdown(ctx context.Context) error {
        fmt.Printf("LSP Plugin shutdown for %s\n", p.language)
        return nil
}

func main() {
        fmt.Println("LSP Code Completion Plugin")
}`,
                },
                Config: map[string]interface{}{
                        "language": "go",
                        "enabled":  true,
                },
                Tags:         []string{"lsp", "completion", "code"},
                Author:       "SuperAgent",
                Category:     "development",
                Requirements: []string{"lsp-client"},
        }

        if err := tm.AddTemplate(lspTemplate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add LSP template: %w", err)
        }</span>

        <span class="cov1" title="1">tm.logger.WithField("count", 2).Info("Default protocol integration templates initialized")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProtocolSecurity provides authentication and authorization for protocols
type ProtocolSecurity struct {
        mu          sync.RWMutex
        apiKeys     map[string]*APIKey
        permissions map[string][]string // key -&gt; permissions
        logger      *logrus.Logger
}

// APIKey represents an API key with permissions
type APIKey struct {
        Key         string
        Name        string
        Owner       string
        Permissions []string
        CreatedAt   time.Time
        LastUsed    time.Time
        Active      bool
}

// ProtocolAccessRequest represents a request for protocol access
type ProtocolAccessRequest struct {
        APIKey   string
        Protocol string
        Action   string
        Resource string
}

// NewProtocolSecurity creates a new protocol security manager
func NewProtocolSecurity(logger *logrus.Logger) *ProtocolSecurity <span class="cov7" title="22">{
        return &amp;ProtocolSecurity{
                apiKeys:     make(map[string]*APIKey),
                permissions: make(map[string][]string),
                logger:      logger,
        }
}</span>

// CreateAPIKey creates a new API key with permissions
func (s *ProtocolSecurity) CreateAPIKey(name, owner string, permissions []string) (*APIKey, error) <span class="cov9" title="45">{
        s.mu.Lock()
        defer s.mu.Unlock()

        key := generateSecureToken()

        apiKey := &amp;APIKey{
                Key:         key,
                Name:        name,
                Owner:       owner,
                Permissions: permissions,
                CreatedAt:   time.Now(),
                Active:      true,
        }

        s.apiKeys[key] = apiKey
        s.permissions[key] = permissions

        s.logger.WithFields(logrus.Fields{
                "name":  name,
                "owner": owner,
        }).Info("API key created")

        return apiKey, nil
}</span>

// ValidateAccess validates if an API key has access to a protocol operation
func (s *ProtocolSecurity) ValidateAccess(ctx context.Context, req ProtocolAccessRequest) error <span class="cov6" title="13">{
        s.mu.RLock()
        apiKey, exists := s.apiKeys[req.APIKey]
        s.mu.RUnlock()

        if !exists || !apiKey.Active </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid API key")
        }</span>

        // Check permissions
        <span class="cov6" title="11">permissions, exists := s.permissions[req.APIKey]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no permissions found for API key")
        }</span>

        <span class="cov6" title="11">requiredPermission := fmt.Sprintf("%s:%s", req.Protocol, req.Action)

        // Check for exact match or wildcard
        for _, permission := range permissions </span><span class="cov7" title="21">{
                if permission == requiredPermission ||
                        permission == fmt.Sprintf("%s:*", req.Protocol) ||
                        permission == "*" </span><span class="cov5" title="8">{
                        // Update last used time
                        s.mu.Lock()
                        apiKey.LastUsed = time.Now()
                        s.mu.Unlock()

                        return nil
                }</span>
        }

        <span class="cov3" title="3">return fmt.Errorf("insufficient permissions for %s", requiredPermission)</span>
}

// RevokeAPIKey revokes an API key
func (s *ProtocolSecurity) RevokeAPIKey(key string) error <span class="cov2" title="2">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if apiKey, exists := s.apiKeys[key]; exists </span><span class="cov1" title="1">{
                apiKey.Active = false
                delete(s.permissions, key)

                s.logger.WithField("key", key[:8]+"...").Info("API key revoked")
                return nil
        }</span>

        <span class="cov1" title="1">return fmt.Errorf("API key not found")</span>
}

// ListAPIKeys returns all API keys (for admin purposes)
func (s *ProtocolSecurity) ListAPIKeys() []*APIKey <span class="cov3" title="3">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        keys := make([]*APIKey, 0, len(s.apiKeys))
        for _, key := range s.apiKeys </span><span class="cov4" title="5">{
                keys = append(keys, key)
        }</span>

        <span class="cov3" title="3">return keys</span>
}

// InitializeDefaultSecurity sets up default security configuration
func (s *ProtocolSecurity) InitializeDefaultSecurity() error <span class="cov6" title="15">{
        // Create admin key with full access
        adminKey, err := s.CreateAPIKey("admin-key", "system", []string{
                "*", // Full access
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create admin key: %w", err)
        }</span>

        <span class="cov6" title="15">s.logger.WithField("key", adminKey.Key[:8]+"...").Info("Admin API key created")

        // Create user key with limited access
        userKey, err := s.CreateAPIKey("user-key", "demo", []string{
                "mcp:read",
                "mcp:execute",
                "lsp:read",
                "lsp:execute",
                "acp:read",
                "acp:execute",
                "embedding:read",
                "embedding:execute",
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user key: %w", err)
        }</span>

        <span class="cov6" title="15">s.logger.WithField("key", userKey.Key[:8]+"...").Info("User API key created")

        return nil</span>
}

// Rate limiting (basic implementation)

type RateLimiter struct {
        mu        sync.Mutex
        requests  map[string][]time.Time
        maxPerMin int
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(maxPerMin int) *RateLimiter <span class="cov7" title="21">{
        return &amp;RateLimiter{
                requests:  make(map[string][]time.Time),
                maxPerMin: maxPerMin,
        }
}</span>

// Allow checks if a request should be allowed
func (r *RateLimiter) Allow(key string) bool <span class="cov8" title="28">{
        r.mu.Lock()
        defer r.mu.Unlock()

        now := time.Now()
        windowStart := now.Add(-time.Minute)

        // Clean old requests
        if requests, exists := r.requests[key]; exists </span><span class="cov7" title="18">{
                valid := make([]time.Time, 0)
                for _, t := range requests </span><span class="cov10" title="65">{
                        if t.After(windowStart) </span><span class="cov10" title="65">{
                                valid = append(valid, t)
                        }</span>
                }
                <span class="cov7" title="18">r.requests[key] = valid

                // Check if under limit
                if len(valid) &lt; r.maxPerMin </span><span class="cov6" title="15">{
                        r.requests[key] = append(r.requests[key], now)
                        return true
                }</span>
                <span class="cov3" title="3">return false</span>
        }

        // First request
        <span class="cov5" title="10">r.requests[key] = []time.Time{now}
        return true</span>
}

// Global rate limiter
var GlobalRateLimiter = NewRateLimiter(100) // 100 requests per minute per API key

// Utility functions

func generateSecureToken() string <span class="cov9" title="45">{
        return fmt.Sprintf("sk-%s", generateID())
}</span>

func generateID() string <span class="cov9" title="45">{
        // Simple ID generation - in production, use crypto/rand
        return fmt.Sprintf("%d", time.Now().UnixNano())
}</span>

// Middleware helpers

// ExtractAPIKeyFromHeader extracts API key from request headers
func ExtractAPIKeyFromHeader(headerValue string) string <span class="cov3" title="4">{
        if strings.HasPrefix(headerValue, "Bearer ") </span><span class="cov2" title="2">{
                return strings.TrimPrefix(headerValue, "Bearer ")
        }</span>
        <span class="cov2" title="2">return headerValue</span>
}

// ValidateProtocolAccess is a convenience function for protocol access validation
func (s *ProtocolSecurity) ValidateProtocolAccess(ctx context.Context, apiKey, protocol, action, resource string) error <span class="cov5" title="7">{
        return s.ValidateAccess(ctx, ProtocolAccessRequest{
                APIKey:   apiKey,
                Protocol: protocol,
                Action:   action,
                Resource: resource,
        })
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// ModelMetadataServiceInterface defines the interface for model metadata service
type ModelMetadataServiceInterface interface {
        GetModel(ctx context.Context, modelID string) (*database.ModelMetadata, error)
        ListModels(ctx context.Context, providerID string, modelType string, page int, limit int) ([]*database.ModelMetadata, int, error)
        SearchModels(ctx context.Context, query string, page int, limit int) ([]*database.ModelMetadata, int, error)
        RefreshModels(ctx context.Context) error
        RefreshProviderModels(ctx context.Context, providerID string) error
        GetRefreshHistory(ctx context.Context, limit int) ([]*database.ModelsRefreshHistory, error)
        GetProviderModels(ctx context.Context, providerID string) ([]*database.ModelMetadata, error)
        CompareModels(ctx context.Context, modelIDs []string) ([]*database.ModelMetadata, error)
        GetModelsByCapability(ctx context.Context, capability string) ([]*database.ModelMetadata, error)
}

// ProviderRegistryInterface defines the interface for provider registry
type ProviderRegistryInterface interface {
        ListProviders() []string
        GetProviderConfig(name string) (*ProviderConfig, error)
        ConfigureProvider(name string, config *ProviderConfig) error
}

// ProviderMetadataService integrates Models.dev data with provider registry
type ProviderMetadataService struct {
        modelMetadataService ModelMetadataServiceInterface
        providerRegistry     ProviderRegistryInterface
        log                  *logrus.Logger
        mu                   sync.RWMutex
        providerToModels     map[string][]*database.ModelMetadata
}

// NewProviderMetadataService creates a new provider metadata service
func NewProviderMetadataService(
        modelMetadataService ModelMetadataServiceInterface,
        providerRegistry ProviderRegistryInterface,
        log *logrus.Logger,
) *ProviderMetadataService <span class="cov10" title="18">{
        return &amp;ProviderMetadataService{
                modelMetadataService: modelMetadataService,
                providerRegistry:     providerRegistry,
                log:                  log,
                providerToModels:     make(map[string][]*database.ModelMetadata),
        }
}</span>

// LoadProviderMetadata loads Models.dev metadata for all providers
func (s *ProviderMetadataService) LoadProviderMetadata(ctx context.Context) error <span class="cov3" title="2">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Clear existing data
        s.providerToModels = make(map[string][]*database.ModelMetadata)

        // Get all providers from registry
        providers := s.providerRegistry.ListProviders()

        for _, providerName := range providers </span><span class="cov3" title="2">{
                s.log.WithField("provider", providerName).Info("Loading metadata for provider")

                // Get models for this provider
                models, err := s.modelMetadataService.GetProviderModels(ctx, providerName)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("provider", providerName).Warn("Failed to load provider models")
                        continue</span>
                }

                <span class="cov3" title="2">s.providerToModels[providerName] = models
                s.log.WithFields(logrus.Fields{
                        "provider":    providerName,
                        "model_count": len(models),
                }).Info("Loaded models for provider")</span>
        }

        <span class="cov3" title="2">s.log.WithField("total_providers", len(s.providerToModels)).Info("Provider metadata loaded")
        return nil</span>
}

// UpdateProviderConfigs updates provider configurations with Models.dev metadata
func (s *ProviderMetadataService) UpdateProviderConfigs(ctx context.Context) (map[string]*ProviderConfig, error) <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        updatedConfigs := make(map[string]*ProviderConfig)

        for providerName, models := range s.providerToModels </span><span class="cov1" title="1">{
                config, err := s.providerRegistry.GetProviderConfig(providerName)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("provider", providerName).Warn("Failed to get provider config")
                        continue</span>
                }

                // Update model configurations with Models.dev metadata
                <span class="cov1" title="1">updatedConfig := s.enhanceProviderConfig(config, models)
                updatedConfigs[providerName] = updatedConfig

                // Update the provider in the registry
                if err := s.providerRegistry.ConfigureProvider(providerName, updatedConfig); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("provider", providerName).Warn("Failed to update provider config")
                }</span>
        }

        <span class="cov1" title="1">return updatedConfigs, nil</span>
}

// enhanceProviderConfig enhances provider configuration with Models.dev metadata
func (s *ProviderMetadataService) enhanceProviderConfig(
        config *ProviderConfig,
        models []*database.ModelMetadata,
) *ProviderConfig <span class="cov4" title="3">{
        enhancedConfig := &amp;ProviderConfig{
                Name:           config.Name,
                Type:           config.Type,
                Enabled:        config.Enabled,
                APIKey:         config.APIKey,
                BaseURL:        config.BaseURL,
                Timeout:        config.Timeout,
                MaxRetries:     config.MaxRetries,
                HealthCheckURL: config.HealthCheckURL,
                Weight:         config.Weight,
                Tags:           config.Tags,
                Capabilities:   config.Capabilities,
                CustomSettings: config.CustomSettings,
                Models:         make([]ModelConfig, 0),
        }

        // Convert Models.dev models to provider model configurations
        for _, model := range models </span><span class="cov4" title="3">{
                modelConfig := ModelConfig{
                        ID:           model.ModelID,
                        Name:         model.ModelName,
                        Enabled:      true,
                        Weight:       s.calculateModelWeight(model),
                        Capabilities: s.extractCapabilities(model),
                        CustomParams: s.createCustomParams(model),
                }

                enhancedConfig.Models = append(enhancedConfig.Models, modelConfig)
        }</span>

        <span class="cov4" title="3">return enhancedConfig</span>
}

// calculateModelWeight calculates weight based on model metadata
func (s *ProviderMetadataService) calculateModelWeight(model *database.ModelMetadata) float64 <span class="cov7" title="7">{
        weight := 1.0

        // Adjust weight based on benchmark scores
        if model.BenchmarkScore != nil </span><span class="cov6" title="5">{
                // Normalize benchmark score (assuming 0-100 scale)
                benchmarkWeight := *model.BenchmarkScore / 100.0
                weight += benchmarkWeight * 0.5 // Add up to 50% based on benchmarks
        }</span>

        // Adjust weight based on popularity
        <span class="cov7" title="7">if model.PopularityScore != nil </span><span class="cov3" title="2">{
                // Assuming popularity score is 0-100
                popularityWeight := float64(*model.PopularityScore) / 100.0
                weight += popularityWeight * 0.3 // Add up to 30% based on popularity
        }</span>

        // Adjust weight based on reliability
        <span class="cov7" title="7">if model.ReliabilityScore != nil </span><span class="cov3" title="2">{
                reliabilityWeight := *model.ReliabilityScore / 1.0 // Assuming 0-1 scale
                weight += reliabilityWeight * 0.2                  // Add up to 20% based on reliability
        }</span>

        // Cap weight at reasonable limits
        <span class="cov7" title="7">if weight &gt; 2.0 </span><span class="cov0" title="0">{
                weight = 2.0
        }</span>
        <span class="cov7" title="7">if weight &lt; 0.5 </span><span class="cov0" title="0">{
                weight = 0.5
        }</span>

        <span class="cov7" title="7">return weight</span>
}

// extractCapabilities extracts capabilities from model metadata
func (s *ProviderMetadataService) extractCapabilities(model *database.ModelMetadata) []string <span class="cov7" title="9">{
        capabilities := make([]string, 0)

        // Map boolean fields to capability names
        if model.SupportsVision </span><span class="cov6" title="5">{
                capabilities = append(capabilities, "vision")
        }</span>
        <span class="cov7" title="9">if model.SupportsFunctionCalling </span><span class="cov4" title="3">{
                capabilities = append(capabilities, "function_calling")
        }</span>
        <span class="cov7" title="9">if model.SupportsStreaming </span><span class="cov4" title="3">{
                capabilities = append(capabilities, "streaming")
        }</span>
        <span class="cov7" title="9">if model.SupportsJSONMode </span><span class="cov1" title="1">{
                capabilities = append(capabilities, "json_mode")
        }</span>
        <span class="cov7" title="9">if model.SupportsImageGeneration </span><span class="cov1" title="1">{
                capabilities = append(capabilities, "image_generation")
        }</span>
        <span class="cov7" title="9">if model.SupportsAudio </span><span class="cov1" title="1">{
                capabilities = append(capabilities, "audio")
        }</span>
        <span class="cov7" title="9">if model.SupportsCodeGeneration </span><span class="cov1" title="1">{
                capabilities = append(capabilities, "code_generation")
        }</span>
        <span class="cov7" title="9">if model.SupportsReasoning </span><span class="cov1" title="1">{
                capabilities = append(capabilities, "reasoning")
        }</span>

        // Add model type as capability
        <span class="cov7" title="9">if model.ModelType != nil </span><span class="cov1" title="1">{
                capabilities = append(capabilities, strings.ToLower(*model.ModelType))
        }</span>

        <span class="cov7" title="9">return capabilities</span>
}

// createCustomParams creates custom parameters for model configuration
func (s *ProviderMetadataService) createCustomParams(model *database.ModelMetadata) map[string]any <span class="cov7" title="8">{
        params := make(map[string]any)

        // Add context window if available
        if model.ContextWindow != nil </span><span class="cov1" title="1">{
                params["max_tokens"] = *model.ContextWindow
        }</span>

        // Add max tokens if available
        <span class="cov7" title="8">if model.MaxTokens != nil </span><span class="cov1" title="1">{
                params["max_completion_tokens"] = *model.MaxTokens
        }</span>

        // Add pricing information if available
        <span class="cov7" title="8">if model.PricingInput != nil </span><span class="cov1" title="1">{
                params["pricing_input_per_million"] = *model.PricingInput
        }</span>
        <span class="cov7" title="8">if model.PricingOutput != nil </span><span class="cov1" title="1">{
                params["pricing_output_per_million"] = *model.PricingOutput
        }</span>
        <span class="cov7" title="8">if model.PricingCurrency != "" </span><span class="cov1" title="1">{
                params["pricing_currency"] = model.PricingCurrency
        }</span>

        // Add metadata flags
        <span class="cov7" title="8">params["supports_vision"] = model.SupportsVision
        params["supports_function_calling"] = model.SupportsFunctionCalling
        params["supports_streaming"] = model.SupportsStreaming
        params["supports_json_mode"] = model.SupportsJSONMode
        params["supports_image_generation"] = model.SupportsImageGeneration
        params["supports_audio"] = model.SupportsAudio
        params["supports_code_generation"] = model.SupportsCodeGeneration
        params["supports_reasoning"] = model.SupportsReasoning

        // Add benchmark information if available
        if model.BenchmarkScore != nil </span><span class="cov4" title="3">{
                params["benchmark_score"] = *model.BenchmarkScore
        }</span>

        <span class="cov7" title="8">return params</span>
}

// GetModelsForProvider returns models for a specific provider
func (s *ProviderMetadataService) GetModelsForProvider(ctx context.Context, providerName string) ([]*database.ModelMetadata, error) <span class="cov5" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        models, exists := s.providerToModels[providerName]
        if !exists </span><span class="cov1" title="1">{
                // Try to load models for this provider
                s.mu.RUnlock()
                models, err := s.modelMetadataService.GetProviderModels(ctx, providerName)
                s.mu.RLock()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get models for provider %s: %w", providerName, err)
                }</span>
                <span class="cov1" title="1">s.providerToModels[providerName] = models
                return models, nil</span>
        }

        <span class="cov4" title="3">return models, nil</span>
}

// GetRecommendedModel returns the recommended model for a provider based on capabilities
func (s *ProviderMetadataService) GetRecommendedModel(
        ctx context.Context,
        providerName string,
        requiredCapabilities []string,
) (*database.ModelMetadata, error) <span class="cov3" title="2">{
        models, err := s.GetModelsForProvider(ctx, providerName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter models by required capabilities
        <span class="cov3" title="2">var candidateModels []*database.ModelMetadata
        for _, model := range models </span><span class="cov4" title="3">{
                if s.hasRequiredCapabilities(model, requiredCapabilities) </span><span class="cov1" title="1">{
                        candidateModels = append(candidateModels, model)
                }</span>
        }

        <span class="cov3" title="2">if len(candidateModels) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no models found for provider %s with required capabilities", providerName)
        }</span>

        // Select best model based on scoring
        <span class="cov1" title="1">return s.selectBestModel(candidateModels), nil</span>
}

// hasRequiredCapabilities checks if a model has all required capabilities
func (s *ProviderMetadataService) hasRequiredCapabilities(
        model *database.ModelMetadata,
        requiredCapabilities []string,
) bool <span class="cov8" title="13">{
        for _, required := range requiredCapabilities </span><span class="cov9" title="14">{
                hasCapability := false

                switch strings.ToLower(required) </span>{
                case "vision":<span class="cov6" title="5">
                        hasCapability = model.SupportsVision</span>
                case "function_calling":<span class="cov3" title="2">
                        hasCapability = model.SupportsFunctionCalling</span>
                case "streaming":<span class="cov1" title="1">
                        hasCapability = model.SupportsStreaming</span>
                case "json_mode":<span class="cov1" title="1">
                        hasCapability = model.SupportsJSONMode</span>
                case "image_generation":<span class="cov1" title="1">
                        hasCapability = model.SupportsImageGeneration</span>
                case "audio":<span class="cov1" title="1">
                        hasCapability = model.SupportsAudio</span>
                case "code_generation":<span class="cov1" title="1">
                        hasCapability = model.SupportsCodeGeneration</span>
                case "reasoning":<span class="cov1" title="1">
                        hasCapability = model.SupportsReasoning</span>
                default:<span class="cov1" title="1">
                        // Check if capability is in tags
                        for _, tag := range model.Tags </span><span class="cov1" title="1">{
                                if strings.EqualFold(tag, required) </span><span class="cov1" title="1">{
                                        hasCapability = true
                                        break</span>
                                }
                        }
                }

                <span class="cov9" title="14">if !hasCapability </span><span class="cov4" title="3">{
                        return false
                }</span>
        }

        <span class="cov8" title="10">return true</span>
}

// selectBestModel selects the best model based on scoring
func (s *ProviderMetadataService) selectBestModel(models []*database.ModelMetadata) *database.ModelMetadata <span class="cov5" title="4">{
        if len(models) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="3">var bestModel *database.ModelMetadata
        bestScore := -1.0

        for _, model := range models </span><span class="cov5" title="4">{
                score := s.calculateModelScore(model)
                if score &gt; bestScore </span><span class="cov5" title="4">{
                        bestScore = score
                        bestModel = model
                }</span>
        }

        <span class="cov4" title="3">return bestModel</span>
}

// calculateModelScore calculates a score for model selection
func (s *ProviderMetadataService) calculateModelScore(model *database.ModelMetadata) float64 <span class="cov7" title="7">{
        score := 0.0

        // Add benchmark score if available
        if model.BenchmarkScore != nil </span><span class="cov5" title="4">{
                score += *model.BenchmarkScore
        }</span>

        // Add popularity score if available
        <span class="cov7" title="7">if model.PopularityScore != nil </span><span class="cov1" title="1">{
                score += float64(*model.PopularityScore) * 0.5
        }</span>

        // Add reliability score if available
        <span class="cov7" title="7">if model.ReliabilityScore != nil </span><span class="cov1" title="1">{
                score += *model.ReliabilityScore * 100.0
        }</span>

        // Prefer newer models (if version is available)
        <span class="cov7" title="7">if model.Version != nil </span><span class="cov1" title="1">{
                // Simple scoring for version (higher is better)
                score += 10.0
        }</span>

        // Adjust for context window size
        <span class="cov7" title="7">if model.ContextWindow != nil </span><span class="cov3" title="2">{
                contextWindowScore := float64(*model.ContextWindow) / 1000.0
                if contextWindowScore &gt; 100.0 </span><span class="cov1" title="1">{
                        contextWindowScore = 100.0
                }</span>
                <span class="cov3" title="2">score += contextWindowScore</span>
        }

        <span class="cov7" title="7">return score</span>
}

// RefreshProviderMetadata refreshes metadata for a specific provider
func (s *ProviderMetadataService) RefreshProviderMetadata(ctx context.Context, providerName string) error <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Refresh models from Models.dev
        s.log.WithField("provider", providerName).Info("Refreshing provider metadata")

        // Call ModelMetadataService to refresh provider models
        err := s.modelMetadataService.RefreshProviderModels(ctx, providerName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to refresh provider %s models: %w", providerName, err)
        }</span>

        // Reload models for this provider
        <span class="cov1" title="1">models, err := s.modelMetadataService.GetProviderModels(ctx, providerName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get refreshed models for provider %s: %w", providerName, err)
        }</span>

        // Update cache
        <span class="cov1" title="1">s.providerToModels[providerName] = models

        // Update provider configuration
        config, err := s.providerRegistry.GetProviderConfig(providerName)
        if err == nil </span><span class="cov1" title="1">{
                updatedConfig := s.enhanceProviderConfig(config, models)
                if err := s.providerRegistry.ConfigureProvider(providerName, updatedConfig); err != nil </span><span class="cov0" title="0">{
                        s.log.WithError(err).WithField("provider", providerName).Warn("Failed to update provider config after refresh")
                }</span>
        }

        <span class="cov1" title="1">s.log.WithFields(logrus.Fields{
                "provider":    providerName,
                "model_count": len(models),
        }).Info("Provider metadata refreshed")

        return nil</span>
}

// StartAutoRefresh starts automatic refresh of provider metadata
func (s *ProviderMetadataService) StartAutoRefresh(refreshInterval time.Duration) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(refreshInterval)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        if err := s.LoadProviderMetadata(ctx); err != nil </span><span class="cov0" title="0">{
                                s.log.WithError(err).Error("Failed to auto-refresh provider metadata")
                        }</span> else<span class="cov0" title="0"> {
                                s.log.Info("Auto-refresh of provider metadata completed")
                        }</span>
                }
        }()
}

// StopAutoRefresh stops automatic refresh of provider metadata
func (s *ProviderMetadataService) StopAutoRefresh() {<span class="cov1" title="1">
        // Currently uses ticker which runs until service stops
        // Could be enhanced with context cancellation
}</span>

// GetProviderStats returns statistics for all providers
func (s *ProviderMetadataService) GetProviderStats(ctx context.Context) (map[string]ProviderStats, error) <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        stats := make(map[string]ProviderStats)

        for providerName, models := range s.providerToModels </span><span class="cov1" title="1">{
                stat := ProviderStats{
                        TotalModels:     len(models),
                        EnabledModels:   len(models), // All models from Models.dev are considered enabled
                        AverageScore:    0.0,
                        Capabilities:    make(map[string]int),
                        LastRefreshedAt: time.Now(),
                }

                // Calculate average benchmark score
                totalScore := 0.0
                modelsWithScore := 0

                for _, model := range models </span><span class="cov3" title="2">{
                        // Count capabilities
                        for _, capability := range s.extractCapabilities(model) </span><span class="cov3" title="2">{
                                stat.Capabilities[capability]++
                        }</span>

                        // Calculate average score
                        <span class="cov3" title="2">if model.BenchmarkScore != nil </span><span class="cov1" title="1">{
                                totalScore += *model.BenchmarkScore
                                modelsWithScore++
                        }</span>

                        // Find most recent refresh
                        <span class="cov3" title="2">if model.LastRefreshedAt.After(stat.LastRefreshedAt) </span><span class="cov0" title="0">{
                                stat.LastRefreshedAt = model.LastRefreshedAt
                        }</span>
                }

                <span class="cov1" title="1">if modelsWithScore &gt; 0 </span><span class="cov1" title="1">{
                        stat.AverageScore = totalScore / float64(modelsWithScore)
                }</span>

                <span class="cov1" title="1">stats[providerName] = stat</span>
        }

        <span class="cov1" title="1">return stats, nil</span>
}

// ProviderStats holds statistics for a provider
type ProviderStats struct {
        TotalModels     int            `json:"total_models"`
        EnabledModels   int            `json:"enabled_models"`
        AverageScore    float64        `json:"average_score"`
        Capabilities    map[string]int `json:"capabilities"`
        LastRefreshedAt time.Time      `json:"last_refreshed_at"`
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import (
        "context"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/superagent/superagent/internal/config"
        "github.com/superagent/superagent/internal/llm"
        "github.com/superagent/superagent/internal/llm/providers/claude"
        "github.com/superagent/superagent/internal/llm/providers/deepseek"
        "github.com/superagent/superagent/internal/llm/providers/gemini"
        "github.com/superagent/superagent/internal/llm/providers/openrouter"
        "github.com/superagent/superagent/internal/llm/providers/qwen"
        "github.com/superagent/superagent/internal/models"
)

// ProviderRegistry manages LLM provider registration and configuration
type ProviderRegistry struct {
        providers       map[string]llm.LLMProvider
        circuitBreakers map[string]*CircuitBreaker
        config          *RegistryConfig
        ensemble        *EnsembleService
        requestService  *RequestService
        memory          *MemoryService
        mu              sync.RWMutex
}

// ProviderConfig holds configuration for an LLM provider
type ProviderConfig struct {
        Name           string            `json:"name"`
        Type           string            `json:"type"`
        Enabled        bool              `json:"enabled"`
        APIKey         string            `json:"api_key"`
        BaseURL        string            `json:"base_url"`
        Models         []ModelConfig     `json:"models"`
        Timeout        time.Duration     `json:"timeout"`
        MaxRetries     int               `json:"max_retries"`
        HealthCheckURL string            `json:"health_check_url"`
        Weight         float64           `json:"weight"`
        Tags           []string          `json:"tags"`
        Capabilities   map[string]string `json:"capabilities"`
        CustomSettings map[string]any    `json:"custom_settings"`
}

// ModelConfig holds configuration for a specific model
type ModelConfig struct {
        ID           string         `json:"id"`
        Name         string         `json:"name"`
        Enabled      bool           `json:"enabled"`
        Weight       float64        `json:"weight"`
        Capabilities []string       `json:"capabilities"`
        CustomParams map[string]any `json:"custom_params"`
}

// RegistryConfig holds configuration for provider registry
type RegistryConfig struct {
        DefaultTimeout time.Duration              `json:"default_timeout"`
        MaxRetries     int                        `json:"max_retries"`
        HealthCheck    HealthCheckConfig          `json:"health_check"`
        CircuitBreaker CircuitBreakerConfig       `json:"circuit_breaker"`
        Providers      map[string]*ProviderConfig `json:"providers"`
        Ensemble       *models.EnsembleConfig     `json:"ensemble"`
        Routing        *RoutingConfig             `json:"routing"`
}

// HealthCheckConfig holds health check configuration
type HealthCheckConfig struct {
        Enabled          bool          `json:"enabled"`
        Interval         time.Duration `json:"interval"`
        Timeout          time.Duration `json:"timeout"`
        FailureThreshold int           `json:"failure_threshold"`
}

// RoutingConfig holds routing configuration
type RoutingConfig struct {
        Strategy string             `json:"strategy"`
        Weights  map[string]float64 `json:"weights"`
}

// CircuitBreakerConfig holds circuit breaker configuration
type CircuitBreakerConfig struct {
        Enabled          bool          `json:"enabled"`
        FailureThreshold int           `json:"failure_threshold"`
        RecoveryTimeout  time.Duration `json:"recovery_timeout"`
        SuccessThreshold int           `json:"success_threshold"`
}

// circuitBreakerProvider wraps an LLMProvider with circuit breaker functionality
type circuitBreakerProvider struct {
        provider       llm.LLMProvider
        circuitBreaker *CircuitBreaker
        name           string
}

// Complete wraps the provider's Complete method with circuit breaker protection
func (cbp *circuitBreakerProvider) Complete(ctx context.Context, req *models.LLMRequest) (*models.LLMResponse, error) <span class="cov3" title="2">{
        var resp *models.LLMResponse
        err := cbp.circuitBreaker.Call(func() error </span><span class="cov3" title="2">{
                var callErr error
                resp, callErr = cbp.provider.Complete(ctx, req)
                return callErr
        }</span>)
        <span class="cov3" title="2">return resp, err</span>
}

// CompleteStream wraps the provider's CompleteStream method with circuit breaker protection
func (cbp *circuitBreakerProvider) CompleteStream(ctx context.Context, req *models.LLMRequest) (&lt;-chan *models.LLMResponse, error) <span class="cov1" title="1">{
        var stream &lt;-chan *models.LLMResponse
        err := cbp.circuitBreaker.Call(func() error </span><span class="cov1" title="1">{
                var callErr error
                stream, callErr = cbp.provider.CompleteStream(ctx, req)
                return callErr
        }</span>)
        <span class="cov1" title="1">return stream, err</span>
}

// HealthCheck wraps the provider's HealthCheck method with circuit breaker protection
func (cbp *circuitBreakerProvider) HealthCheck() error <span class="cov3" title="2">{
        return cbp.circuitBreaker.Call(func() error </span><span class="cov3" title="2">{
                return cbp.provider.HealthCheck()
        }</span>)
}

// GetCapabilities delegates to the underlying provider
func (cbp *circuitBreakerProvider) GetCapabilities() *models.ProviderCapabilities <span class="cov1" title="1">{
        return cbp.provider.GetCapabilities()
}</span>

// ValidateConfig delegates to the underlying provider
func (cbp *circuitBreakerProvider) ValidateConfig(config map[string]interface{}) (bool, []string) <span class="cov1" title="1">{
        return cbp.provider.ValidateConfig(config)
}</span>

func NewProviderRegistry(cfg *RegistryConfig, memory *MemoryService) *ProviderRegistry <span class="cov10" title="12">{
        if cfg == nil </span><span class="cov6" title="4">{
                cfg = getDefaultRegistryConfig()
        }</span>

        <span class="cov10" title="12">registry := &amp;ProviderRegistry{
                providers:       make(map[string]llm.LLMProvider),
                circuitBreakers: make(map[string]*CircuitBreaker),
                config:          cfg,
                memory:          memory,
        }

        // Initialize ensemble service
        ensembleStrategy := "confidence_weighted"
        if cfg.Ensemble != nil </span><span class="cov10" title="12">{
                ensembleStrategy = cfg.Ensemble.Strategy
        }</span>
        <span class="cov10" title="12">registry.ensemble = NewEnsembleService(ensembleStrategy, cfg.DefaultTimeout)

        // Initialize request service
        routingStrategy := "weighted"
        if cfg.Routing != nil </span><span class="cov10" title="12">{
                routingStrategy = cfg.Routing.Strategy
        }</span>
        <span class="cov10" title="12">registry.requestService = NewRequestService(routingStrategy, registry.ensemble, memory)

        // Register default providers
        registry.registerDefaultProviders(cfg)

        return registry</span>
}

func (r *ProviderRegistry) registerDefaultProviders(cfg *RegistryConfig) <span class="cov10" title="12">{
        // Register DeepSeek provider (only if API key is configured)
        deepseekConfig := cfg.Providers["deepseek"]
        if deepseekConfig == nil </span><span class="cov10" title="12">{
                deepseekConfig = &amp;ProviderConfig{
                        Name:    "deepseek",
                        Type:    "deepseek",
                        Enabled: false, // Disabled by default - requires API key
                        Models: []ModelConfig{{
                                ID:      "deepseek-coder",
                                Name:    "DeepSeek Coder",
                                Enabled: true,
                                Weight:  1.0,
                        }},
                }
        }</span>
        <span class="cov10" title="12">if deepseekConfig.Enabled &amp;&amp; deepseekConfig.APIKey != "" </span><span class="cov0" title="0">{
                r.RegisterProvider(deepseekConfig.Name, deepseek.NewDeepSeekProvider(
                        deepseekConfig.APIKey,
                        deepseekConfig.BaseURL,
                        deepseekConfig.Models[0].ID,
                ))
        }</span>

        // Register Claude provider (only if API key is configured)
        <span class="cov10" title="12">claudeConfig := cfg.Providers["claude"]
        if claudeConfig == nil </span><span class="cov10" title="12">{
                claudeConfig = &amp;ProviderConfig{
                        Name:    "claude",
                        Type:    "claude",
                        Enabled: false, // Disabled by default - requires API key
                        Models: []ModelConfig{{
                                ID:      "claude-3-sonnet-20240229",
                                Name:    "Claude 3 Sonnet",
                                Enabled: true,
                                Weight:  1.0,
                        }},
                }
        }</span>
        <span class="cov10" title="12">if claudeConfig.Enabled &amp;&amp; claudeConfig.APIKey != "" </span><span class="cov0" title="0">{
                r.RegisterProvider(claudeConfig.Name, claude.NewClaudeProvider(
                        claudeConfig.APIKey,
                        claudeConfig.BaseURL,
                        claudeConfig.Models[0].ID,
                ))
        }</span>

        // Register Gemini provider (only if API key is configured)
        <span class="cov10" title="12">geminiConfig := cfg.Providers["gemini"]
        if geminiConfig == nil </span><span class="cov10" title="12">{
                geminiConfig = &amp;ProviderConfig{
                        Name:    "gemini",
                        Type:    "gemini",
                        Enabled: false, // Disabled by default - requires API key
                        Models: []ModelConfig{{
                                ID:      "gemini-pro",
                                Name:    "Gemini Pro",
                                Enabled: true,
                                Weight:  1.0,
                        }},
                }
        }</span>
        <span class="cov10" title="12">if geminiConfig.Enabled &amp;&amp; geminiConfig.APIKey != "" </span><span class="cov0" title="0">{
                r.RegisterProvider(geminiConfig.Name, gemini.NewGeminiProvider(
                        geminiConfig.APIKey,
                        geminiConfig.BaseURL,
                        geminiConfig.Models[0].ID,
                ))
        }</span>

        // Register Qwen provider (only if API key is configured)
        <span class="cov10" title="12">qwenConfig := cfg.Providers["qwen"]
        if qwenConfig == nil </span><span class="cov10" title="12">{
                qwenConfig = &amp;ProviderConfig{
                        Name:    "qwen",
                        Type:    "qwen",
                        Enabled: false, // Disabled by default - requires API key
                        Models: []ModelConfig{{
                                ID:      "qwen-turbo",
                                Name:    "Qwen Turbo",
                                Enabled: true,
                                Weight:  1.0,
                        }},
                }
        }</span>
        <span class="cov10" title="12">if qwenConfig.Enabled &amp;&amp; qwenConfig.APIKey != "" </span><span class="cov0" title="0">{
                r.RegisterProvider(qwenConfig.Name, qwen.NewQwenProvider(
                        qwenConfig.APIKey,
                        qwenConfig.BaseURL,
                        qwenConfig.Models[0].ID,
                ))
        }</span>

        // Register OpenRouter provider (only if API key is configured)
        <span class="cov10" title="12">openrouterConfig := cfg.Providers["openrouter"]
        if openrouterConfig == nil </span><span class="cov10" title="12">{
                openrouterConfig = &amp;ProviderConfig{
                        Name:    "openrouter",
                        Type:    "openrouter",
                        Enabled: false, // Disabled by default - requires API key
                        Models: []ModelConfig{{
                                ID:      "x-ai/grok-4",
                                Name:    "Grok-4 via OpenRouter",
                                Enabled: true,
                                Weight:  1.3,
                        }},
                }
        }</span>
        <span class="cov10" title="12">if openrouterConfig.Enabled &amp;&amp; openrouterConfig.APIKey != "" </span><span class="cov0" title="0">{
                r.RegisterProvider(openrouterConfig.Name, openrouter.NewSimpleOpenRouterProvider(
                        openrouterConfig.APIKey,
                ))
        }</span>
}

func (r *ProviderRegistry) RegisterProvider(name string, provider llm.LLMProvider) error <span class="cov10" title="12">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.providers[name]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("provider %s already registered", name)
        }</span>

        // Wrap provider with circuit breaker if enabled
        <span class="cov9" title="11">var wrappedProvider llm.LLMProvider = provider
        if r.config.CircuitBreaker.Enabled </span><span class="cov4" title="3">{
                cb := NewCircuitBreaker(
                        r.config.CircuitBreaker.FailureThreshold,
                        r.config.CircuitBreaker.SuccessThreshold,
                        r.config.CircuitBreaker.RecoveryTimeout,
                )
                r.circuitBreakers[name] = cb
                wrappedProvider = &amp;circuitBreakerProvider{
                        provider:       provider,
                        circuitBreaker: cb,
                        name:           name,
                }
        }</span>

        <span class="cov9" title="11">r.providers[name] = wrappedProvider

        // Also register with ensemble and request services
        r.ensemble.RegisterProvider(name, &amp;providerAdapter{provider: wrappedProvider})
        r.requestService.RegisterProvider(name, &amp;providerAdapter{provider: wrappedProvider})

        return nil</span>
}

// GetCircuitBreaker returns the circuit breaker for a provider (for internal use)
func (r *ProviderRegistry) GetCircuitBreaker(name string) *CircuitBreaker <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.circuitBreakers[name]
}</span>

func (r *ProviderRegistry) UnregisterProvider(name string) error <span class="cov3" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()

        return r.unregisterProviderLocked(name)
}</span>

// unregisterProviderLocked removes a provider (caller must hold the lock)
func (r *ProviderRegistry) unregisterProviderLocked(name string) error <span class="cov4" title="3">{
        if _, exists := r.providers[name]; !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("provider %s not found", name)
        }</span>

        <span class="cov3" title="2">delete(r.providers, name)
        r.ensemble.RemoveProvider(name)
        r.requestService.RemoveProvider(name)

        return nil</span>
}

func (r *ProviderRegistry) GetProvider(name string) (llm.LLMProvider, error) <span class="cov6" title="5">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        provider, exists := r.providers[name]
        if !exists </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("provider %s not found", name)
        }</span>

        <span class="cov3" title="2">return provider, nil</span>
}

func (r *ProviderRegistry) ListProviders() []string <span class="cov4" title="3">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        names := make([]string, 0, len(r.providers))
        for name := range r.providers </span><span class="cov3" title="2">{
                names = append(names, name)
        }</span>
        <span class="cov4" title="3">return names</span>
}

func (r *ProviderRegistry) GetEnsembleService() *EnsembleService <span class="cov1" title="1">{
        return r.ensemble
}</span>

func (r *ProviderRegistry) GetRequestService() *RequestService <span class="cov1" title="1">{
        return r.requestService
}</span>

func (r *ProviderRegistry) ConfigureProvider(name string, config *ProviderConfig) error <span class="cov3" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()

        provider, exists := r.providers[name]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("provider %s not found", name)
        }</span>

        // Re-register provider with new configuration if needed
        <span class="cov1" title="1">if !config.Enabled </span><span class="cov1" title="1">{
                return r.unregisterProviderLocked(name)
        }</span>

        // For now, we assume provider is already configured
        // In a real implementation, you might need to reinitialize the provider
        <span class="cov0" title="0">_ = provider

        return nil</span>
}

func (r *ProviderRegistry) GetProviderConfig(name string) (*ProviderConfig, error) <span class="cov3" title="2">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // For now, return a basic config
        // In a real implementation, this would return stored configuration
        if _, exists := r.providers[name]; !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("provider %s not found", name)
        }</span>

        <span class="cov1" title="1">return &amp;ProviderConfig{
                Name:    name,
                Enabled: true,
        }, nil</span>
}

func (r *ProviderRegistry) HealthCheck() map[string]error <span class="cov4" title="3">{
        r.mu.RLock()
        providers := make(map[string]llm.LLMProvider)
        for name, provider := range r.providers </span><span class="cov4" title="3">{
                providers[name] = provider
        }</span>
        <span class="cov4" title="3">r.mu.RUnlock()

        results := make(map[string]error)
        var wg sync.WaitGroup
        var mu sync.Mutex

        for name, provider := range providers </span><span class="cov4" title="3">{
                wg.Add(1)
                go func(name string, provider llm.LLMProvider) </span><span class="cov4" title="3">{
                        defer wg.Done()

                        err := provider.HealthCheck()

                        mu.Lock()
                        results[name] = err
                        mu.Unlock()
                }</span>(name, provider)
        }

        <span class="cov4" title="3">wg.Wait()
        return results</span>
}

// providerAdapter adapts llm.LLMProvider to services.LLMProvider interface
type providerAdapter struct {
        provider llm.LLMProvider
}

func (a *providerAdapter) Complete(ctx context.Context, req *models.LLMRequest) (*models.LLMResponse, error) <span class="cov1" title="1">{
        return a.provider.Complete(ctx, req)
}</span>

func (a *providerAdapter) CompleteStream(ctx context.Context, req *models.LLMRequest) (&lt;-chan *models.LLMResponse, error) <span class="cov1" title="1">{
        return a.provider.CompleteStream(ctx, req)
}</span>

func getDefaultRegistryConfig() *RegistryConfig <span class="cov6" title="5">{
        return &amp;RegistryConfig{
                DefaultTimeout: 30 * time.Second,
                MaxRetries:     3,
                HealthCheck: HealthCheckConfig{
                        Enabled:          true,
                        Interval:         60 * time.Second,
                        Timeout:          10 * time.Second,
                        FailureThreshold: 3,
                },
                CircuitBreaker: CircuitBreakerConfig{
                        Enabled:          true,
                        FailureThreshold: 5,
                        RecoveryTimeout:  60 * time.Second,
                        SuccessThreshold: 2,
                },
                Providers: make(map[string]*ProviderConfig),
                Ensemble: &amp;models.EnsembleConfig{
                        Strategy:            "confidence_weighted",
                        MinProviders:        2,
                        ConfidenceThreshold: 0.8,
                        FallbackToBest:      true,
                        Timeout:             30,
                        PreferredProviders:  []string{},
                },
                Routing: &amp;RoutingConfig{
                        Strategy: "weighted",
                        Weights:  make(map[string]float64),
                },
        }
}</span>

// LoadRegistryConfigFromAppConfig converts application config to registry config
func LoadRegistryConfigFromAppConfig(appConfig *config.Config) *RegistryConfig <span class="cov0" title="0">{
        cfg := getDefaultRegistryConfig()

        // Override with application config if provided
        if appConfig != nil </span><span class="cov0" title="0">{
                if appConfig.LLM.DefaultTimeout &gt; 0 </span><span class="cov0" title="0">{
                        cfg.DefaultTimeout = appConfig.LLM.DefaultTimeout
                }</span>

                <span class="cov0" title="0">if appConfig.LLM.MaxRetries &gt; 0 </span><span class="cov0" title="0">{
                        cfg.MaxRetries = appConfig.LLM.MaxRetries
                }</span>
        }

        // Load provider configurations from environment variables
        // Providers are only enabled if their API key is configured

        <span class="cov0" title="0">deepseekKey := os.Getenv("DEEPSEEK_API_KEY")
        cfg.Providers["deepseek"] = &amp;ProviderConfig{
                Name:    "deepseek",
                Type:    "deepseek",
                Enabled: deepseekKey != "",
                Models: []ModelConfig{{
                        ID:      getEnvOrDefault("DEEPSEEK_MODEL", "deepseek-coder"),
                        Name:    "DeepSeek Coder",
                        Enabled: true,
                        Weight:  1.0,
                }},
                APIKey:  deepseekKey,
                BaseURL: os.Getenv("DEEPSEEK_BASE_URL"),
                Timeout: cfg.DefaultTimeout,
                Weight:  1.0,
        }

        claudeKey := os.Getenv("ANTHROPIC_API_KEY")
        cfg.Providers["claude"] = &amp;ProviderConfig{
                Name:    "claude",
                Type:    "claude",
                Enabled: claudeKey != "",
                Models: []ModelConfig{{
                        ID:      getEnvOrDefault("CLAUDE_MODEL", "claude-3-sonnet-20240229"),
                        Name:    "Claude 3 Sonnet",
                        Enabled: true,
                        Weight:  1.0,
                }},
                APIKey:  claudeKey,
                BaseURL: os.Getenv("ANTHROPIC_BASE_URL"),
                Timeout: cfg.DefaultTimeout,
                Weight:  1.0,
        }

        geminiKey := os.Getenv("GEMINI_API_KEY")
        cfg.Providers["gemini"] = &amp;ProviderConfig{
                Name:    "gemini",
                Type:    "gemini",
                Enabled: geminiKey != "",
                Models: []ModelConfig{{
                        ID:      getEnvOrDefault("GEMINI_MODEL", "gemini-pro"),
                        Name:    "Gemini Pro",
                        Enabled: true,
                        Weight:  1.0,
                }},
                APIKey:  geminiKey,
                BaseURL: os.Getenv("GEMINI_BASE_URL"),
                Timeout: cfg.DefaultTimeout,
                Weight:  1.0,
        }

        qwenKey := os.Getenv("QWEN_API_KEY")
        cfg.Providers["qwen"] = &amp;ProviderConfig{
                Name:    "qwen",
                Type:    "qwen",
                Enabled: qwenKey != "",
                Models: []ModelConfig{{
                        ID:      getEnvOrDefault("QWEN_MODEL", "qwen-turbo"),
                        Name:    "Qwen Turbo",
                        Enabled: true,
                        Weight:  1.0,
                }},
                APIKey:  qwenKey,
                BaseURL: os.Getenv("QWEN_BASE_URL"),
                Timeout: cfg.DefaultTimeout,
                Weight:  1.0,
        }

        openrouterKey := os.Getenv("OPENROUTER_API_KEY")
        cfg.Providers["openrouter"] = &amp;ProviderConfig{
                Name:    "openrouter",
                Type:    "openrouter",
                Enabled: openrouterKey != "",
                Models: []ModelConfig{{
                        ID:      getEnvOrDefault("OPENROUTER_MODEL", "x-ai/grok-4"),
                        Name:    "Grok-4 via OpenRouter",
                        Enabled: true,
                        Weight:  1.3,
                }},
                APIKey:  openrouterKey,
                Timeout: cfg.DefaultTimeout,
                Weight:  1.3,
        }

        return cfg</span>
}

// getEnvOrDefault returns the environment variable value or a default
func getEnvOrDefault(key, defaultValue string) string <span class="cov1" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov1" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "context"
        "fmt"
        "math"
        "math/rand"
        "sync"
        "time"

        "github.com/superagent/superagent/internal/models"
)

// RequestService handles LLM request routing and load balancing
type RequestService struct {
        providers map[string]LLMProvider
        ensemble  *EnsembleService
        memory    *MemoryService
        strategy  RoutingStrategy
        mu        sync.RWMutex
}

// RoutingStrategy defines different routing approaches
type RoutingStrategy interface {
        SelectProvider(providers map[string]LLMProvider, req *models.LLMRequest) (string, error)
}

// ProviderHealth tracks health and performance metrics for providers
type ProviderHealth struct {
        Name          string
        Healthy       bool
        LastCheck     time.Time
        ResponseTime  int64   // Average response time in milliseconds
        SuccessRate   float64 // Success rate (0.0 to 1.0)
        ErrorCount    int64
        TotalRequests int64
        LastError     string
        Weight        float64 // Dynamic weight based on performance
        mu            sync.RWMutex
}

// Routing strategies

// RoundRobinStrategy implements round-robin load balancing
type RoundRobinStrategy struct {
        counter int64
        mu      sync.Mutex
}

// WeightedStrategy implements weighted load balancing based on performance
type WeightedStrategy struct{}

// HealthBasedStrategy implements health-based routing
type HealthBasedStrategy struct{}

// LatencyBasedStrategy implements latency-based routing
type LatencyBasedStrategy struct{}

// RandomStrategy implements random provider selection
type RandomStrategy struct{}

func NewRequestService(strategy string, ensemble *EnsembleService, memory *MemoryService) *RequestService <span class="cov6" title="24">{
        var routingStrategy RoutingStrategy

        switch strategy </span>{
        case "round_robin":<span class="cov2" title="2">
                routingStrategy = &amp;RoundRobinStrategy{}</span>
        case "weighted":<span class="cov4" title="12">
                routingStrategy = &amp;WeightedStrategy{}</span>
        case "health_based":<span class="cov1" title="1">
                routingStrategy = &amp;HealthBasedStrategy{}</span>
        case "latency_based":<span class="cov1" title="1">
                routingStrategy = &amp;LatencyBasedStrategy{}</span>
        case "random":<span class="cov4" title="7">
                routingStrategy = &amp;RandomStrategy{}</span>
        default:<span class="cov1" title="1">
                routingStrategy = &amp;WeightedStrategy{}</span> // Default
        }

        <span class="cov6" title="24">return &amp;RequestService{
                providers: make(map[string]LLMProvider),
                ensemble:  ensemble,
                memory:    memory,
                strategy:  routingStrategy,
        }</span>
}

func (r *RequestService) RegisterProvider(name string, provider LLMProvider) <span class="cov5" title="21">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.providers[name] = provider
}</span>

func (r *RequestService) RemoveProvider(name string) <span class="cov2" title="3">{
        r.mu.Lock()
        defer r.mu.Unlock()
        delete(r.providers, name)
}</span>

func (r *RequestService) GetProviders() []string <span class="cov3" title="4">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        names := make([]string, 0, len(r.providers))
        for name := range r.providers </span><span class="cov3" title="6">{
                names = append(names, name)
        }</span>
        <span class="cov3" title="4">return names</span>
}

func (r *RequestService) ProcessRequest(ctx context.Context, req *models.LLMRequest) (*models.LLMResponse, error) <span class="cov0" title="0">{
        r.mu.RLock()
        providers := make(map[string]LLMProvider)
        for k, v := range r.providers </span><span class="cov0" title="0">{
                providers[k] = v
        }</span>
        <span class="cov0" title="0">r.mu.RUnlock()

        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no providers available")
        }</span>

        // Enhance request with memory if enabled
        <span class="cov0" title="0">if r.memory != nil &amp;&amp; req.MemoryEnhanced </span><span class="cov0" title="0">{
                if err := r.memory.EnhanceRequest(ctx, req); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the request
                        fmt.Printf("Memory enhancement failed: %v\n", err)
                }</span>
        }

        // Check if ensemble is requested and we have multiple providers
        <span class="cov0" title="0">if req.EnsembleConfig != nil &amp;&amp; len(providers) &gt;= req.EnsembleConfig.MinProviders </span><span class="cov0" title="0">{
                result, err := r.ensemble.RunEnsemble(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        // Fall back to single provider if ensemble fails
                        return r.processSingleProvider(ctx, req, providers)
                }</span>
                <span class="cov0" title="0">return result.Selected, nil</span>
        }

        // Process with single provider
        <span class="cov0" title="0">return r.processSingleProvider(ctx, req, providers)</span>
}

func (r *RequestService) ProcessRequestStream(ctx context.Context, req *models.LLMRequest) (&lt;-chan *models.LLMResponse, error) <span class="cov0" title="0">{
        r.mu.RLock()
        providers := make(map[string]LLMProvider)
        for k, v := range r.providers </span><span class="cov0" title="0">{
                providers[k] = v
        }</span>
        <span class="cov0" title="0">r.mu.RUnlock()

        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no providers available")
        }</span>

        // Enhance request with memory if enabled
        <span class="cov0" title="0">if r.memory != nil &amp;&amp; req.MemoryEnhanced </span><span class="cov0" title="0">{
                if err := r.memory.EnhanceRequest(ctx, req); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the request
                        fmt.Printf("Memory enhancement failed: %v\n", err)
                }</span>
        }

        // Check if ensemble is requested and we have multiple providers
        <span class="cov0" title="0">if req.EnsembleConfig != nil &amp;&amp; len(providers) &gt;= req.EnsembleConfig.MinProviders </span><span class="cov0" title="0">{
                return r.ensemble.RunEnsembleStream(ctx, req)
        }</span>

        // Process with single provider
        <span class="cov0" title="0">return r.processSingleProviderStream(ctx, req, providers)</span>
}

func (r *RequestService) processSingleProvider(ctx context.Context, req *models.LLMRequest, providers map[string]LLMProvider) (*models.LLMResponse, error) <span class="cov0" title="0">{
        // Select provider based on routing strategy
        providerName, err := r.strategy.SelectProvider(providers, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to select provider: %w", err)
        }</span>

        <span class="cov0" title="0">provider, exists := providers[providerName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selected provider %s not found", providerName)
        }</span>

        // Execute request
        <span class="cov0" title="0">resp, err := provider.Complete(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider %s failed: %w", providerName, err)
        }</span>

        // Add provider metadata
        <span class="cov0" title="0">resp.ProviderID = providerName
        resp.ProviderName = providerName

        return resp, nil</span>
}

func (r *RequestService) processSingleProviderStream(ctx context.Context, req *models.LLMRequest, providers map[string]LLMProvider) (&lt;-chan *models.LLMResponse, error) <span class="cov0" title="0">{
        // Select provider based on routing strategy
        providerName, err := r.strategy.SelectProvider(providers, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to select provider: %w", err)
        }</span>

        <span class="cov0" title="0">provider, exists := providers[providerName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selected provider %s not found", providerName)
        }</span>

        // Execute streaming request
        <span class="cov0" title="0">streamChan, err := provider.CompleteStream(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider %s failed: %w", providerName, err)
        }</span>

        // Wrap responses with provider info
        <span class="cov0" title="0">wrappedChan := make(chan *models.LLMResponse)
        go func() </span><span class="cov0" title="0">{
                defer close(wrappedChan)
                for resp := range streamChan </span><span class="cov0" title="0">{
                        resp.ProviderID = providerName
                        resp.ProviderName = providerName
                        wrappedChan &lt;- resp
                }</span>
        }()

        <span class="cov0" title="0">return wrappedChan, nil</span>
}

// Routing strategy implementations

// RoundRobinStrategy
func (s *RoundRobinStrategy) SelectProvider(providers map[string]LLMProvider, req *models.LLMRequest) (string, error) <span class="cov4" title="7">{
        if len(providers) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no providers available")
        }</span>

        <span class="cov3" title="6">s.mu.Lock()
        defer s.mu.Unlock()

        names := make([]string, 0, len(providers))
        for name := range providers </span><span class="cov5" title="18">{
                names = append(names, name)
        }</span>

        <span class="cov3" title="6">selected := names[s.counter%int64(len(names))]
        s.counter++
        return selected, nil</span>
}

// WeightedStrategy
func (s *WeightedStrategy) SelectProvider(providers map[string]LLMProvider, req *models.LLMRequest) (string, error) <span class="cov8" title="102">{
        if len(providers) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no providers available")
        }</span>

        // For now, use equal weights
        // In a real implementation, you'd track performance and adjust weights
        <span class="cov8" title="101">weights := make(map[string]float64)
        totalWeight := 0.0

        for name := range providers </span><span class="cov9" title="202">{
                weight := 1.0 // Equal weight for all providers
                if req.EnsembleConfig != nil </span><span class="cov9" title="200">{
                        // Apply preference weights
                        for i, preferred := range req.EnsembleConfig.PreferredProviders </span><span class="cov9" title="200">{
                                if name == preferred </span><span class="cov8" title="100">{
                                        weight = 2.0 - float64(i)*0.1 // Higher weight for more preferred providers
                                        break</span>
                                }
                        }
                }
                <span class="cov9" title="202">weights[name] = weight
                totalWeight += weight</span>
        }

        // Select based on weighted random selection
        <span class="cov8" title="101">random := rand.Float64() * totalWeight
        current := 0.0

        for name, weight := range weights </span><span class="cov8" title="140">{
                current += weight
                if random &lt;= current </span><span class="cov8" title="101">{
                        return name, nil
                }</span>
        }

        // Fallback to first provider
        <span class="cov0" title="0">for name := range providers </span><span class="cov0" title="0">{
                return name, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("failed to select provider")</span>
}

// HealthBasedStrategy
func (s *HealthBasedStrategy) SelectProvider(providers map[string]LLMProvider, req *models.LLMRequest) (string, error) <span class="cov2" title="2">{
        if len(providers) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no providers available")
        }</span>

        // Filter healthy providers
        <span class="cov1" title="1">healthyProviders := make([]string, 0)
        for name := range providers </span><span class="cov2" title="2">{
                // In a real implementation, you'd check actual health status
                // For now, assume all providers are healthy
                healthyProviders = append(healthyProviders, name)
        }</span>

        <span class="cov1" title="1">if len(healthyProviders) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no healthy providers available")
        }</span>

        // Select first healthy provider
        <span class="cov1" title="1">return healthyProviders[0], nil</span>
}

// LatencyBasedStrategy
func (s *LatencyBasedStrategy) SelectProvider(providers map[string]LLMProvider, req *models.LLMRequest) (string, error) <span class="cov2" title="2">{
        if len(providers) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no providers available")
        }</span>

        // For now, select randomly
        // In a real implementation, you'd track actual latency metrics
        <span class="cov1" title="1">names := make([]string, 0, len(providers))
        for name := range providers </span><span class="cov2" title="2">{
                names = append(names, name)
        }</span>

        <span class="cov1" title="1">if len(names) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no providers available")
        }</span>

        <span class="cov1" title="1">selected := names[rand.Intn(len(names))]
        return selected, nil</span>
}

// RandomStrategy
func (s *RandomStrategy) SelectProvider(providers map[string]LLMProvider, req *models.LLMRequest) (string, error) <span class="cov8" title="101">{
        if len(providers) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no providers available")
        }</span>

        <span class="cov8" title="100">names := make([]string, 0, len(providers))
        for name := range providers </span><span class="cov10" title="300">{
                names = append(names, name)
        }</span>

        <span class="cov8" title="100">if len(names) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no providers available")
        }</span>

        <span class="cov8" title="100">selected := names[rand.Intn(len(names))]
        return selected, nil</span>
}

// ProviderHealth management

func (r *RequestService) UpdateProviderHealth(name string, healthy bool, responseTime int64, err error) {<span class="cov0" title="0">
        // This would be used to track provider health and performance
        // Implementation would involve maintaining a health registry
}</span>

func (r *RequestService) GetProviderHealth(name string) *ProviderHealth <span class="cov1" title="1">{
        // Return health information for a specific provider
        // Implementation would query the health registry
        return &amp;ProviderHealth{
                Name:         name,
                Healthy:      true,
                LastCheck:    time.Now(),
                ResponseTime: 1000,
                SuccessRate:  0.95,
        }
}</span>

func (r *RequestService) GetAllProviderHealth() map[string]*ProviderHealth <span class="cov1" title="1">{
        // Return health information for all providers
        health := make(map[string]*ProviderHealth)
        r.mu.RLock()
        for name := range r.providers </span><span class="cov2" title="2">{
                health[name] = &amp;ProviderHealth{
                        Name:         name,
                        Healthy:      true,
                        LastCheck:    time.Now(),
                        ResponseTime: 1000,
                        SuccessRate:  0.95,
                }
        }</span>
        <span class="cov1" title="1">r.mu.RUnlock()
        return health</span>
}

// Advanced routing features

// CircuitBreakerPattern implements circuit breaker for failing providers
type CircuitBreakerPattern struct {
        providers map[string]*RequestCircuitBreaker
        mu        sync.RWMutex
}

type RequestCircuitBreaker struct {
        Name             string
        State            RequestCircuitState
        FailureCount     int64
        LastFailTime     time.Time
        SuccessCount     int64
        Timeout          time.Duration
        FailureThreshold int64
        RecoveryTimeout  time.Duration
        mu               sync.RWMutex
}

type RequestCircuitState int

const (
        RequestStateClosed RequestCircuitState = iota
        RequestStateOpen
        RequestStateHalfOpen
)

func NewCircuitBreakerPattern() *CircuitBreakerPattern <span class="cov2" title="2">{
        return &amp;CircuitBreakerPattern{
                providers: make(map[string]*RequestCircuitBreaker),
        }
}</span>

func (c *CircuitBreakerPattern) GetCircuitBreaker(name string) *RequestCircuitBreaker <span class="cov2" title="3">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        cb, exists := c.providers[name]
        if !exists </span><span class="cov2" title="2">{
                cb = &amp;RequestCircuitBreaker{
                        Name:             name,
                        State:            RequestStateClosed,
                        FailureThreshold: 5,
                        Timeout:          60 * time.Second,
                        RecoveryTimeout:  30 * time.Second,
                }
                c.providers[name] = cb
        }</span>

        <span class="cov2" title="3">return cb</span>
}

func (cb *RequestCircuitBreaker) Call(ctx context.Context, operation func() (*models.LLMResponse, error)) (*models.LLMResponse, error) <span class="cov4" title="8">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.State </span>{
        case RequestStateOpen:<span class="cov2" title="2">
                if time.Since(cb.LastFailTime) &gt; cb.RecoveryTimeout </span><span class="cov1" title="1">{
                        cb.State = RequestStateHalfOpen
                }</span> else<span class="cov1" title="1"> {
                        return nil, fmt.Errorf("circuit breaker is open for provider %s", cb.Name)
                }</span>
        case RequestStateHalfOpen:<span class="cov2" title="2">
                // Allow one request through
                resp, err := operation()
                if err != nil </span><span class="cov1" title="1">{
                        cb.FailureCount++
                        cb.LastFailTime = time.Now()
                        cb.State = RequestStateOpen
                        return resp, err
                }</span>
                <span class="cov1" title="1">cb.SuccessCount++
                cb.State = RequestStateClosed
                return resp, nil</span>
        case RequestStateClosed:<span class="cov3" title="4">
                // Normal operation
                resp, err := operation()
                if err != nil </span><span class="cov2" title="3">{
                        cb.FailureCount++
                        if cb.FailureCount &gt;= cb.FailureThreshold </span><span class="cov1" title="1">{
                                cb.State = RequestStateOpen
                                cb.LastFailTime = time.Now()
                        }</span>
                        <span class="cov2" title="3">return resp, err</span>
                }
                <span class="cov1" title="1">cb.SuccessCount++
                return resp, nil</span>
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("unknown circuit breaker state")</span>
}

// RetryPattern implements retry logic with exponential backoff
type RetryPattern struct {
        MaxRetries    int
        InitialDelay  time.Duration
        MaxDelay      time.Duration
        BackoffFactor float64
}

func NewRetryPattern(maxRetries int, initialDelay, maxDelay time.Duration, backoffFactor float64) *RetryPattern <span class="cov3" title="5">{
        return &amp;RetryPattern{
                MaxRetries:    maxRetries,
                InitialDelay:  initialDelay,
                MaxDelay:      maxDelay,
                BackoffFactor: backoffFactor,
        }
}</span>

func (r *RetryPattern) Execute(ctx context.Context, operation func() (*models.LLMResponse, error)) (*models.LLMResponse, error) <span class="cov3" title="4">{
        var lastErr error

        for attempt := 0; attempt &lt;= r.MaxRetries; attempt++ </span><span class="cov4" title="8">{
                resp, err := operation()
                if err == nil </span><span class="cov2" title="2">{
                        return resp, nil
                }</span>

                <span class="cov3" title="6">lastErr = err

                // Don't wait on the last attempt
                if attempt &lt; r.MaxRetries </span><span class="cov3" title="5">{
                        delay := time.Duration(float64(r.InitialDelay) * math.Pow(r.BackoffFactor, float64(attempt)))
                        if delay &gt; r.MaxDelay </span><span class="cov0" title="0">{
                                delay = r.MaxDelay
                        }</span>

                        <span class="cov3" title="5">select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov3" title="4"></span>
                                // Continue to next attempt
                        }
                }
        }

        <span class="cov1" title="1">return nil, lastErr</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "os/exec"
        "strings"
        "time"
)

// SecuritySandbox provides sandboxed execution for tools and plugins
type SecuritySandbox struct {
        allowedCommands        map[string]bool
        timeout                time.Duration
        maxOutputSize          int
        enableContainerization bool
        containerImage         string
        resourceLimits         ResourceLimits
}

// ResourceLimits defines resource constraints
type ResourceLimits struct {
        MaxCPU    string // e.g., "500m"
        MaxMemory string // e.g., "256Mi"
        MaxDisk   string // e.g., "100Mi"
}

// NewSecuritySandbox creates a new security sandbox
func NewSecuritySandbox() *SecuritySandbox <span class="cov8" title="9">{
        return &amp;SecuritySandbox{
                allowedCommands: map[string]bool{
                        "grep":    true,
                        "find":    true,
                        "ls":      true,
                        "cat":     true,
                        "head":    true,
                        "tail":    true,
                        "wc":      true,
                        "sort":    true,
                        "uniq":    true,
                        "python3": true,
                        "node":    true,
                        "go":      true,
                        "rustc":   true,
                        "gcc":     true,
                        "javac":   true,
                },
                timeout:       30 * time.Second,
                maxOutputSize: 1024 * 1024, // 1MB
        }
}</span>

// ExecuteSandboxed executes a command in a sandboxed environment
func (s *SecuritySandbox) ExecuteSandboxed(ctx context.Context, command string, args []string) (*SandboxedResult, error) <span class="cov7" title="8">{
        // Validate command
        if !s.allowedCommands[command] </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("command %s is not allowed", command)
        }</span>

        // Sanitize arguments
        <span class="cov6" title="5">for _, arg := range args </span><span class="cov6" title="5">{
                if strings.Contains(arg, "..") || strings.Contains(arg, "/etc") || strings.Contains(arg, "/proc") </span><span class="cov4" title="3">{
                        return nil, fmt.Errorf("potentially dangerous argument: %s", arg)
                }</span>
        }

        <span class="cov3" title="2">if s.enableContainerization </span><span class="cov0" title="0">{
                return s.executeInContainer(ctx, command, args)
        }</span>

        <span class="cov3" title="2">return s.executeDirectly(ctx, command, args)</span>
}

// executeInContainer executes command in a Docker container
func (s *SecuritySandbox) executeInContainer(ctx context.Context, command string, args []string) (*SandboxedResult, error) <span class="cov0" title="0">{
        // Build docker run command
        dockerArgs := []string{
                "run", "--rm",
                "--cpus", s.resourceLimits.MaxCPU,
                "--memory", s.resourceLimits.MaxMemory,
                "--read-only",
                "--tmpfs", "/tmp",
                "--network", "none",
                s.containerImage,
                command,
        }
        dockerArgs = append(dockerArgs, args...)

        // Check if docker is available
        if _, err := exec.LookPath("docker"); err != nil </span><span class="cov0" title="0">{
                log.Printf("Docker not available, falling back to direct execution")
                return s.executeDirectly(ctx, command, args)
        }</span>

        <span class="cov0" title="0">return s.executeDirectly(ctx, "docker", dockerArgs)</span>
}

// executeDirectly executes command directly with resource monitoring
func (s *SecuritySandbox) executeDirectly(ctx context.Context, command string, args []string) (*SandboxedResult, error) <span class="cov3" title="2">{
        // Prepare execution context with timeout
        execCtx, cancel := context.WithTimeout(ctx, s.timeout)
        defer cancel()

        cmd := exec.CommandContext(execCtx, command, args...)

        // Capture output
        var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Run command
        err := cmd.Run()

        result := &amp;SandboxedResult{
                Command: command,
                Args:    args,
                Success: err == nil,
        }

        if err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
                result.Output = stderr.String()
        }</span> else<span class="cov3" title="2"> {
                // Limit output size
                output := stdout.String()
                if len(output) &gt; s.maxOutputSize </span><span class="cov0" title="0">{
                        output = output[:s.maxOutputSize]
                        result.Truncated = true
                }</span>
                <span class="cov3" title="2">result.Output = output</span>
        }

        <span class="cov3" title="2">return result, nil</span>
}

// ValidateToolExecution validates tool execution parameters
func (s *SecuritySandbox) ValidateToolExecution(toolName string, params map[string]interface{}) error <span class="cov6" title="5">{
        // Check for dangerous parameters
        for key, value := range params </span><span class="cov8" title="9">{
                if str, ok := value.(string); ok </span><span class="cov5" title="4">{
                        if strings.Contains(str, ";") || strings.Contains(str, "|") || strings.Contains(str, "`") </span><span class="cov4" title="3">{
                                return fmt.Errorf("potentially dangerous parameter %s: %s", key, str)
                        }</span>
                }
        }

        <span class="cov3" title="2">return nil</span>
}

// SandboxedResult represents the result of a sandboxed execution
type SandboxedResult struct {
        Command   string   `json:"command"`
        Args      []string `json:"args"`
        Output    string   `json:"output,omitempty"`
        Error     string   `json:"error,omitempty"`
        Success   bool     `json:"success"`
        Truncated bool     `json:"truncated,omitempty"`
}

// PerformanceMonitor monitors system performance
type PerformanceMonitor struct {
        metrics map[string]*PerformanceMetric
}

// PerformanceMetric represents a performance metric
type PerformanceMetric struct {
        Name      string
        Value     float64
        Timestamp time.Time
        Labels    map[string]string
}

// NewPerformanceMonitor creates a new performance monitor
func NewPerformanceMonitor() *PerformanceMonitor <span class="cov7" title="8">{
        return &amp;PerformanceMonitor{
                metrics: make(map[string]*PerformanceMetric),
        }
}</span>

// RecordMetric records a performance metric
func (pm *PerformanceMonitor) RecordMetric(name string, value float64, labels map[string]string) <span class="cov10" title="16">{
        pm.metrics[name] = &amp;PerformanceMetric{
                Name:      name,
                Value:     value,
                Timestamp: time.Now(),
                Labels:    labels,
        }
}</span>

// GetMetric retrieves a performance metric
func (pm *PerformanceMonitor) GetMetric(name string) (*PerformanceMetric, bool) <span class="cov6" title="5">{
        metric, exists := pm.metrics[name]
        return metric, exists
}</span>

// GetAllMetrics returns all performance metrics
func (pm *PerformanceMonitor) GetAllMetrics() map[string]*PerformanceMetric <span class="cov1" title="1">{
        result := make(map[string]*PerformanceMetric)
        for k, v := range pm.metrics </span><span class="cov4" title="3">{
                result[k] = v
        }</span>
        <span class="cov1" title="1">return result</span>
}

// MonitorExecution monitors the execution of a function
func (pm *PerformanceMonitor) MonitorExecution(name string, fn func() error) error <span class="cov6" title="6">{
        start := time.Now()
        err := fn()
        duration := time.Since(start).Seconds()

        pm.RecordMetric(name+"_duration", duration, map[string]string{"operation": name})

        if err != nil </span><span class="cov3" title="2">{
                pm.RecordMetric(name+"_errors", 1, map[string]string{"operation": name, "error": err.Error()})
        }</span> else<span class="cov5" title="4"> {
                pm.RecordMetric(name+"_success", 1, map[string]string{"operation": name})
        }</span>

        <span class="cov6" title="6">return err</span>
}

// TestingFramework provides comprehensive testing utilities
type TestingFramework struct {
        sandbox   *SecuritySandbox
        monitor   *PerformanceMonitor
        testCases map[string]*TestCase
}

// TestCase represents a test case
type TestCase struct {
        Name        string
        Description string
        Function    func() error
        Expected    interface{}
        Actual      interface{}
        Passed      bool
        Duration    time.Duration
        Error       error
}

// NewTestingFramework creates a new testing framework
func NewTestingFramework() *TestingFramework <span class="cov5" title="4">{
        return &amp;TestingFramework{
                sandbox:   NewSecuritySandbox(),
                monitor:   NewPerformanceMonitor(),
                testCases: make(map[string]*TestCase),
        }
}</span>

// AddTestCase adds a test case
func (tf *TestingFramework) AddTestCase(name, description string, fn func() error) <span class="cov6" title="5">{
        tf.testCases[name] = &amp;TestCase{
                Name:        name,
                Description: description,
                Function:    fn,
        }
}</span>

// RunTests runs all test cases
func (tf *TestingFramework) RunTests(ctx context.Context) *TestResults <span class="cov3" title="2">{
        results := &amp;TestResults{
                Total:     len(tf.testCases),
                Passed:    0,
                Failed:    0,
                StartTime: time.Now(),
        }

        for name, testCase := range tf.testCases </span><span class="cov5" title="4">{
                start := time.Now()

                err := tf.monitor.MonitorExecution("test_"+name, testCase.Function)

                testCase.Duration = time.Since(start)
                testCase.Error = err

                if err != nil </span><span class="cov1" title="1">{
                        testCase.Passed = false
                        results.Failed++
                        results.Errors = append(results.Errors, TestError{
                                TestName: name,
                                Error:    err.Error(),
                        })
                }</span> else<span class="cov4" title="3"> {
                        testCase.Passed = true
                        results.Passed++
                }</span>
        }

        <span class="cov3" title="2">results.EndTime = time.Now()
        results.Duration = results.EndTime.Sub(results.StartTime)

        return results</span>
}

// TestResults represents the results of running tests
type TestResults struct {
        Total     int           `json:"total"`
        Passed    int           `json:"passed"`
        Failed    int           `json:"failed"`
        Errors    []TestError   `json:"errors,omitempty"`
        StartTime time.Time     `json:"start_time"`
        EndTime   time.Time     `json:"end_time"`
        Duration  time.Duration `json:"duration"`
}

// TestError represents a test error
type TestError struct {
        TestName string `json:"test_name"`
        Error    string `json:"error"`
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"
)

// Tool represents a unified tool interface
type Tool interface {
        Name() string
        Description() string
        Parameters() map[string]interface{}
        Execute(ctx context.Context, params map[string]interface{}) (interface{}, error)
        Source() string // "mcp", "lsp", "custom", etc.
}

// ToolRegistry manages tools from various sources
type ToolRegistry struct {
        mu          sync.RWMutex
        tools       map[string]Tool
        mcpManager  *MCPManager
        lspClient   *LSPClient
        customTools map[string]Tool
        lastRefresh time.Time
}

// NewToolRegistry creates a new tool registry
func NewToolRegistry(mcpManager *MCPManager, lspClient *LSPClient) *ToolRegistry <span class="cov7" title="8">{
        return &amp;ToolRegistry{
                tools:       make(map[string]Tool),
                mcpManager:  mcpManager,
                lspClient:   lspClient,
                customTools: make(map[string]Tool),
        }
}</span>

// RegisterCustomTool registers a custom tool with validation
func (tr *ToolRegistry) RegisterCustomTool(tool Tool) error <span class="cov9" title="19">{
        tr.mu.Lock()
        defer tr.mu.Unlock()

        name := tool.Name()
        if _, exists := tr.tools[name]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("tool %s already registered", name)
        }</span>

        // Validate tool metadata
        <span class="cov9" title="18">if err := tr.validateToolMetadata(tool); err != nil </span><span class="cov5" title="5">{
                return fmt.Errorf("tool validation failed: %w", err)
        }</span>

        <span class="cov8" title="13">tr.tools[name] = tool
        tr.customTools[name] = tool
        return nil</span>
}

// validateToolMetadata validates tool metadata
func (tr *ToolRegistry) validateToolMetadata(tool Tool) error <span class="cov10" title="21">{
        if tool.Name() == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("tool name cannot be empty")
        }</span>

        <span class="cov9" title="20">if tool.Description() == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("tool description cannot be empty")
        }</span>

        <span class="cov9" title="19">params := tool.Parameters()
        if params == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("tool parameters cannot be nil")
        }</span>

        // Validate parameter schemas
        <span class="cov9" title="18">for paramName, paramSchema := range params </span><span class="cov9" title="18">{
                if err := tr.validateParameterSchema(paramName, paramSchema); err != nil </span><span class="cov3" title="2">{
                        return err
                }</span>
        }

        <span class="cov9" title="16">return nil</span>
}

// validateParameterSchema validates a parameter schema
func (tr *ToolRegistry) validateParameterSchema(name string, schema interface{}) error <span class="cov9" title="18">{
        // Basic validation - can be enhanced with JSON Schema validation
        schemaMap, ok := schema.(map[string]interface{})
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("parameter %s schema must be a map", name)
        }</span>

        <span class="cov9" title="17">if _, hasType := schemaMap["type"]; !hasType </span><span class="cov1" title="1">{
                return fmt.Errorf("parameter %s schema must have a type", name)
        }</span>

        <span class="cov9" title="16">return nil</span>
}

// RegisterExternalToolSource registers tools from an external source
func (tr *ToolRegistry) RegisterExternalToolSource(sourceName string, toolFetcher func() ([]Tool, error)) error <span class="cov4" title="3">{
        tr.mu.Lock()
        defer tr.mu.Unlock()

        tools, err := toolFetcher()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to fetch tools from %s: %w", sourceName, err)
        }</span>

        <span class="cov3" title="2">for _, tool := range tools </span><span class="cov5" title="4">{
                name := tool.Name()
                if _, exists := tr.tools[name]; exists </span><span class="cov1" title="1">{
                        log.Printf("Tool %s from %s already exists, skipping", name, sourceName)
                        continue</span>
                }

                <span class="cov4" title="3">if err := tr.validateToolMetadata(tool); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Tool %s from %s validation failed: %v, skipping", name, sourceName, err)
                        continue</span>
                }

                <span class="cov4" title="3">tr.tools[name] = tool
                log.Printf("Registered tool %s from external source %s", name, sourceName)</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// RefreshTools refreshes tools from all sources
func (tr *ToolRegistry) RefreshTools(ctx context.Context) error <span class="cov3" title="2">{
        tr.mu.Lock()
        defer tr.mu.Unlock()

        // Clear existing tools except custom ones
        for name, tool := range tr.tools </span><span class="cov3" title="2">{
                if tool.Source() != "custom" </span><span class="cov0" title="0">{
                        delete(tr.tools, name)
                }</span>
        }

        // Add MCP tools
        <span class="cov3" title="2">if tr.mcpManager != nil </span><span class="cov0" title="0">{
                mcpTools := tr.mcpManager.ListTools()
                for _, mcpTool := range mcpTools </span><span class="cov0" title="0">{
                        wrapper := &amp;MCPToolWrapper{
                                mcpTool:    mcpTool,
                                mcpManager: tr.mcpManager,
                        }
                        tr.tools[mcpTool.Name] = wrapper
                }</span>
        }

        // Add LSP-based tools (code actions)
        <span class="cov3" title="2">if tr.lspClient != nil </span>{<span class="cov0" title="0">
                // LSP tools would be added here when implemented
        }</span>

        <span class="cov3" title="2">tr.lastRefresh = time.Now()
        return nil</span>
}

// GetTool returns a tool by name
func (tr *ToolRegistry) GetTool(name string) (Tool, bool) <span class="cov8" title="13">{
        tr.mu.RLock()
        defer tr.mu.RUnlock()

        tool, exists := tr.tools[name]
        return tool, exists
}</span>

// ListTools returns all available tools
func (tr *ToolRegistry) ListTools() []Tool <span class="cov4" title="3">{
        tr.mu.RLock()
        defer tr.mu.RUnlock()

        tools := make([]Tool, 0, len(tr.tools))
        for _, tool := range tr.tools </span><span class="cov5" title="5">{
                tools = append(tools, tool)
        }</span>
        <span class="cov4" title="3">return tools</span>
}

// ExecuteTool safely executes a tool with sandboxing
func (tr *ToolRegistry) ExecuteTool(ctx context.Context, name string, params map[string]interface{}) (interface{}, error) <span class="cov6" title="7">{
        tool, exists := tr.GetTool(name)
        if !exists </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("tool %s not found", name)
        }</span>

        // Basic parameter validation
        <span class="cov5" title="4">if err := tr.validateParameters(tool, params); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        // Execute with timeout
        <span class="cov4" title="3">execCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        result, err := tool.Execute(execCtx, params)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("tool execution failed: %w", err)
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// validateParameters performs basic parameter validation
func (tr *ToolRegistry) validateParameters(tool Tool, params map[string]interface{}) error <span class="cov5" title="4">{
        // Basic validation - could be enhanced
        required := tool.Parameters()
        for key := range required </span><span class="cov5" title="4">{
                if _, exists := params[key]; !exists </span><span class="cov1" title="1">{
                        return fmt.Errorf("missing required parameter: %s", key)
                }</span>
        }
        <span class="cov4" title="3">return nil</span>
}

// MCPToolWrapper wraps MCP tools to implement the Tool interface
type MCPToolWrapper struct {
        mcpTool    *MCPTool
        mcpManager *MCPManager
}

func (w *MCPToolWrapper) Name() string <span class="cov1" title="1">{
        return w.mcpTool.Name
}</span>

func (w *MCPToolWrapper) Description() string <span class="cov1" title="1">{
        return w.mcpTool.Description
}</span>

func (w *MCPToolWrapper) Parameters() map[string]interface{} <span class="cov1" title="1">{
        return w.mcpTool.InputSchema
}</span>

func (w *MCPToolWrapper) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        return w.mcpManager.CallTool(ctx, w.mcpTool.Name, params)
}</span>

func (w *MCPToolWrapper) Source() string <span class="cov1" title="1">{
        return "mcp"
}</span>

// LSPToolWrapper would wrap LSP-based tools (code actions, etc.)
// Implementation would be added when LSP tools are implemented
</pre>
		
		<pre class="file" id="file37" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/superagent/superagent/internal/database"
)

// ProtocolManagerInterface defines the interface for protocol managers
type ProtocolManagerInterface interface {
        ExecuteRequest(ctx context.Context, req UnifiedProtocolRequest) (UnifiedProtocolResponse, error)
        ListServers(ctx context.Context) (map[string]interface{}, error)
        GetMetrics(ctx context.Context) (map[string]interface{}, error)
        RefreshAll(ctx context.Context) error
        ConfigureProtocols(ctx context.Context, config map[string]interface{}) error
}

// UnifiedProtocolManager manages all protocol operations (MCP, LSP, ACP, Embeddings)
type UnifiedProtocolManager struct {
        mcpManager       *MCPManager
        lspManager       *LSPManager
        acpManager       *ACPManager
        embeddingManager *EmbeddingManager
        cache            CacheInterface
        monitor          *ProtocolMonitor
        security         *ProtocolSecurity
        rateLimiter      *RateLimiter
        repo             *database.ModelMetadataRepository
        log              *logrus.Logger
}

// UnifiedProtocolRequest represents a request to any protocol
type UnifiedProtocolRequest struct {
        ProtocolType string                 `json:"protocolType"` // "mcp", "lsp", "acp", "embedding"
        ServerID     string                 `json:"serverId"`
        ToolName     string                 `json:"toolName"`
        Arguments    map[string]interface{} `json:"arguments"`
}

// UnifiedProtocolResponse represents a response from any protocol
type UnifiedProtocolResponse struct {
        Success   bool        `json:"success"`
        Result    interface{} `json:"result,omitempty"`
        Error     string      `json:"error,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
        Protocol  string      `json:"protocol"`
}

// NewUnifiedProtocolManager creates a new unified protocol manager
func NewUnifiedProtocolManager(
        repo *database.ModelMetadataRepository,
        cache CacheInterface,
        log *logrus.Logger,
) *UnifiedProtocolManager <span class="cov10" title="14">{
        monitor := NewProtocolMonitor(log)
        security := NewProtocolSecurity(log)

        // Initialize default security
        security.InitializeDefaultSecurity()

        return &amp;UnifiedProtocolManager{
                mcpManager:       NewMCPManager(repo, cache, log),
                lspManager:       NewLSPManager(repo, cache, log),
                acpManager:       NewACPManager(repo, cache, log),
                embeddingManager: NewEmbeddingManager(repo, cache, log),
                cache:            cache,
                monitor:          monitor,
                security:         security,
                rateLimiter:      NewRateLimiter(100), // 100 requests per minute
                repo:             repo,
                log:              log,
        }
}</span>

// ExecuteRequest executes a request on the appropriate protocol
func (u *UnifiedProtocolManager) ExecuteRequest(ctx context.Context, req UnifiedProtocolRequest) (UnifiedProtocolResponse, error) <span class="cov7" title="7">{
        startTime := time.Now()

        u.log.WithFields(logrus.Fields{
                "protocol": req.ProtocolType,
                "serverId": req.ServerID,
                "toolName": req.ToolName,
        }).Info("Executing unified protocol request")

        response := UnifiedProtocolResponse{
                Timestamp: time.Now(),
                Protocol:  req.ProtocolType,
                Success:   false,
        }

        // Extract API key from context (would be set by middleware)
        apiKey := extractAPIKeyFromContext(ctx)
        if apiKey == "" </span><span class="cov1" title="1">{
                response.Error = "API key required"
                u.recordMetrics(req.ProtocolType, time.Since(startTime), false)
                return response, fmt.Errorf("API key required")
        }</span>

        // Rate limiting
        <span class="cov7" title="6">if !u.rateLimiter.Allow(apiKey) </span><span class="cov1" title="1">{
                response.Error = "Rate limit exceeded"
                u.recordMetrics(req.ProtocolType, time.Since(startTime), false)
                u.log.WithField("apiKey", apiKey[:8]+"...").Warn("Rate limit exceeded")
                return response, fmt.Errorf("rate limit exceeded")
        }</span>

        // Security check
        <span class="cov6" title="5">if err := u.security.ValidateProtocolAccess(ctx, apiKey, req.ProtocolType, "execute", req.ServerID); err != nil </span><span class="cov1" title="1">{
                response.Error = err.Error()
                u.recordMetrics(req.ProtocolType, time.Since(startTime), false)
                return response, err
        }</span>

        <span class="cov5" title="4">switch req.ProtocolType </span>{
        case "mcp":<span class="cov1" title="1">
                mcpResp, err := u.mcpManager.ExecuteMCPTool(ctx, req)
                if err != nil </span><span class="cov1" title="1">{
                        response.Error = err.Error()
                        return response, err
                }</span>

                <span class="cov0" title="0">response.Success = true
                response.Result = mcpResp</span>

        case "acp":<span class="cov1" title="1">
                acpResp, err := u.acpManager.ExecuteACPAction(ctx, ACPRequest{
                        ServerID:   req.ServerID,
                        Action:     req.ToolName,
                        Parameters: req.Arguments,
                })
                if err != nil </span><span class="cov0" title="0">{
                        response.Error = err.Error()
                        return response, err
                }</span>

                <span class="cov1" title="1">response.Success = true
                response.Result = acpResp</span>

        case "lsp":<span class="cov1" title="1">
                // LSP requests need more specific handling
                // For now, return a placeholder response
                response.Success = true
                response.Result = fmt.Sprintf("LSP request %s executed on server %s", req.ToolName, req.ServerID)</span>

        case "embedding":<span class="cov1" title="1">
                // Generate embeddings for the input text
                text, ok := req.Arguments["text"].(string)
                if !ok </span><span class="cov0" title="0">{
                        err := fmt.Errorf("text argument is required for embedding requests")
                        response.Error = err.Error()
                        return response, err
                }</span>

                <span class="cov1" title="1">embeddingResp, err := u.embeddingManager.GenerateEmbedding(ctx, text)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error = err.Error()
                        return response, err
                }</span>

                <span class="cov1" title="1">response.Success = true
                response.Result = embeddingResp</span>

        default:<span class="cov0" title="0">
                err := fmt.Errorf("unsupported protocol type: %s", req.ProtocolType)
                response.Error = err.Error()
                u.recordMetrics(req.ProtocolType, time.Since(startTime), false)
                return response, err</span>
        }

        <span class="cov4" title="3">u.recordMetrics(req.ProtocolType, time.Since(startTime), response.Success)

        u.log.WithFields(logrus.Fields{
                "protocol": req.ProtocolType,
                "success":  response.Success,
        }).Info("Protocol request completed")

        return response, nil</span>
}

// ListServers lists all servers for all protocols
func (u *UnifiedProtocolManager) ListServers(ctx context.Context) (map[string]interface{}, error) <span class="cov1" title="1">{
        servers := make(map[string]interface{})

        // Get MCP servers
        mcpServers, err := u.mcpManager.ListMCPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to list MCP servers")
        }</span> else<span class="cov1" title="1"> {
                servers["mcp"] = mcpServers
        }</span>

        // Get LSP servers
        <span class="cov1" title="1">lspServers, err := u.lspManager.ListLSPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to list LSP servers")
        }</span> else<span class="cov1" title="1"> {
                servers["lsp"] = lspServers
        }</span>

        // Get ACP servers
        <span class="cov1" title="1">acpServers, err := u.acpManager.ListACPServers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to list ACP servers")
        }</span> else<span class="cov1" title="1"> {
                servers["acp"] = acpServers
        }</span>

        // Get embedding providers
        <span class="cov1" title="1">embeddingProviders, err := u.embeddingManager.ListEmbeddingProviders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to list embedding providers")
        }</span> else<span class="cov1" title="1"> {
                servers["embedding"] = embeddingProviders
        }</span>

        <span class="cov1" title="1">return servers, nil</span>
}

// GetMetrics returns metrics for all protocols
func (u *UnifiedProtocolManager) GetMetrics(ctx context.Context) (map[string]interface{}, error) <span class="cov1" title="1">{
        metrics := make(map[string]interface{})

        // Get MCP metrics
        mcpStats, err := u.mcpManager.GetMCPStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to get MCP stats")
                metrics["mcp"] = map[string]interface{}{"error": err.Error()}
        }</span> else<span class="cov1" title="1"> {
                metrics["mcp"] = mcpStats
        }</span>

        // Get LSP metrics
        <span class="cov1" title="1">lspStats, err := u.lspManager.GetLSPStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to get LSP stats")
                metrics["lsp"] = map[string]interface{}{"error": err.Error()}
        }</span> else<span class="cov1" title="1"> {
                metrics["lsp"] = lspStats
        }</span>

        // Get ACP metrics
        <span class="cov1" title="1">acpStats, err := u.acpManager.GetACPStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to get ACP stats")
                metrics["acp"] = map[string]interface{}{"error": err.Error()}
        }</span> else<span class="cov1" title="1"> {
                metrics["acp"] = acpStats
        }</span>

        // Get Embedding metrics
        <span class="cov1" title="1">embeddingStats, err := u.embeddingManager.GetEmbeddingStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                u.log.WithError(err).Error("Failed to get embedding stats")
                metrics["embedding"] = map[string]interface{}{"error": err.Error()}
        }</span> else<span class="cov1" title="1"> {
                metrics["embedding"] = embeddingStats
        }</span>

        // Add overall metrics
        <span class="cov1" title="1">metrics["overall"] = map[string]interface{}{
                "totalProtocols": 4,
                "activeRequests": 0,
                "cacheSize":      0,
        }

        u.log.Info("Retrieved unified protocol metrics")
        return metrics, nil</span>
}

// RefreshAll refreshes all protocol servers
func (u *UnifiedProtocolManager) RefreshAll(ctx context.Context) error <span class="cov1" title="1">{
        u.log.Info("Refreshing all protocol servers")

        // Refresh MCP servers
        _ = u.mcpManager.SyncMCPServer(ctx, "all")

        // Refresh LSP servers
        _ = u.lspManager.RefreshAllLSPServers(ctx)

        // Refresh ACP servers
        _ = u.acpManager.SyncACPServer(ctx, "all")

        // Refresh embeddings provider
        _ = u.embeddingManager.RefreshAllEmbeddings(ctx)

        u.log.Info("All protocol servers refreshed")
        return nil
}</span>

// ConfigureProtocols configures protocol servers based on configuration
func (u *UnifiedProtocolManager) ConfigureProtocols(ctx context.Context, config map[string]interface{}) error <span class="cov1" title="1">{
        u.log.Info("Configuring protocol servers")

        // In a real implementation, this would:
        // 1. Parse configuration
        // 2. Configure each protocol manager
        // 3. Start/stop servers as needed

        u.log.WithFields(logrus.Fields{
                "configured_protocols": config,
        }).Info("Protocol servers configured")

        return nil
}</span>

// GetMonitor returns the protocol monitor
func (u *UnifiedProtocolManager) GetMonitor() *ProtocolMonitor <span class="cov1" title="1">{
        return u.monitor
}</span>

// GetSecurity returns the protocol security manager
func (u *UnifiedProtocolManager) GetSecurity() *ProtocolSecurity <span class="cov7" title="7">{
        return u.security
}</span>

// Private methods

func (u *UnifiedProtocolManager) recordMetrics(protocol string, duration time.Duration, success bool) <span class="cov7" title="6">{
        if u.monitor != nil </span><span class="cov7" title="6">{
                u.monitor.RecordRequest(context.Background(), protocol, duration, success, "")
        }</span>
}

func extractAPIKeyFromContext(ctx context.Context) string <span class="cov7" title="7">{
        // Extract API key from context (would be set by middleware)
        if apiKey, ok := ctx.Value("api_key").(string); ok </span><span class="cov7" title="6">{
                return apiKey
        }</span>
        <span class="cov1" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package services

import (
        "context"
        "crypto/rand"
        "crypto/subtle"
        "encoding/hex"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/superagent/superagent/internal/database"
        "github.com/superagent/superagent/internal/models"
        "golang.org/x/crypto/argon2"
)

// UserService handles user management and authentication
type UserService struct {
        db        *database.PostgresDB
        jwtSecret string
        jwtExpiry time.Duration
}

// User represents a user in the system
type User struct {
        ID        int       `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Role      string    `json:"role"`
        APIKey    string    `json:"api_key"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
}

// RegisterRequest represents a user registration request
type RegisterRequest struct {
        Username string `json:"username" binding:"required,min=3,max=50"`
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=8"`
}

// AuthResponse represents an authentication response
type AuthResponse struct {
        Token     string    `json:"token"`
        User      User      `json:"user"`
        ExpiresAt time.Time `json:"expires_at"`
}

// NewUserService creates a new user service
func NewUserService(db *database.PostgresDB, jwtSecret string, jwtExpiry time.Duration) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                db:        db,
                jwtSecret: jwtSecret,
                jwtExpiry: jwtExpiry,
        }
}</span>

// Register creates a new user account
func (u *UserService) Register(ctx context.Context, req *RegisterRequest) (*User, error) <span class="cov0" title="0">{
        // Check if username already exists
        var existingID int
        err := u.db.QueryRow("SELECT id FROM users WHERE username = $1 OR email = $2", req.Username, req.Email).Scan(&amp;existingID)
        if err == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("username or email already exists")
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>

        // Hash the password
        <span class="cov0" title="0">passwordHash, err := u.hashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Generate API key
        <span class="cov0" title="0">apiKey, err := u.generateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate API key: %w", err)
        }</span>

        // Insert user
        <span class="cov0" title="0">var userID int
        err = u.db.QueryRow(`
                INSERT INTO users (username, email, password_hash, api_key, role, created_at, updated_at)
                VALUES ($1, $2, $3, $4, 'user', NOW(), NOW())
                RETURNING id
        `, req.Username, req.Email, passwordHash, apiKey).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Return user info
        <span class="cov0" title="0">user := &amp;User{
                ID:       userID,
                Username: req.Username,
                Email:    req.Email,
                Role:     "user",
                APIKey:   apiKey,
        }

        return user, nil</span>
}

// Authenticate validates user credentials and returns user info
func (u *UserService) Authenticate(ctx context.Context, username, password string) (*User, error) <span class="cov0" title="0">{
        var user User
        var passwordHash string

        err := u.db.QueryRow(`
                SELECT id, username, email, password_hash, api_key, role, created_at, updated_at
                FROM users
                WHERE username = $1
        `, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;passwordHash,
                &amp;user.APIKey, &amp;user.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid username or password")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to authenticate user: %w", err)</span>
        }

        // Verify password
        <span class="cov0" title="0">if !u.verifyPassword(password, passwordHash) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid username or password")
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// AuthenticateByAPIKey validates an API key and returns user info
func (u *UserService) AuthenticateByAPIKey(ctx context.Context, apiKey string) (*User, error) <span class="cov0" title="0">{
        var user User

        err := u.db.QueryRow(`
                SELECT id, username, email, api_key, role, created_at, updated_at
                FROM users
                WHERE api_key = $1
        `, apiKey).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.APIKey,
                &amp;user.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid API key")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to authenticate API key: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByID retrieves a user by ID
func (u *UserService) GetUserByID(ctx context.Context, userID int) (*User, error) <span class="cov0" title="0">{
        var user User

        err := u.db.QueryRow(`
                SELECT id, username, email, api_key, role, created_at, updated_at
                FROM users
                WHERE id = $1
        `, userID).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.APIKey,
                &amp;user.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UpdateUser updates user information
func (u *UserService) UpdateUser(ctx context.Context, userID int, updates map[string]interface{}) (*User, error) <span class="cov0" title="0">{
        // Build dynamic update query
        setParts := []string{}
        args := []interface{}{}
        argCount := 1

        for field, value := range updates </span><span class="cov0" title="0">{
                switch field </span>{
                case "email", "role":<span class="cov0" title="0">
                        setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argCount))
                        args = append(args, value)
                        argCount++</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("field %s cannot be updated", field)</span>
                }
        }

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid fields to update")
        }</span>

        <span class="cov0" title="0">setParts = append(setParts, "updated_at = NOW()")
        query := fmt.Sprintf("UPDATE users SET %s WHERE id = $%d", strings.Join(setParts, ", "), argCount)
        args = append(args, userID)

        err := u.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        // Return updated user
        <span class="cov0" title="0">return u.GetUserByID(ctx, userID)</span>
}

// ChangePassword changes a user's password
func (u *UserService) ChangePassword(ctx context.Context, userID int, oldPassword, newPassword string) error <span class="cov0" title="0">{
        // Verify old password
        var passwordHash string
        err := u.db.QueryRow("SELECT password_hash FROM users WHERE id = $1", userID).Scan(&amp;passwordHash)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to verify password: %w", err)</span>
        }

        <span class="cov0" title="0">if !u.verifyPassword(oldPassword, passwordHash) </span><span class="cov0" title="0">{
                return fmt.Errorf("current password is incorrect")
        }</span>

        // Hash new password
        <span class="cov0" title="0">newHash, err := u.hashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash new password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = u.db.Exec(`
                UPDATE users
                SET password_hash = $1, updated_at = NOW()
                WHERE id = $2
        `, newHash, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RegenerateAPIKey generates a new API key for a user
func (u *UserService) RegenerateAPIKey(ctx context.Context, userID int) (string, error) <span class="cov0" title="0">{
        // Generate new API key
        newAPIKey, err := u.generateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate API key: %w", err)
        }</span>

        // Update in database
        <span class="cov0" title="0">err = u.db.Exec(`
                UPDATE users
                SET api_key = $1, updated_at = NOW()
                WHERE id = $2
        `, newAPIKey, userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to update API key: %w", err)
        }</span>

        <span class="cov0" title="0">return newAPIKey, nil</span>
}

// DeleteUser deletes a user account
func (u *UserService) DeleteUser(ctx context.Context, userID int) error <span class="cov0" title="0">{
        err := u.db.Exec("DELETE FROM users WHERE id = $1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// hashPassword hashes a password using Argon2
func (u *UserService) hashPassword(password string) (string, error) <span class="cov0" title="0">{
        // Argon2 parameters
        salt := make([]byte, 32)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)

        // Format: $argon2id$v=19$m=65536,t=1,p=4$salt$hash
        saltHex := hex.EncodeToString(salt)
        hashHex := hex.EncodeToString(hash)

        return fmt.Sprintf("$argon2id$v=19$m=65536,t=1,p=4$%s$%s", saltHex, hashHex), nil</span>
}

// verifyPassword verifies a password against a hash
func (u *UserService) verifyPassword(password, hash string) bool <span class="cov0" title="0">{
        parts := strings.Split(hash, "$")
        if len(parts) != 6 || parts[1] != "argon2id" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">salt, err := hex.DecodeString(parts[4])
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">expectedHash, err := hex.DecodeString(parts[5])
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">computedHash := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)

        return subtle.ConstantTimeCompare(computedHash, expectedHash) == 1</span>
}

// generateAPIKey generates a secure API key
func (u *UserService) generateAPIKey() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return "sk-" + hex.EncodeToString(bytes), nil</span>
}

// CreateSession creates a new user session
func (u *UserService) CreateSession(ctx context.Context, userID int, metadata map[string]interface{}) (*models.UserSession, error) <span class="cov0" title="0">{
        sessionToken, err := u.generateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate session token: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(u.jwtExpiry)

        var sessionID string
        err = u.db.QueryRow(`
                INSERT INTO user_sessions (user_id, session_token, expires_at, metadata, created_at, last_activity)
                VALUES ($1, $2, $3, $4, NOW(), NOW())
                RETURNING id
        `, userID, sessionToken, expiresAt, metadata).Scan(&amp;sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov0" title="0">session := &amp;models.UserSession{
                ID:           sessionID,
                UserID:       fmt.Sprintf("%d", userID),
                SessionToken: sessionToken,
                Context:      metadata,
                ExpiresAt:    expiresAt,
                LastActivity: time.Now(),
                CreatedAt:    time.Now(),
        }

        return session, nil</span>
}

// GetSession retrieves a session by token
func (u *UserService) GetSession(ctx context.Context, token string) (*models.UserSession, error) <span class="cov0" title="0">{
        var session models.UserSession

        err := u.db.QueryRow(`
                SELECT id, user_id, session_token, expires_at, metadata, created_at, last_activity
                FROM user_sessions
                WHERE session_token = $1 AND expires_at &gt; NOW()
        `, token).Scan(
                &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken,
                &amp;session.ExpiresAt, &amp;session.Context, &amp;session.CreatedAt, &amp;session.LastActivity,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("session not found or expired")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get session: %w", err)</span>
        }

        // Update last activity
        <span class="cov0" title="0">u.db.Exec("UPDATE user_sessions SET last_activity = NOW() WHERE id = $1", session.ID)

        return &amp;session, nil</span>
}

// DeleteSession deletes a session
func (u *UserService) DeleteSession(ctx context.Context, sessionID int) error <span class="cov0" title="0">{
        err := u.db.Exec("DELETE FROM user_sessions WHERE id = $1", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupExpiredSessions removes expired sessions
func (u *UserService) CleanupExpiredSessions(ctx context.Context) error <span class="cov0" title="0">{
        err := u.db.Exec("DELETE FROM user_sessions WHERE expires_at &lt; NOW()")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired sessions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

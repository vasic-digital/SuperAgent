//go:build pentest
// +build pentest

// Package pentest contains penetration tests for injection attack prevention.
package pentest

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strings"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

// SQL Injection Test Payloads
var sqlInjectionPayloads = []string{
	// Basic SQL injection
	"' OR '1'='1",
	"'; DROP TABLE users;--",
	"1; DROP TABLE users",
	"' UNION SELECT * FROM users--",
	"admin'--",
	"' OR 1=1--",
	"1' AND '1'='1",

	// Boolean-based blind
	"' AND 1=1--",
	"' AND 1=2--",

	// Time-based blind
	"' AND SLEEP(5)--",
	"'; WAITFOR DELAY '0:0:5'--",

	// Error-based
	"' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version())))--",

	// Second-order injection
	"admin'/*",
	"*/OR/**/1=1--",

	// Encoded variants
	"%27%20OR%20%271%27%3D%271",
	"'+OR+'1'='1",
}

// Command Injection Test Payloads
var commandInjectionPayloads = []string{
	// Basic command injection
	"; ls -la",
	"| cat /etc/passwd",
	"&& cat /etc/passwd",
	"|| cat /etc/passwd",
	"`cat /etc/passwd`",
	"$(cat /etc/passwd)",

	// Newline injection
	"\n cat /etc/passwd",
	"\r\n cat /etc/passwd",

	// Encoded variants
	"%3B%20ls%20-la",
	"%7C%20cat%20/etc/passwd",

	// Subshell
	"$(whoami)",
	"`whoami`",

	// Background execution
	"; sleep 10 &",
}

// XSS Test Payloads
var xssPayloads = []string{
	// Basic XSS
	"<script>alert('XSS')</script>",
	"<img src=x onerror=alert('XSS')>",
	"<svg onload=alert('XSS')>",

	// Event handlers
	"<body onload=alert('XSS')>",
	"<input onfocus=alert('XSS') autofocus>",

	// JavaScript protocol
	"javascript:alert('XSS')",
	"<a href='javascript:alert(1)'>click</a>",

	// Encoded variants
	"<script>alert(String.fromCharCode(88,83,83))</script>",
	"<img src=x onerror=alert(1)>",

	// DOM-based
	"<img src=1 onerror=this.onerror=alert(1)>",
}

// JSON Injection Test Payloads
var jsonInjectionPayloads = []string{
	`{"__proto__":{"polluted":true}}`,
	`{"constructor":{"prototype":{"polluted":true}}}`,
	`{"a":"b","c":{"$gt":""},"d":"e"}`,
}

// LDAP Injection Test Payloads
var ldapInjectionPayloads = []string{
	"*)(uid=*))(|(uid=*",
	"admin)(&)",
	"*)(|(password=*))",
	"admin)(|(objectclass=*))",
}

// TestSQLInjection tests SQL injection prevention
func TestSQLInjection(t *testing.T) {
	router := setupInjectionTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	for _, payload := range sqlInjectionPayloads {
		t.Run("SQLi_"+sanitizeTestName(payload), func(t *testing.T) {
			// Test in query parameters
			testEndpoints := []struct {
				method string
				path   string
			}{
				{"GET", "/v1/models?search=" + payload},
				{"GET", "/v1/users?name=" + payload},
				{"GET", "/v1/sessions/" + payload},
			}

			for _, ep := range testEndpoints {
				req, _ := http.NewRequest(ep.method, server.URL+ep.path, nil)
				resp, err := client.Do(req)
				if err != nil {
					continue
				}
				defer resp.Body.Close()

				// Should not return internal errors that might leak DB info
				assert.NotEqual(t, http.StatusInternalServerError, resp.StatusCode,
					"Endpoint %s leaked internal error for payload: %s", ep.path, payload)
			}

			// Test in JSON body
			body := map[string]string{
				"query": payload,
				"name":  payload,
				"id":    payload,
			}
			jsonBody, _ := json.Marshal(body)

			req, _ := http.NewRequest("POST", server.URL+"/v1/search", bytes.NewBuffer(jsonBody))
			req.Header.Set("Content-Type", "application/json")
			resp, err := client.Do(req)
			if err == nil {
				defer resp.Body.Close()
				assert.NotEqual(t, http.StatusInternalServerError, resp.StatusCode,
					"POST endpoint leaked internal error for payload: %s", payload)
			}
		})
	}
}

// TestCommandInjection tests command injection prevention
func TestCommandInjection(t *testing.T) {
	router := setupInjectionTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	for _, payload := range commandInjectionPayloads {
		t.Run("CMDi_"+sanitizeTestName(payload), func(t *testing.T) {
			// Test in various contexts
			testCases := []struct {
				path   string
				method string
				body   map[string]interface{}
			}{
				{"/v1/tools/execute", "POST", map[string]interface{}{"command": payload}},
				{"/v1/bash", "POST", map[string]interface{}{"script": payload}},
				{"/v1/files?path=" + payload, "GET", nil},
			}

			for _, tc := range testCases {
				var req *http.Request
				var reqErr error
				if tc.body != nil {
					jsonBody, _ := json.Marshal(tc.body)
					req, reqErr = http.NewRequest(tc.method, server.URL+tc.path, bytes.NewBuffer(jsonBody))
					if reqErr != nil || req == nil {
						continue // Skip malformed URLs
					}
					req.Header.Set("Content-Type", "application/json")
				} else {
					req, reqErr = http.NewRequest(tc.method, server.URL+tc.path, nil)
					if reqErr != nil || req == nil {
						continue // Skip malformed URLs
					}
				}

				resp, err := client.Do(req)
				if err != nil {
					continue
				}
				defer resp.Body.Close()

				// Check for signs of command execution
				var response map[string]interface{}
				json.NewDecoder(resp.Body).Decode(&response)

				// Response should not contain sensitive system info
				respStr := strings.ToLower(string(mustMarshal(response)))
				assert.NotContains(t, respStr, "root:", "Response contains /etc/passwd content")
				assert.NotContains(t, respStr, "bin/bash", "Response contains shell path")
			}
		})
	}
}

// TestXSSPrevention tests XSS attack prevention
func TestXSSPrevention(t *testing.T) {
	router := setupInjectionTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	for _, payload := range xssPayloads {
		t.Run("XSS_"+sanitizeTestName(payload), func(t *testing.T) {
			// Test reflected XSS - URL encode the payload
			encodedPayload := url.QueryEscape(payload)
			req, _ := http.NewRequest("GET", server.URL+"/v1/echo?message="+encodedPayload, nil)
			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			// Response should escape or sanitize the payload
			var response map[string]interface{}
			json.NewDecoder(resp.Body).Decode(&response)

			if msg, ok := response["message"].(string); ok {
				// Check payload is properly escaped or removed
				assert.NotContains(t, msg, "<script>", "XSS payload not sanitized")
				assert.NotContains(t, msg, "javascript:", "XSS payload not sanitized")
			}

			// Check Content-Type header (should not be text/html for API)
			contentType := resp.Header.Get("Content-Type")
			assert.Contains(t, contentType, "application/json", "API should return JSON, not HTML")
		})
	}
}

// TestJSONInjection tests JSON injection prevention
func TestJSONInjection(t *testing.T) {
	router := setupInjectionTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	for _, payload := range jsonInjectionPayloads {
		t.Run("JSONi_"+sanitizeTestName(payload), func(t *testing.T) {
			req, _ := http.NewRequest("POST", server.URL+"/v1/data", bytes.NewBufferString(payload))
			req.Header.Set("Content-Type", "application/json")

			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			// Should either reject malformed JSON or handle it safely
			assert.True(t, resp.StatusCode == http.StatusBadRequest || resp.StatusCode == http.StatusOK,
				"Unexpected status for JSON injection: %d", resp.StatusCode)
		})
	}
}

// TestLDAPInjection tests LDAP injection prevention
func TestLDAPInjection(t *testing.T) {
	router := setupInjectionTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	for _, payload := range ldapInjectionPayloads {
		t.Run("LDAPi_"+sanitizeTestName(payload), func(t *testing.T) {
			// Test in authentication context
			body := map[string]string{
				"username": payload,
				"password": "test",
			}
			jsonBody, _ := json.Marshal(body)

			req, _ := http.NewRequest("POST", server.URL+"/v1/auth/login", bytes.NewBuffer(jsonBody))
			req.Header.Set("Content-Type", "application/json")

			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			// Should not bypass authentication
			assert.NotEqual(t, http.StatusOK, resp.StatusCode,
				"LDAP injection might have bypassed auth with payload: %s", payload)
		})
	}
}

// TestHeaderInjection tests HTTP header injection prevention
func TestHeaderInjection(t *testing.T) {
	router := setupInjectionTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	headerInjectionPayloads := []string{
		"value\r\nX-Injected-Header: malicious",
		"value\nSet-Cookie: stolen=true",
		"value\r\n\r\n<html>injected</html>",
	}

	for _, payload := range headerInjectionPayloads {
		t.Run("HeaderInj_"+sanitizeTestName(payload), func(t *testing.T) {
			req, _ := http.NewRequest("GET", server.URL+"/v1/test", nil)
			req.Header.Set("X-Custom", payload)

			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			// Check that injected headers are not present
			assert.Empty(t, resp.Header.Get("X-Injected-Header"), "Header injection detected")
		})
	}
}

// Helper functions

func setupInjectionTestRouter() *gin.Engine {
	r := gin.New()
	r.Use(gin.Recovery())

	// Mock endpoints for testing
	r.GET("/v1/models", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"models": []string{}})
	})

	r.GET("/v1/users", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"users": []string{}})
	})

	r.GET("/v1/sessions/:id", func(c *gin.Context) {
		c.JSON(http.StatusNotFound, gin.H{"error": "session not found"})
	})

	r.POST("/v1/search", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"results": []string{}})
	})

	r.POST("/v1/tools/execute", func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "command execution disabled"})
	})

	r.POST("/v1/bash", func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "bash execution disabled"})
	})

	r.GET("/v1/files", func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "file access disabled"})
	})

	r.GET("/v1/echo", func(c *gin.Context) {
		msg := c.Query("message")
		// Simple sanitization - in production use proper sanitization library
		msg = strings.ReplaceAll(msg, "<", "&lt;")
		msg = strings.ReplaceAll(msg, ">", "&gt;")
		// Sanitize javascript protocol
		msg = strings.ReplaceAll(strings.ToLower(msg), "javascript:", "")
		c.JSON(http.StatusOK, gin.H{"message": msg})
	})

	r.POST("/v1/data", func(c *gin.Context) {
		var data map[string]interface{}
		if err := c.ShouldBindJSON(&data); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON"})
			return
		}
		c.JSON(http.StatusOK, gin.H{"received": true})
	})

	r.POST("/v1/auth/login", func(c *gin.Context) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
	})

	r.GET("/v1/test", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	return r
}

func sanitizeTestName(s string) string {
	// Replace problematic characters for test names
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, "'", "")
	s = strings.ReplaceAll(s, "\"", "")
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, "\\", "_")
	s = strings.ReplaceAll(s, "\n", "_")
	s = strings.ReplaceAll(s, "\r", "_")
	s = strings.ReplaceAll(s, ";", "_")
	if len(s) > 30 {
		s = s[:30]
	}
	return s
}

func mustMarshal(v interface{}) []byte {
	b, _ := json.Marshal(v)
	return b
}

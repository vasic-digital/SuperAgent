//go:build pentest
// +build pentest

// Package pentest contains penetration tests for authentication bypass prevention.
package pentest

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// isRejectionStatus returns true if the status code indicates the request was rejected
// Both 401 (Unauthorized) and 403 (Forbidden) are valid rejection codes
func isRejectionStatus(status int) bool {
	return status == http.StatusUnauthorized || status == http.StatusForbidden
}

// TestJWTManipulation tests JWT token manipulation attacks
func TestJWTManipulation(t *testing.T) {
	router := setupAuthTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	t.Run("AlgorithmNone", func(t *testing.T) {
		// Test alg:none attack
		header := base64URLEncode([]byte(`{"alg":"none","typ":"JWT"}`))
		payload := base64URLEncode([]byte(`{"sub":"admin","role":"admin","exp":` +
			string(mustMarshalInt(time.Now().Add(time.Hour).Unix())) + `}`))
		token := header + "." + payload + "."

		req, _ := http.NewRequest("GET", server.URL+"/v1/admin/users", nil)
		req.Header.Set("Authorization", "Bearer "+token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.True(t, isRejectionStatus(resp.StatusCode),
			"alg:none token should be rejected (got %d)", resp.StatusCode)
	})

	t.Run("AlgorithmConfusion", func(t *testing.T) {
		// Test HS256/RS256 confusion attack
		// Create HS256 token signed with public key (which attacker might know)
		header := base64URLEncode([]byte(`{"alg":"HS256","typ":"JWT"}`))
		payload := base64URLEncode([]byte(`{"sub":"admin","role":"admin"}`))

		// In real attack, this would be signed with the public key
		fakeSignature := base64URLEncode([]byte("fake_signature"))
		token := header + "." + payload + "." + fakeSignature

		req, _ := http.NewRequest("GET", server.URL+"/v1/admin/users", nil)
		req.Header.Set("Authorization", "Bearer "+token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.True(t, isRejectionStatus(resp.StatusCode),
			"Algorithm confusion attack should be rejected (got %d)", resp.StatusCode)
	})

	t.Run("ExpiredToken", func(t *testing.T) {
		// Test expired token
		header := base64URLEncode([]byte(`{"alg":"HS256","typ":"JWT"}`))
		payload := base64URLEncode([]byte(`{"sub":"user","exp":` +
			string(mustMarshalInt(time.Now().Add(-time.Hour).Unix())) + `}`))
		token := header + "." + payload + ".fake_signature"

		req, _ := http.NewRequest("GET", server.URL+"/v1/protected", nil)
		req.Header.Set("Authorization", "Bearer "+token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.True(t, isRejectionStatus(resp.StatusCode),
			"Expired token should be rejected (got %d)", resp.StatusCode)
	})

	t.Run("ModifiedPayload", func(t *testing.T) {
		// Test token with modified payload but original signature
		// Get a valid token first
		loginResp := doLogin(server.URL, "user", "password")
		if loginResp == nil {
			t.Skip("Could not get valid token for test")
			return
		}

		// Modify the payload part
		parts := strings.Split(loginResp.Token, ".")
		if len(parts) != 3 {
			t.Skip("Invalid token format")
			return
		}

		// Replace payload with admin role
		modifiedPayload := base64URLEncode([]byte(`{"sub":"user","role":"admin"}`))
		modifiedToken := parts[0] + "." + modifiedPayload + "." + parts[2]

		req, _ := http.NewRequest("GET", server.URL+"/v1/admin/users", nil)
		req.Header.Set("Authorization", "Bearer "+modifiedToken)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.NotEqual(t, http.StatusOK, resp.StatusCode,
			"Modified token should be rejected")
	})

	t.Run("SQLInjectionInToken", func(t *testing.T) {
		// Test SQL injection in JWT claims
		header := base64URLEncode([]byte(`{"alg":"HS256","typ":"JWT"}`))
		payload := base64URLEncode([]byte(`{"sub":"' OR '1'='1","role":"admin"}`))
		token := header + "." + payload + ".fake_signature"

		req, _ := http.NewRequest("GET", server.URL+"/v1/protected", nil)
		req.Header.Set("Authorization", "Bearer "+token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.True(t, isRejectionStatus(resp.StatusCode),
			"SQL injection in token should be rejected (got %d)", resp.StatusCode)
	})
}

// TestSessionHijacking tests session hijacking prevention
func TestSessionHijacking(t *testing.T) {
	router := setupAuthTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	t.Run("SessionFixation", func(t *testing.T) {
		// Create session before login
		req, _ := http.NewRequest("GET", server.URL+"/v1/session", nil)
		req.Header.Set("Cookie", "session_id=attacker_controlled_session")

		resp, err := client.Do(req)
		require.NoError(t, err)
		resp.Body.Close()

		// Now login with that session
		loginBody, _ := json.Marshal(map[string]string{
			"username": "user",
			"password": "password",
		})
		req, _ = http.NewRequest("POST", server.URL+"/v1/auth/login", bytes.NewBuffer(loginBody))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Cookie", "session_id=attacker_controlled_session")

		resp, err = client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		// Check if a new session was created
		cookies := resp.Cookies()
		for _, cookie := range cookies {
			if cookie.Name == "session_id" {
				assert.NotEqual(t, "attacker_controlled_session", cookie.Value,
					"Session fixation vulnerability: session ID not regenerated after login")
			}
		}
	})

	t.Run("CrossUserSessionAccess", func(t *testing.T) {
		// Login as user1
		loginResp1 := doLogin(server.URL, "user1", "password1")
		if loginResp1 == nil {
			t.Skip("Could not login as user1")
			return
		}

		// Login as user2
		loginResp2 := doLogin(server.URL, "user2", "password2")
		if loginResp2 == nil {
			t.Skip("Could not login as user2")
			return
		}

		// Try to access user2's resources with user1's token
		req, _ := http.NewRequest("GET", server.URL+"/v1/users/user2/profile", nil)
		req.Header.Set("Authorization", "Bearer "+loginResp1.Token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		// Should not be able to access another user's private resources
		assert.True(t, resp.StatusCode == http.StatusForbidden || resp.StatusCode == http.StatusNotFound,
			"Cross-user session access should be denied")
	})
}

// TestPrivilegeEscalation tests privilege escalation prevention
func TestPrivilegeEscalation(t *testing.T) {
	router := setupAuthTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	t.Run("RoleManipulation", func(t *testing.T) {
		// Login as regular user
		loginResp := doLogin(server.URL, "user", "password")
		if loginResp == nil {
			t.Skip("Could not login")
			return
		}

		// Try to access admin endpoint
		req, _ := http.NewRequest("GET", server.URL+"/v1/admin/users", nil)
		req.Header.Set("Authorization", "Bearer "+loginResp.Token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		assert.True(t, resp.StatusCode == http.StatusForbidden || resp.StatusCode == http.StatusUnauthorized,
			"Regular user should not access admin endpoints")
	})

	t.Run("IDORVulnerability", func(t *testing.T) {
		// Test Insecure Direct Object Reference
		loginResp := doLogin(server.URL, "user1", "password1")
		if loginResp == nil {
			t.Skip("Could not login")
			return
		}

		// Try to access other users' data by manipulating IDs
		sensitiveEndpoints := []string{
			"/v1/users/999/settings",
			"/v1/orders/12345",
			"/v1/documents/private-doc-id",
		}

		for _, endpoint := range sensitiveEndpoints {
			req, _ := http.NewRequest("GET", server.URL+endpoint, nil)
			req.Header.Set("Authorization", "Bearer "+loginResp.Token)

			resp, err := client.Do(req)
			if err != nil {
				continue
			}
			defer resp.Body.Close()

			// Should return 403 or 404, not actual data
			assert.True(t, resp.StatusCode == http.StatusForbidden ||
				resp.StatusCode == http.StatusNotFound,
				"IDOR vulnerability: %s returned %d", endpoint, resp.StatusCode)
		}
	})

	t.Run("MassAssignment", func(t *testing.T) {
		// Login as regular user
		loginResp := doLogin(server.URL, "user", "password")
		if loginResp == nil {
			t.Skip("Could not login")
			return
		}

		// Try to update profile with admin role
		updateBody, _ := json.Marshal(map[string]interface{}{
			"name":    "Test User",
			"role":    "admin", // Attempt to escalate
			"is_admin": true,   // Another attempt
		})

		req, _ := http.NewRequest("PUT", server.URL+"/v1/users/me", bytes.NewBuffer(updateBody))
		req.Header.Set("Authorization", "Bearer "+loginResp.Token)
		req.Header.Set("Content-Type", "application/json")

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		// Verify role wasn't changed
		req, _ = http.NewRequest("GET", server.URL+"/v1/users/me", nil)
		req.Header.Set("Authorization", "Bearer "+loginResp.Token)

		resp, err = client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		var userProfile map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&userProfile)

		if role, ok := userProfile["role"].(string); ok {
			assert.NotEqual(t, "admin", role, "Mass assignment vulnerability: role was escalated")
		}
	})
}

// TestBruteForceProtection tests brute force attack prevention
func TestBruteForceProtection(t *testing.T) {
	router := setupAuthTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	t.Run("LoginBruteForce", func(t *testing.T) {
		const attempts = 10

		failedAttempts := 0
		lockedOut := false

		for i := 0; i < attempts; i++ {
			loginBody, _ := json.Marshal(map[string]string{
				"username": "admin",
				"password": "wrong_password_" + string(rune('0'+i)),
			})

			req, _ := http.NewRequest("POST", server.URL+"/v1/auth/login", bytes.NewBuffer(loginBody))
			req.Header.Set("Content-Type", "application/json")

			resp, err := client.Do(req)
			if err != nil {
				continue
			}
			resp.Body.Close()

			if resp.StatusCode == http.StatusTooManyRequests {
				lockedOut = true
				break
			}
			failedAttempts++
		}

		t.Logf("Brute Force Test: %d failed attempts before lockout=%v", failedAttempts, lockedOut)

		// Should either lock out or rate limit
		assert.True(t, lockedOut || failedAttempts < attempts,
			"Brute force protection should kick in after multiple failed attempts")
	})

	t.Run("PasswordResetBruteForce", func(t *testing.T) {
		const attempts = 10

		for i := 0; i < attempts; i++ {
			resetBody, _ := json.Marshal(map[string]string{
				"email": "admin@example.com",
			})

			req, _ := http.NewRequest("POST", server.URL+"/v1/auth/reset-password", bytes.NewBuffer(resetBody))
			req.Header.Set("Content-Type", "application/json")

			resp, err := client.Do(req)
			if err != nil {
				continue
			}
			resp.Body.Close()

			if resp.StatusCode == http.StatusTooManyRequests {
				t.Log("Password reset rate limiting is working")
				return
			}
		}

		t.Log("Note: Password reset rate limiting may not be configured")
	})
}

// TestAPIKeyExposure tests API key security
func TestAPIKeyExposure(t *testing.T) {
	router := setupAuthTestRouter()
	server := httptest.NewServer(router)
	defer server.Close()

	client := &http.Client{}

	t.Run("APIKeyInURL", func(t *testing.T) {
		// API keys in URL are vulnerable to logging
		req, _ := http.NewRequest("GET", server.URL+"/v1/data?api_key=secret_key_12345", nil)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		// Should either reject or warn about API key in URL
		t.Log("Note: API keys in URL parameters should be avoided")
	})

	t.Run("APIKeyLeakInResponse", func(t *testing.T) {
		loginResp := doLogin(server.URL, "user", "password")
		if loginResp == nil {
			t.Skip("Could not login")
			return
		}

		req, _ := http.NewRequest("GET", server.URL+"/v1/users/me", nil)
		req.Header.Set("Authorization", "Bearer "+loginResp.Token)

		resp, err := client.Do(req)
		require.NoError(t, err)
		defer resp.Body.Close()

		var profile map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&profile)

		// Check for sensitive data exposure
		sensitiveFields := []string{"password", "password_hash", "api_key", "secret", "token"}
		for _, field := range sensitiveFields {
			_, exists := profile[field]
			assert.False(t, exists, "Sensitive field %s exposed in response", field)
		}
	})
}

// Helper types and functions

type LoginResponse struct {
	Token string `json:"token"`
}

func doLogin(baseURL, username, password string) *LoginResponse {
	client := &http.Client{}
	loginBody, _ := json.Marshal(map[string]string{
		"username": username,
		"password": password,
	})

	req, _ := http.NewRequest("POST", baseURL+"/v1/auth/login", bytes.NewBuffer(loginBody))
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil
	}

	var loginResp LoginResponse
	json.NewDecoder(resp.Body).Decode(&loginResp)
	return &loginResp
}

// Simple rate limiter for testing
var loginAttempts = make(map[string]int)
var resetAttempts = make(map[string]int)

func setupAuthTestRouter() *gin.Engine {
	// Reset rate limiters for each test
	loginAttempts = make(map[string]int)
	resetAttempts = make(map[string]int)

	r := gin.New()
	r.Use(gin.Recovery())

	// Mock authentication endpoints with rate limiting
	r.POST("/v1/auth/login", func(c *gin.Context) {
		clientIP := c.ClientIP()

		// Check rate limit (5 failed attempts)
		if loginAttempts[clientIP] >= 5 {
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{"error": "too many failed attempts"})
			return
		}

		var req map[string]string
		c.BindJSON(&req)

		// Simple mock auth - in real tests, use actual auth middleware
		if req["username"] == "user" && req["password"] == "password" {
			loginAttempts[clientIP] = 0 // Reset on success
			c.JSON(http.StatusOK, gin.H{
				"token": createMockJWT(req["username"], "user"),
			})
			return
		}
		if req["username"] == "admin" && req["password"] == "admin123" {
			loginAttempts[clientIP] = 0 // Reset on success
			c.JSON(http.StatusOK, gin.H{
				"token": createMockJWT(req["username"], "admin"),
			})
			return
		}

		loginAttempts[clientIP]++
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
	})

	r.POST("/v1/auth/reset-password", func(c *gin.Context) {
		clientIP := c.ClientIP()

		// Check rate limit (3 reset attempts)
		if resetAttempts[clientIP] >= 3 {
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{"error": "too many reset attempts"})
			return
		}

		resetAttempts[clientIP]++
		c.JSON(http.StatusOK, gin.H{"message": "If the email exists, a reset link will be sent"})
	})

	r.GET("/v1/session", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	// Protected endpoints
	r.GET("/v1/protected", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"data": "protected"})
	})

	r.GET("/v1/admin/users", authMiddleware("admin"), func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"users": []string{}})
	})

	r.GET("/v1/users/me", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"username": "user",
			"role":     "user",
			"email":    "user@example.com",
		})
	})

	r.PUT("/v1/users/me", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"updated": true})
	})

	r.GET("/v1/users/:id/profile", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
	})

	r.GET("/v1/users/:id/settings", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
	})

	r.GET("/v1/orders/:id", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
	})

	r.GET("/v1/documents/:id", authMiddleware("user"), func(c *gin.Context) {
		c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
	})

	r.GET("/v1/data", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"data": "public"})
	})

	return r
}

func authMiddleware(requiredRole string) gin.HandlerFunc {
	return func(c *gin.Context) {
		auth := c.GetHeader("Authorization")
		if auth == "" {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing token"})
			return
		}

		if !strings.HasPrefix(auth, "Bearer ") {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token format"})
			return
		}

		token := strings.TrimPrefix(auth, "Bearer ")

		// Proper JWT validation for penetration testing
		parts := strings.Split(token, ".")
		if len(parts) != 3 {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token structure"})
			return
		}

		// Decode and validate header
		headerBytes, err := base64URLDecode(parts[0])
		if err != nil {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid header encoding"})
			return
		}

		var header map[string]interface{}
		if err := json.Unmarshal(headerBytes, &header); err != nil {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid header JSON"})
			return
		}

		// Check for alg:none attack
		if alg, ok := header["alg"].(string); ok {
			if alg == "none" || alg == "None" || alg == "NONE" {
				c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "alg:none not allowed"})
				return
			}
		}

		// Decode and validate payload
		payloadBytes, err := base64URLDecode(parts[1])
		if err != nil {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid payload encoding"})
			return
		}

		var payload map[string]interface{}
		if err := json.Unmarshal(payloadBytes, &payload); err != nil {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid payload JSON"})
			return
		}

		// Check for SQL injection in claims
		sub, _ := payload["sub"].(string)
		if strings.Contains(sub, "'") || strings.Contains(sub, "\"") ||
			strings.Contains(sub, "--") || strings.Contains(sub, ";") {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid characters in token"})
			return
		}

		// Check expiration
		if exp, ok := payload["exp"].(float64); ok {
			if time.Now().Unix() > int64(exp) {
				c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "token expired"})
				return
			}
		}

		// Verify signature (using test secret)
		expectedSig := computeHMAC(parts[0]+"."+parts[1], "test-secret")
		if parts[2] != expectedSig {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid signature"})
			return
		}

		// Check role
		role, _ := payload["role"].(string)
		if requiredRole == "admin" && role != "admin" {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "admin required"})
			return
		}

		c.Next()
	}
}

func base64URLDecode(s string) ([]byte, error) {
	// Add padding if needed
	switch len(s) % 4 {
	case 2:
		s += "=="
	case 3:
		s += "="
	}
	return base64.URLEncoding.DecodeString(s)
}

func computeHMAC(data, secret string) string {
	h := hmac.New(sha256.New, []byte(secret))
	h.Write([]byte(data))
	return base64URLEncode(h.Sum(nil))
}

func createMockJWT(subject, role string) string {
	header := base64URLEncode([]byte(`{"alg":"HS256","typ":"JWT"}`))
	payload := base64URLEncode([]byte(`{"sub":"` + subject + `","role":"` + role + `"}`))

	// Create signature (simplified for testing)
	h := hmac.New(sha256.New, []byte("test-secret"))
	h.Write([]byte(header + "." + payload))
	signature := base64URLEncode(h.Sum(nil))

	return header + "." + payload + "." + signature
}

func base64URLEncode(data []byte) string {
	return strings.TrimRight(base64.URLEncoding.EncodeToString(data), "=")
}

func mustMarshalInt(v int64) []byte {
	b, _ := json.Marshal(v)
	return b
}

package services

import (
	"fmt"
	"time"
)

// DebateResult represents the outcome of a complete AI debate
type DebateResult struct {
	DebateID       string                 `json:"debate_id"`
	StartTime      time.Time              `json:"start_time"`
	EndTime        time.Time              `json:"end_time"`
	Duration       time.Duration          `json:"duration"`
	TotalRounds    int                    `json:"total_rounds"`
	Participants   []ParticipantResponse  `json:"participants"`
	Consensus      *ConsensusResult       `json:"consensus,omitempty"`
	CogneeInsights *CogneeInsights        `json:"cognee_insights,omitempty"`
	QualityScore   float64                `json:"quality_score"`
	Success        bool                   `json:"success"`
	ErrorMessage   string                 `json:"error_message,omitempty"`
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ConsensusResult represents the consensus reached during debate
type ConsensusResult struct {
	Achieved       bool          `json:"achieved"`
	Confidence     float64       `json:"confidence"`
	AgreementLevel float64       `json:"agreement_level"`
	FinalPosition  string        `json:"final_position"`
	KeyPoints      []string      `json:"key_points"`
	Disagreements  []string      `json:"disagreements"`
	VotingSummary  VotingSummary `json:"voting_summary"`
	Timestamp      time.Time     `json:"timestamp"`
}

// ParticipantResponse represents a single participant's response
type ParticipantResponse struct {
	ParticipantID   string          `json:"participant_id"`
	ParticipantName string          `json:"participant_name"`
	Role            string          `json:"role"`
	Round           int             `json:"round"`
	Response        string          `json:"response"`
	Confidence      float64         `json:"confidence"`
	QualityScore    float64         `json:"quality_score"`
	ResponseTime    time.Duration   `json:"response_time"`
	LLMProvider     string          `json:"llm_provider"`
	LLMModel        string          `json:"llm_model"`
	CogneeEnhanced  bool            `json:"cognee_enhanced"`
	CogneeAnalysis  *CogneeAnalysis `json:"cognee_analysis,omitempty"`
	Timestamp       time.Time       `json:"timestamp"`
}

// CogneeInsights represents insights generated by Cognee AI
type CogneeInsights struct {
	DatasetName       string            `json:"dataset_name"`
	EnhancementTime   time.Duration     `json:"enhancement_time"`
	SemanticAnalysis  SemanticAnalysis  `json:"semantic_analysis"`
	EntityExtraction  []Entity          `json:"entity_extraction"`
	SentimentAnalysis SentimentAnalysis `json:"sentiment_analysis"`
	KnowledgeGraph    KnowledgeGraph    `json:"knowledge_graph"`
	Recommendations   []string          `json:"recommendations"`
	QualityMetrics    QualityMetrics    `json:"quality_metrics"`
}

// CogneeAnalysis represents Cognee analysis for a single response
type CogneeAnalysis struct {
	Enhanced         bool          `json:"enhanced"`
	OriginalResponse string        `json:"original_response,omitempty"`
	EnhancedResponse string        `json:"enhanced_response,omitempty"`
	Sentiment        string        `json:"sentiment"`
	Entities         []string      `json:"entities"`
	KeyPhrases       []string      `json:"key_phrases"`
	Confidence       float64       `json:"confidence"`
	ProcessingTime   time.Duration `json:"processing_time"`
}

// VotingSummary represents the voting results
type VotingSummary struct {
	Strategy         string         `json:"strategy"`
	TotalVotes       int            `json:"total_votes"`
	VoteDistribution map[string]int `json:"vote_distribution"`
	Winner           string         `json:"winner"`
	Margin           float64        `json:"margin"`
}

// SemanticAnalysis represents semantic analysis results
type SemanticAnalysis struct {
	SimilarityMatrix [][]float64 `json:"similarity_matrix"`
	Clusters         []Cluster   `json:"clusters"`
	MainThemes       []string    `json:"main_themes"`
	CoherenceScore   float64     `json:"coherence_score"`
}

// SentimentAnalysis represents sentiment analysis results
type SentimentAnalysis struct {
	OverallSentiment string             `json:"overall_sentiment"`
	SentimentScore   float64            `json:"sentiment_score"`
	SentimentByRound []SentimentByRound `json:"sentiment_by_round"`
}

// KnowledgeGraph represents the knowledge graph
type KnowledgeGraph struct {
	Nodes           []Node   `json:"nodes"`
	Edges           []Edge   `json:"edges"`
	CentralConcepts []string `json:"central_concepts"`
}

// QualityMetrics represents quality metrics
type QualityMetrics struct {
	Coherence    float64 `json:"coherence"`
	Relevance    float64 `json:"relevance"`
	Accuracy     float64 `json:"accuracy"`
	Completeness float64 `json:"completeness"`
	OverallScore float64 `json:"overall_score"`
}

// Helper types
type Entity struct {
	Text       string  `json:"text"`
	Type       string  `json:"type"`
	Confidence float64 `json:"confidence"`
}

type Cluster struct {
	ID       string   `json:"id"`
	Members  []string `json:"members"`
	Centroid string   `json:"centroid"`
}

type SentimentByRound struct {
	Round     int     `json:"round"`
	Sentiment string  `json:"sentiment"`
	Score     float64 `json:"score"`
}

type Node struct {
	ID         string                 `json:"id"`
	Label      string                 `json:"label"`
	Type       string                 `json:"type"`
	Properties map[string]interface{} `json:"properties"`
}

type Edge struct {
	Source string  `json:"source"`
	Target string  `json:"target"`
	Type   string  `json:"type"`
	Weight float64 `json:"weight"`
}

// Validate validates the DebateResult
func (dr *DebateResult) Validate() error {
	if dr.DebateID == "" {
		return fmt.Errorf("debate_id is required")
	}
	if dr.StartTime.IsZero() {
		return fmt.Errorf("start_time is required")
	}
	if dr.TotalRounds < 1 {
		return fmt.Errorf("total_rounds must be at least 1")
	}
	if len(dr.Participants) < 2 {
		return fmt.Errorf("at least 2 participants required")
	}
	return nil
}

// Validate validates the ConsensusResult
func (cr *ConsensusResult) Validate() error {
	if cr.Timestamp.IsZero() {
		return fmt.Errorf("timestamp is required")
	}
	if cr.Confidence < 0 || cr.Confidence > 1 {
		return fmt.Errorf("confidence must be between 0 and 1")
	}
	return nil
}

// Validate validates the ParticipantResponse
func (pr *ParticipantResponse) Validate() error {
	if pr.ParticipantID == "" {
		return fmt.Errorf("participant_id is required")
	}
	if pr.ParticipantName == "" {
		return fmt.Errorf("participant_name is required")
	}
	if pr.Round < 1 {
		return fmt.Errorf("round must be at least 1")
	}
	if pr.Response == "" {
		return fmt.Errorf("response is required")
	}
	if pr.Timestamp.IsZero() {
		return fmt.Errorf("timestamp is required")
	}
	return nil
}

package services

import (
	"fmt"
	"time"
)

// DebateResult represents the outcome of a complete AI debate
type DebateResult struct {
	DebateID        string                `json:"debate_id"`
	SessionID       string                `json:"session_id,omitempty"`
	Topic           string                `json:"topic,omitempty"`
	StartTime       time.Time             `json:"start_time"`
	EndTime         time.Time             `json:"end_time"`
	Duration        time.Duration         `json:"duration"`
	TotalRounds     int                   `json:"total_rounds"`
	RoundsConducted int                   `json:"rounds_conducted,omitempty"`
	Participants    []ParticipantResponse `json:"participants"`
	AllResponses    []ParticipantResponse `json:"all_responses,omitempty"`
	BestResponse    *ParticipantResponse  `json:"best_response,omitempty"`
	Consensus       *ConsensusResult      `json:"consensus,omitempty"`
	CogneeInsights  *CogneeInsights       `json:"cognee_insights,omitempty"`
	QualityScore    float64               `json:"quality_score"`
	FinalScore      float64               `json:"final_score,omitempty"`
	QualityMetrics  *QualityMetrics       `json:"quality_metrics,omitempty"`
	Success         bool                  `json:"success"`
	FallbackUsed    bool                  `json:"fallback_used,omitempty"`
	CogneeEnhanced  bool                  `json:"cognee_enhanced,omitempty"`
	MemoryUsed      bool                  `json:"memory_used,omitempty"`
	Recommendations []string              `json:"recommendations,omitempty"`
	ErrorMessage    string                `json:"error_message,omitempty"`
	Metadata        map[string]any        `json:"metadata,omitempty"`

	// NEW: Integrated AI Debate Features Metadata
	ValidationResult   interface{}    `json:"validation_result,omitempty"`    // 4-Pass Validation result
	TestDrivenMetadata map[string]any `json:"test_driven_metadata,omitempty"` // Test-Driven Debate metadata
	ToolEnrichmentUsed bool           `json:"tool_enrichment_used,omitempty"` // Tool Integration flag
	SpecializedRole    string         `json:"specialized_role,omitempty"`     // Specialized role used
}

// ConsensusResult represents the consensus reached during debate
type ConsensusResult struct {
	Reached        bool          `json:"reached,omitempty"`
	Achieved       bool          `json:"achieved"`
	Confidence     float64       `json:"confidence"`
	ConsensusLevel float64       `json:"consensus_level,omitempty"`
	AgreementLevel float64       `json:"agreement_level"`
	AgreementScore float64       `json:"agreement_score,omitempty"`
	FinalPosition  string        `json:"final_position"`
	KeyPoints      []string      `json:"key_points"`
	Disagreements  []string      `json:"disagreements"`
	Summary        string        `json:"summary,omitempty"`
	VotingSummary  VotingSummary `json:"voting_summary"`
	Timestamp      time.Time     `json:"timestamp"`
	QualityScore   float64       `json:"quality_score,omitempty"`
}

// ParticipantResponse represents a single participant's response
type ParticipantResponse struct {
	ParticipantID   string          `json:"participant_id"`
	ParticipantName string          `json:"participant_name"`
	Role            string          `json:"role"`
	Round           int             `json:"round"`
	RoundNumber     int             `json:"round_number,omitempty"`
	Response        string          `json:"response"`
	Content         string          `json:"content,omitempty"`
	Confidence      float64         `json:"confidence"`
	QualityScore    float64         `json:"quality_score"`
	ResponseTime    time.Duration   `json:"response_time"`
	LLMProvider     string          `json:"llm_provider"`
	LLMModel        string          `json:"llm_model"`
	LLMName         string          `json:"llm_name,omitempty"`
	CogneeEnhanced  bool            `json:"cognee_enhanced"`
	CogneeAnalysis  *CogneeAnalysis `json:"cognee_analysis,omitempty"`
	Timestamp       time.Time       `json:"timestamp"`
	Metadata        map[string]any  `json:"metadata,omitempty"`
}

// CogneeInsights represents insights generated by Cognee AI
type CogneeInsights struct {
	DatasetName       string             `json:"dataset_name"`
	EnhancementTime   time.Duration      `json:"enhancement_time"`
	SemanticAnalysis  SemanticAnalysis   `json:"semantic_analysis"`
	EntityExtraction  []Entity           `json:"entity_extraction"`
	SentimentAnalysis SentimentAnalysis  `json:"sentiment_analysis"`
	KnowledgeGraph    KnowledgeGraph     `json:"knowledge_graph"`
	Recommendations   []string           `json:"recommendations"`
	QualityMetrics    *QualityMetrics    `json:"quality_metrics,omitempty"`
	TopicModeling     map[string]float64 `json:"topic_modeling,omitempty"`
	CoherenceScore    float64            `json:"coherence_score,omitempty"`
	RelevanceScore    float64            `json:"relevance_score,omitempty"`
	InnovationScore   float64            `json:"innovation_score,omitempty"`
}

// CogneeAnalysis represents Cognee analysis for a single response
type CogneeAnalysis struct {
	Enhanced         bool          `json:"enhanced"`
	OriginalResponse string        `json:"original_response,omitempty"`
	EnhancedResponse string        `json:"enhanced_response,omitempty"`
	Sentiment        string        `json:"sentiment"`
	Entities         []string      `json:"entities"`
	KeyPhrases       []string      `json:"key_phrases"`
	Confidence       float64       `json:"confidence"`
	ProcessingTime   time.Duration `json:"processing_time"`
}

// VotingSummary represents the voting results
type VotingSummary struct {
	Strategy         string         `json:"strategy"`
	TotalVotes       int            `json:"total_votes"`
	VoteDistribution map[string]int `json:"vote_distribution"`
	Winner           string         `json:"winner"`
	Margin           float64        `json:"margin"`
}

// SemanticAnalysis represents semantic analysis results
type SemanticAnalysis struct {
	SimilarityMatrix [][]float64 `json:"similarity_matrix"`
	Clusters         []Cluster   `json:"clusters"`
	MainThemes       []string    `json:"main_themes"`
	CoherenceScore   float64     `json:"coherence_score"`
}

// SentimentAnalysis represents sentiment analysis results
type SentimentAnalysis struct {
	OverallSentiment string             `json:"overall_sentiment"`
	SentimentScore   float64            `json:"sentiment_score"`
	SentimentByRound []SentimentByRound `json:"sentiment_by_round"`
}

// KnowledgeGraph represents the knowledge graph
type KnowledgeGraph struct {
	Nodes           []Node   `json:"nodes"`
	Edges           []Edge   `json:"edges"`
	CentralConcepts []string `json:"central_concepts"`
}

// QualityMetrics represents quality metrics
type QualityMetrics struct {
	Coherence    float64 `json:"coherence"`
	Relevance    float64 `json:"relevance"`
	Accuracy     float64 `json:"accuracy"`
	Completeness float64 `json:"completeness"`
	OverallScore float64 `json:"overall_score"`
}

// Helper types
type Entity struct {
	Text       string  `json:"text"`
	Type       string  `json:"type"`
	Confidence float64 `json:"confidence"`
}

type Cluster struct {
	ID       string   `json:"id"`
	Members  []string `json:"members"`
	Centroid string   `json:"centroid"`
}

type SentimentByRound struct {
	Round     int     `json:"round"`
	Sentiment string  `json:"sentiment"`
	Score     float64 `json:"score"`
}

type Node struct {
	ID         string         `json:"id"`
	Label      string         `json:"label"`
	Type       string         `json:"type"`
	Properties map[string]any `json:"properties"`
}

type Edge struct {
	Source string  `json:"source"`
	Target string  `json:"target"`
	Type   string  `json:"type"`
	Weight float64 `json:"weight"`
}

// Validate validates the DebateResult
func (dr *DebateResult) Validate() error {
	if dr.DebateID == "" {
		return fmt.Errorf("debate_id is required")
	}
	if dr.StartTime.IsZero() {
		return fmt.Errorf("start_time is required")
	}
	if dr.TotalRounds < 1 {
		return fmt.Errorf("total_rounds must be at least 1")
	}
	if len(dr.Participants) < 2 {
		return fmt.Errorf("at least 2 participants required")
	}
	return nil
}

// Validate validates the ConsensusResult
func (cr *ConsensusResult) Validate() error {
	if cr.Timestamp.IsZero() {
		return fmt.Errorf("timestamp is required")
	}
	if cr.Confidence < 0 || cr.Confidence > 1 {
		return fmt.Errorf("confidence must be between 0 and 1")
	}
	return nil
}

// Validate validates the ParticipantResponse
func (pr *ParticipantResponse) Validate() error {
	if pr.ParticipantID == "" {
		return fmt.Errorf("participant_id is required")
	}
	if pr.ParticipantName == "" {
		return fmt.Errorf("participant_name is required")
	}
	if pr.Round < 1 {
		return fmt.Errorf("round must be at least 1")
	}
	if pr.Response == "" {
		return fmt.Errorf("response is required")
	}
	if pr.Timestamp.IsZero() {
		return fmt.Errorf("timestamp is required")
	}
	return nil
}

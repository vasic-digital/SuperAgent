package handlers

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/superagent/superagent/internal/config"
	"github.com/superagent/superagent/internal/models"
	"github.com/superagent/superagent/internal/services"
)

// TestUnifiedHandler_Models tests models endpoint
func TestUnifiedHandler_Models(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)
	c.Request = httptest.NewRequest("GET", "/v1/models", nil)

	handler.Models(c)

	assert.Equal(t, http.StatusOK, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "object")
	assert.Contains(t, body, "data")
	assert.Contains(t, body, "superagent-ensemble")
}

// TestUnifiedHandler_ModelsPublic tests public models endpoint
func TestUnifiedHandler_ModelsPublic(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)
	c.Request = httptest.NewRequest("GET", "/v1/models/public", nil)

	handler.ModelsPublic(c)

	assert.Equal(t, http.StatusOK, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "object")
	assert.Contains(t, body, "data")
	assert.Contains(t, body, "superagent-ensemble")
}

// TestUnifiedHandler_ChatCompletions_InvalidRequest tests invalid request
func TestUnifiedHandler_ChatCompletions_InvalidRequest(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	// Invalid JSON
	c.Request = httptest.NewRequest("POST", "/v1/chat/completions", nil)
	c.Request.Header.Set("Content-Type", "application/json")

	handler.ChatCompletions(c)

	assert.Equal(t, http.StatusBadRequest, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "error")
}

// TestUnifiedHandler_Completions_InvalidRequest tests invalid completions request
func TestUnifiedHandler_Completions_InvalidRequest(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	// Invalid JSON
	c.Request = httptest.NewRequest("POST", "/v1/completions", nil)
	c.Request.Header.Set("Content-Type", "application/json")

	handler.Completions(c)

	assert.Equal(t, http.StatusBadRequest, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "error")
}

// TestUnifiedHandler_ChatCompletionsStream_InvalidRequest tests invalid stream request
func TestUnifiedHandler_ChatCompletionsStream_InvalidRequest(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	// Invalid JSON
	c.Request = httptest.NewRequest("POST", "/v1/chat/completions", nil)
	c.Request.Header.Set("Content-Type", "application/json")

	handler.ChatCompletionsStream(c)

	assert.Equal(t, http.StatusBadRequest, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "error")
}

// TestUnifiedHandler_CompletionsStream_InvalidRequest tests invalid completions stream request
func TestUnifiedHandler_CompletionsStream_InvalidRequest(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	// Invalid JSON
	c.Request = httptest.NewRequest("POST", "/v1/completions", nil)
	c.Request.Header.Set("Content-Type", "application/json")

	handler.CompletionsStream(c)

	assert.Equal(t, http.StatusBadRequest, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "error")
}

// TestNewUnifiedHandler tests handler creation
func TestNewUnifiedHandler(t *testing.T) {
	cfg := &config.Config{}

	handler := NewUnifiedHandler(nil, cfg)

	assert.NotNil(t, handler)
	assert.Equal(t, cfg, handler.config)
	assert.Nil(t, handler.providerRegistry)
}

// TestSendOpenAIError tests error response formatting
func TestSendOpenAIError(t *testing.T) {
	handler := &UnifiedHandler{}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	handler.sendOpenAIError(c, http.StatusBadRequest, "invalid_request_error", "Invalid request", "Missing required field")

	assert.Equal(t, http.StatusBadRequest, w.Code)

	body := w.Body.String()
	assert.Contains(t, body, "error")
	assert.Contains(t, body, "invalid_request_error")
	assert.Contains(t, body, "Invalid request")
	assert.Contains(t, body, "Missing required field")
}

// TestUnifiedHandler_RegisterOpenAIRoutes tests route registration
func TestUnifiedHandler_RegisterOpenAIRoutes(t *testing.T) {
	handler := &UnifiedHandler{}
	router := gin.Default()
	api := router.Group("/api")

	// Mock auth middleware that does nothing
	auth := func(c *gin.Context) {
		c.Next()
	}

	handler.RegisterOpenAIRoutes(api, auth)

	// Check that routes are registered by making requests
	// We can't easily test the actual route handlers without setting up the full handler,
	// but we can verify the routes exist by checking the router's routes
	routes := router.Routes()

	// Look for expected routes
	expectedPaths := []string{
		"/api/chat/completions",
		"/api/chat/completions/stream",
		"/api/completions",
		"/api/completions/stream",
		"/api/models",
	}

	// Count routes that match our expected paths
	foundCount := 0
	for _, route := range routes {
		for _, expectedPath := range expectedPaths {
			if route.Path == expectedPath {
				foundCount++
				break
			}
		}
	}

	// We should have at least some routes registered
	assert.Greater(t, foundCount, 0, "Should have registered at least some routes")
}

// TestUnifiedHandler_ConvertOpenAIChatRequest tests request conversion
func TestUnifiedHandler_ConvertOpenAIChatRequest(t *testing.T) {
	handler := &UnifiedHandler{}
	
	openaiReq := &OpenAIChatRequest{
		Model: "gpt-4",
		Messages: []OpenAIMessage{
			{
				Role:    "user",
				Content: "Hello, world!",
			},
		},
		MaxTokens:   100,
		Temperature: 0.7,
		Stream:      false,
	}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	internalReq := handler.convertOpenAIChatRequest(openaiReq, c)

	assert.NotNil(t, internalReq)
	assert.Equal(t, 1, len(internalReq.Messages))
	assert.Equal(t, "user", internalReq.Messages[0].Role)
	assert.Equal(t, "Hello, world!", internalReq.Messages[0].Content)
	assert.Equal(t, "gpt-4", internalReq.ModelParams.Model)
	assert.Equal(t, 100, internalReq.ModelParams.MaxTokens)
	assert.Equal(t, 0.7, internalReq.ModelParams.Temperature)
}

// TestUnifiedHandler_ConvertOpenAIChatRequest_WithEnsemble tests request conversion with ensemble config
func TestUnifiedHandler_ConvertOpenAIChatRequest_WithEnsemble(t *testing.T) {
	handler := &UnifiedHandler{}
	
	ensembleConfig := &models.EnsembleConfig{
		Strategy:           "weighted_voting",
		PreferredProviders: []string{"openai", "anthropic"},
	}
	
	openaiReq := &OpenAIChatRequest{
		Model: "superagent-ensemble",
		Messages: []OpenAIMessage{
			{
				Role:    "user",
				Content: "Test with ensemble",
			},
		},
		EnsembleConfig: ensembleConfig,
	}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	internalReq := handler.convertOpenAIChatRequest(openaiReq, c)

	assert.NotNil(t, internalReq)
	assert.NotNil(t, internalReq.EnsembleConfig)
	assert.Equal(t, "weighted_voting", internalReq.EnsembleConfig.Strategy)
	assert.Equal(t, 2, len(internalReq.EnsembleConfig.PreferredProviders))
	assert.Equal(t, "openai", internalReq.EnsembleConfig.PreferredProviders[0])
	assert.Equal(t, "anthropic", internalReq.EnsembleConfig.PreferredProviders[1])
}

// TestUnifiedHandler_ConvertToOpenAIChatResponse tests response conversion
func TestUnifiedHandler_ConvertToOpenAIChatResponse(t *testing.T) {
	handler := &UnifiedHandler{}
	
	ensembleResult := &services.EnsembleResult{
		Selected: &models.LLMResponse{
			ID:           "test-id-123",
			ProviderName: "openai",
			Content:      "This is a test response",
			TokensUsed:   30,
		},
		VotingMethod: "confidence_weighted",
	}
	
	openaiReq := &OpenAIChatRequest{
		Model: "gpt-4",
	}

	response := handler.convertToOpenAIChatResponse(ensembleResult, openaiReq)

	assert.NotNil(t, response)
	assert.Contains(t, response.ID, "chatcmpl-")
	assert.Equal(t, "chat.completion", response.Object)
	assert.Equal(t, "gpt-4", response.Model)
	assert.Equal(t, 1, len(response.Choices))
	assert.Equal(t, "assistant", response.Choices[0].Message.Role)
	assert.Equal(t, "This is a test response", response.Choices[0].Message.Content)
	assert.Equal(t, "stop", response.Choices[0].FinishReason)
	assert.NotNil(t, response.Usage)
	assert.Equal(t, 30, response.Usage.TotalTokens)
}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	internalReq := handler.convertOpenAIChatRequest(openaiReq, c)

	assert.NotNil(t, internalReq)
	assert.Equal(t, "gpt-4", internalReq.Model)
	assert.Equal(t, 1, len(internalReq.Messages))
	assert.Equal(t, "user", internalReq.Messages[0].Role)
	assert.Equal(t, "Hello, world!", internalReq.Messages[0].Content)
	assert.Equal(t, 100, internalReq.MaxTokens)
	assert.Equal(t, 0.7, internalReq.Temperature)
	assert.False(t, internalReq.Stream)
}

// TestUnifiedHandler_ConvertOpenAIChatRequest_WithEnsemble tests request conversion with ensemble config
func TestUnifiedHandler_ConvertOpenAIChatRequest_WithEnsemble(t *testing.T) {
	handler := &UnifiedHandler{}

	ensembleConfig := &models.EnsembleConfig{
		Strategy:  "weighted_voting",
		Providers: []string{"openai", "anthropic"},
	}

	openaiReq := &OpenAIChatRequest{
		Model: "superagent-ensemble",
		Messages: []OpenAIMessage{
			{
				Role:    "user",
				Content: "Test with ensemble",
			},
		},
		EnsembleConfig: ensembleConfig,
	}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	internalReq := handler.convertOpenAIChatRequest(openaiReq, c)

	assert.NotNil(t, internalReq)
	assert.Equal(t, "superagent-ensemble", internalReq.Model)
	assert.NotNil(t, internalReq.EnsembleConfig)
	assert.Equal(t, "weighted_voting", internalReq.EnsembleConfig.Strategy)
	assert.Equal(t, 2, len(internalReq.EnsembleConfig.Providers))
	assert.Equal(t, "openai", internalReq.EnsembleConfig.Providers[0])
	assert.Equal(t, "anthropic", internalReq.EnsembleConfig.Providers[1])
}

// TestUnifiedHandler_ConvertToOpenAIChatResponse tests response conversion
func TestUnifiedHandler_ConvertToOpenAIChatResponse(t *testing.T) {
	handler := &UnifiedHandler{}

	ensembleResult := &services.EnsembleResult{
		Response: &models.LLMResponse{
			ID:      "test-id-123",
			Model:   "gpt-4",
			Content: "This is a test response",
			Usage: &models.Usage{
				PromptTokens:     10,
				CompletionTokens: 20,
				TotalTokens:      30,
			},
		},
		Provider: "openai",
	}

	openaiReq := &OpenAIChatRequest{
		Model: "gpt-4",
	}

	response := handler.convertToOpenAIChatResponse(ensembleResult, openaiReq)

	assert.NotNil(t, response)
	assert.Equal(t, "test-id-123", response.ID)
	assert.Equal(t, "chat.completion", response.Object)
	assert.Equal(t, "gpt-4", response.Model)
	assert.Equal(t, 1, len(response.Choices))
	assert.Equal(t, "assistant", response.Choices[0].Message.Role)
	assert.Equal(t, "This is a test response", response.Choices[0].Message.Content)
	assert.Equal(t, "stop", response.Choices[0].FinishReason)
	assert.NotNil(t, response.Usage)
	assert.Equal(t, 10, response.Usage.PromptTokens)
	assert.Equal(t, 20, response.Usage.CompletionTokens)
	assert.Equal(t, 30, response.Usage.TotalTokens)
}

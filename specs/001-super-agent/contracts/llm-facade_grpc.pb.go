// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: specs/001-super-agent/contracts/llm-facade.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LLMFacade_Complete_FullMethodName         = "/llm.LLMFacade/Complete"
	LLMFacade_CompleteStream_FullMethodName   = "/llm.LLMFacade/CompleteStream"
	LLMFacade_Chat_FullMethodName             = "/llm.LLMFacade/Chat"
	LLMFacade_ListProviders_FullMethodName    = "/llm.LLMFacade/ListProviders"
	LLMFacade_AddProvider_FullMethodName      = "/llm.LLMFacade/AddProvider"
	LLMFacade_UpdateProvider_FullMethodName   = "/llm.LLMFacade/UpdateProvider"
	LLMFacade_RemoveProvider_FullMethodName   = "/llm.LLMFacade/RemoveProvider"
	LLMFacade_HealthCheck_FullMethodName      = "/llm.LLMFacade/HealthCheck"
	LLMFacade_GetMetrics_FullMethodName       = "/llm.LLMFacade/GetMetrics"
	LLMFacade_CreateSession_FullMethodName    = "/llm.LLMFacade/CreateSession"
	LLMFacade_GetSession_FullMethodName       = "/llm.LLMFacade/GetSession"
	LLMFacade_TerminateSession_FullMethodName = "/llm.LLMFacade/TerminateSession"
)

// LLMFacadeClient is the client API for LLMFacade service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Main LLM Facade Service
type LLMFacadeClient interface {
	// Standard completion request
	Complete(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (*CompletionResponse, error)
	// Streaming completion for real-time generation
	CompleteStream(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CompletionResponse], error)
	// Chat-style interaction with message history
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error)
	// Provider management
	ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersResponse, error)
	AddProvider(ctx context.Context, in *AddProviderRequest, opts ...grpc.CallOption) (*ProviderResponse, error)
	UpdateProvider(ctx context.Context, in *UpdateProviderRequest, opts ...grpc.CallOption) (*ProviderResponse, error)
	RemoveProvider(ctx context.Context, in *RemoveProviderRequest, opts ...grpc.CallOption) (*ProviderResponse, error)
	// Health and monitoring
	HealthCheck(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
	// Session management
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*SessionResponse, error)
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*SessionResponse, error)
	TerminateSession(ctx context.Context, in *TerminateSessionRequest, opts ...grpc.CallOption) (*SessionResponse, error)
}

type lLMFacadeClient struct {
	cc grpc.ClientConnInterface
}

func NewLLMFacadeClient(cc grpc.ClientConnInterface) LLMFacadeClient {
	return &lLMFacadeClient{cc}
}

func (c *lLMFacadeClient) Complete(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (*CompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompletionResponse)
	err := c.cc.Invoke(ctx, LLMFacade_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) CompleteStream(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CompletionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LLMFacade_ServiceDesc.Streams[0], LLMFacade_CompleteStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CompletionRequest, CompletionResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LLMFacade_CompleteStreamClient = grpc.ServerStreamingClient[CompletionResponse]

func (c *lLMFacadeClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LLMFacade_ServiceDesc.Streams[1], LLMFacade_Chat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LLMFacade_ChatClient = grpc.ServerStreamingClient[ChatResponse]

func (c *lLMFacadeClient) ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProvidersResponse)
	err := c.cc.Invoke(ctx, LLMFacade_ListProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) AddProvider(ctx context.Context, in *AddProviderRequest, opts ...grpc.CallOption) (*ProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProviderResponse)
	err := c.cc.Invoke(ctx, LLMFacade_AddProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) UpdateProvider(ctx context.Context, in *UpdateProviderRequest, opts ...grpc.CallOption) (*ProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProviderResponse)
	err := c.cc.Invoke(ctx, LLMFacade_UpdateProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) RemoveProvider(ctx context.Context, in *RemoveProviderRequest, opts ...grpc.CallOption) (*ProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProviderResponse)
	err := c.cc.Invoke(ctx, LLMFacade_RemoveProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) HealthCheck(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, LLMFacade_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, LLMFacade_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*SessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionResponse)
	err := c.cc.Invoke(ctx, LLMFacade_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*SessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionResponse)
	err := c.cc.Invoke(ctx, LLMFacade_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMFacadeClient) TerminateSession(ctx context.Context, in *TerminateSessionRequest, opts ...grpc.CallOption) (*SessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionResponse)
	err := c.cc.Invoke(ctx, LLMFacade_TerminateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LLMFacadeServer is the server API for LLMFacade service.
// All implementations must embed UnimplementedLLMFacadeServer
// for forward compatibility.
//
// Main LLM Facade Service
type LLMFacadeServer interface {
	// Standard completion request
	Complete(context.Context, *CompletionRequest) (*CompletionResponse, error)
	// Streaming completion for real-time generation
	CompleteStream(*CompletionRequest, grpc.ServerStreamingServer[CompletionResponse]) error
	// Chat-style interaction with message history
	Chat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error
	// Provider management
	ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersResponse, error)
	AddProvider(context.Context, *AddProviderRequest) (*ProviderResponse, error)
	UpdateProvider(context.Context, *UpdateProviderRequest) (*ProviderResponse, error)
	RemoveProvider(context.Context, *RemoveProviderRequest) (*ProviderResponse, error)
	// Health and monitoring
	HealthCheck(context.Context, *HealthRequest) (*HealthResponse, error)
	GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
	// Session management
	CreateSession(context.Context, *CreateSessionRequest) (*SessionResponse, error)
	GetSession(context.Context, *GetSessionRequest) (*SessionResponse, error)
	TerminateSession(context.Context, *TerminateSessionRequest) (*SessionResponse, error)
	mustEmbedUnimplementedLLMFacadeServer()
}

// UnimplementedLLMFacadeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLLMFacadeServer struct{}

func (UnimplementedLLMFacadeServer) Complete(context.Context, *CompletionRequest) (*CompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedLLMFacadeServer) CompleteStream(*CompletionRequest, grpc.ServerStreamingServer[CompletionResponse]) error {
	return status.Error(codes.Unimplemented, "method CompleteStream not implemented")
}
func (UnimplementedLLMFacadeServer) Chat(*ChatRequest, grpc.ServerStreamingServer[ChatResponse]) error {
	return status.Error(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedLLMFacadeServer) ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProviders not implemented")
}
func (UnimplementedLLMFacadeServer) AddProvider(context.Context, *AddProviderRequest) (*ProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddProvider not implemented")
}
func (UnimplementedLLMFacadeServer) UpdateProvider(context.Context, *UpdateProviderRequest) (*ProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProvider not implemented")
}
func (UnimplementedLLMFacadeServer) RemoveProvider(context.Context, *RemoveProviderRequest) (*ProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveProvider not implemented")
}
func (UnimplementedLLMFacadeServer) HealthCheck(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedLLMFacadeServer) GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedLLMFacadeServer) CreateSession(context.Context, *CreateSessionRequest) (*SessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedLLMFacadeServer) GetSession(context.Context, *GetSessionRequest) (*SessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedLLMFacadeServer) TerminateSession(context.Context, *TerminateSessionRequest) (*SessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TerminateSession not implemented")
}
func (UnimplementedLLMFacadeServer) mustEmbedUnimplementedLLMFacadeServer() {}
func (UnimplementedLLMFacadeServer) testEmbeddedByValue()                   {}

// UnsafeLLMFacadeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LLMFacadeServer will
// result in compilation errors.
type UnsafeLLMFacadeServer interface {
	mustEmbedUnimplementedLLMFacadeServer()
}

func RegisterLLMFacadeServer(s grpc.ServiceRegistrar, srv LLMFacadeServer) {
	// If the following call panics, it indicates UnimplementedLLMFacadeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LLMFacade_ServiceDesc, srv)
}

func _LLMFacade_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).Complete(ctx, req.(*CompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_CompleteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CompletionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LLMFacadeServer).CompleteStream(m, &grpc.GenericServerStream[CompletionRequest, CompletionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LLMFacade_CompleteStreamServer = grpc.ServerStreamingServer[CompletionResponse]

func _LLMFacade_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LLMFacadeServer).Chat(m, &grpc.GenericServerStream[ChatRequest, ChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LLMFacade_ChatServer = grpc.ServerStreamingServer[ChatResponse]

func _LLMFacade_ListProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).ListProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_ListProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).ListProviders(ctx, req.(*ListProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_AddProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).AddProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_AddProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).AddProvider(ctx, req.(*AddProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_UpdateProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).UpdateProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_UpdateProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).UpdateProvider(ctx, req.(*UpdateProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_RemoveProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).RemoveProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_RemoveProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).RemoveProvider(ctx, req.(*RemoveProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).HealthCheck(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).GetMetrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMFacade_TerminateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMFacadeServer).TerminateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMFacade_TerminateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMFacadeServer).TerminateSession(ctx, req.(*TerminateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LLMFacade_ServiceDesc is the grpc.ServiceDesc for LLMFacade service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LLMFacade_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "llm.LLMFacade",
	HandlerType: (*LLMFacadeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Complete",
			Handler:    _LLMFacade_Complete_Handler,
		},
		{
			MethodName: "ListProviders",
			Handler:    _LLMFacade_ListProviders_Handler,
		},
		{
			MethodName: "AddProvider",
			Handler:    _LLMFacade_AddProvider_Handler,
		},
		{
			MethodName: "UpdateProvider",
			Handler:    _LLMFacade_UpdateProvider_Handler,
		},
		{
			MethodName: "RemoveProvider",
			Handler:    _LLMFacade_RemoveProvider_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _LLMFacade_HealthCheck_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _LLMFacade_GetMetrics_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _LLMFacade_CreateSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _LLMFacade_GetSession_Handler,
		},
		{
			MethodName: "TerminateSession",
			Handler:    _LLMFacade_TerminateSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CompleteStream",
			Handler:       _LLMFacade_CompleteStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Chat",
			Handler:       _LLMFacade_Chat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "specs/001-super-agent/contracts/llm-facade.proto",
}

const (
	LLMProvider_Complete_FullMethodName        = "/llm.LLMProvider/Complete"
	LLMProvider_CompleteStream_FullMethodName  = "/llm.LLMProvider/CompleteStream"
	LLMProvider_HealthCheck_FullMethodName     = "/llm.LLMProvider/HealthCheck"
	LLMProvider_GetCapabilities_FullMethodName = "/llm.LLMProvider/GetCapabilities"
	LLMProvider_ValidateConfig_FullMethodName  = "/llm.LLMProvider/ValidateConfig"
)

// LLMProviderClient is the client API for LLMProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Provider Plugin Service (for external plugins)
type LLMProviderClient interface {
	// Standard completion request
	Complete(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (*CompletionResponse, error)
	// Streaming completion
	CompleteStream(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CompletionResponse], error)
	// Health check for load balancing
	HealthCheck(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// Provider-specific capabilities
	GetCapabilities(ctx context.Context, in *CapabilitiesRequest, opts ...grpc.CallOption) (*CapabilitiesResponse, error)
	// Configuration validation
	ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error)
}

type lLMProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewLLMProviderClient(cc grpc.ClientConnInterface) LLMProviderClient {
	return &lLMProviderClient{cc}
}

func (c *lLMProviderClient) Complete(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (*CompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompletionResponse)
	err := c.cc.Invoke(ctx, LLMProvider_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMProviderClient) CompleteStream(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CompletionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LLMProvider_ServiceDesc.Streams[0], LLMProvider_CompleteStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CompletionRequest, CompletionResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LLMProvider_CompleteStreamClient = grpc.ServerStreamingClient[CompletionResponse]

func (c *lLMProviderClient) HealthCheck(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, LLMProvider_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMProviderClient) GetCapabilities(ctx context.Context, in *CapabilitiesRequest, opts ...grpc.CallOption) (*CapabilitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CapabilitiesResponse)
	err := c.cc.Invoke(ctx, LLMProvider_GetCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMProviderClient) ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateConfigResponse)
	err := c.cc.Invoke(ctx, LLMProvider_ValidateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LLMProviderServer is the server API for LLMProvider service.
// All implementations must embed UnimplementedLLMProviderServer
// for forward compatibility.
//
// Provider Plugin Service (for external plugins)
type LLMProviderServer interface {
	// Standard completion request
	Complete(context.Context, *CompletionRequest) (*CompletionResponse, error)
	// Streaming completion
	CompleteStream(*CompletionRequest, grpc.ServerStreamingServer[CompletionResponse]) error
	// Health check for load balancing
	HealthCheck(context.Context, *HealthRequest) (*HealthResponse, error)
	// Provider-specific capabilities
	GetCapabilities(context.Context, *CapabilitiesRequest) (*CapabilitiesResponse, error)
	// Configuration validation
	ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error)
	mustEmbedUnimplementedLLMProviderServer()
}

// UnimplementedLLMProviderServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLLMProviderServer struct{}

func (UnimplementedLLMProviderServer) Complete(context.Context, *CompletionRequest) (*CompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedLLMProviderServer) CompleteStream(*CompletionRequest, grpc.ServerStreamingServer[CompletionResponse]) error {
	return status.Error(codes.Unimplemented, "method CompleteStream not implemented")
}
func (UnimplementedLLMProviderServer) HealthCheck(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedLLMProviderServer) GetCapabilities(context.Context, *CapabilitiesRequest) (*CapabilitiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCapabilities not implemented")
}
func (UnimplementedLLMProviderServer) ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateConfig not implemented")
}
func (UnimplementedLLMProviderServer) mustEmbedUnimplementedLLMProviderServer() {}
func (UnimplementedLLMProviderServer) testEmbeddedByValue()                     {}

// UnsafeLLMProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LLMProviderServer will
// result in compilation errors.
type UnsafeLLMProviderServer interface {
	mustEmbedUnimplementedLLMProviderServer()
}

func RegisterLLMProviderServer(s grpc.ServiceRegistrar, srv LLMProviderServer) {
	// If the following call panics, it indicates UnimplementedLLMProviderServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LLMProvider_ServiceDesc, srv)
}

func _LLMProvider_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMProviderServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMProvider_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMProviderServer).Complete(ctx, req.(*CompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMProvider_CompleteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CompletionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LLMProviderServer).CompleteStream(m, &grpc.GenericServerStream[CompletionRequest, CompletionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LLMProvider_CompleteStreamServer = grpc.ServerStreamingServer[CompletionResponse]

func _LLMProvider_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMProviderServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMProvider_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMProviderServer).HealthCheck(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMProvider_GetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMProviderServer).GetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMProvider_GetCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMProviderServer).GetCapabilities(ctx, req.(*CapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMProvider_ValidateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMProviderServer).ValidateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMProvider_ValidateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMProviderServer).ValidateConfig(ctx, req.(*ValidateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LLMProvider_ServiceDesc is the grpc.ServiceDesc for LLMProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LLMProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "llm.LLMProvider",
	HandlerType: (*LLMProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Complete",
			Handler:    _LLMProvider_Complete_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _LLMProvider_HealthCheck_Handler,
		},
		{
			MethodName: "GetCapabilities",
			Handler:    _LLMProvider_GetCapabilities_Handler,
		},
		{
			MethodName: "ValidateConfig",
			Handler:    _LLMProvider_ValidateConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CompleteStream",
			Handler:       _LLMProvider_CompleteStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "specs/001-super-agent/contracts/llm-facade.proto",
}

// Package main demonstrates how to create and register a custom agent.
package main

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/superagent/toolkit/pkg/toolkit"
)

// CustomAgent implements a specialized agent for code review and analysis.
type CustomAgent struct {
	config toolkit.AgentConfig
	client toolkit.Provider
}

// CodeReviewConfig represents additional configuration for the code review agent.
type CodeReviewConfig struct {
	toolkit.AgentConfig
	FocusAreas     []string `json:"focus_areas"`     // Areas to focus on: "security", "performance", "style", etc.
	Language       string   `json:"language"`        // Primary programming language
	MaxIssues      int      `json:"max_issues"`      // Maximum issues to report
	IncludeMetrics bool     `json:"include_metrics"` // Whether to include code metrics
}

// NewCustomAgent creates a new custom code review agent.
func NewCustomAgent(config map[string]interface{}) (toolkit.Agent, error) {
	// Build base agent config
	builder := toolkit.NewDefaultAgentConfigBuilder()
	baseConfig, err := builder.Build(config)
	if err != nil {
		return nil, fmt.Errorf("failed to build base config: %w", err)
	}

	agentConfig, ok := baseConfig.(*toolkit.AgentConfig)
	if !ok {
		return nil, fmt.Errorf("invalid config type")
	}

	// Get provider from registry
	tk := toolkit.GetGlobalToolkit()
	provider, err := tk.GetProvider(agentConfig.Provider)
	if err != nil {
		return nil, fmt.Errorf("provider %s not found in registry: %w", agentConfig.Provider, err)
	}

	return &CustomAgent{
		config: *agentConfig,
		client: provider,
	}, nil
}

// Name returns the name of the agent.
func (a *CustomAgent) Name() string {
	return "code-review-agent"
}

// Execute executes a code review task.
func (a *CustomAgent) Execute(ctx context.Context, task string, config interface{}) (string, error) {
	log.Printf("CodeReviewAgent: Executing task: %s", task)

	// Parse the task to understand what kind of code review is needed
	var codeSnippet string
	var reviewType string

	// Simple task parsing - in a real implementation, you'd use more sophisticated NLP
	if strings.Contains(strings.ToLower(task), "review") || strings.Contains(strings.ToLower(task), "analyze") {
		reviewType = "comprehensive"
		// Extract code from task (simplified)
		if strings.Contains(task, "```") {
			parts := strings.Split(task, "```")
			if len(parts) >= 3 {
				codeSnippet = parts[1]
			}
		}
	} else {
		reviewType = "general"
		codeSnippet = task
	}

	// Create a specialized prompt for code review
	systemPrompt := fmt.Sprintf(`You are an expert code reviewer specializing in %s code.
Focus on the following areas: %s
Provide constructive feedback with specific suggestions for improvement.
Be thorough but concise. Limit to %d major issues.
%s`,
		a.getLanguageName(),
		strings.Join(a.getFocusAreas(), ", "),
		a.getMaxIssues(),
		a.getMetricsInstruction())

	userPrompt := fmt.Sprintf(`Please review the following %s code:

%s

Review Type: %s
Please provide:
1. Overall assessment
2. Specific issues found
3. Suggested improvements
4. Code quality score (1-10)

Code to review:
%s`,
		a.getLanguageName(),
		a.getReviewContext(reviewType),
		reviewType,
		codeSnippet)

	// Create chat request
	chatReq := toolkit.ChatRequest{
		Model: a.config.Model,
		Messages: []toolkit.ChatMessage{
			{
				Role:    "system",
				Content: systemPrompt,
			},
			{
				Role:    "user",
				Content: userPrompt,
			},
		},
		MaxTokens:   a.config.MaxTokens,
		Temperature: 0.3, // Lower temperature for more consistent analysis
	}

	// Execute the chat completion
	response, err := a.client.Chat(ctx, chatReq)
	if err != nil {
		return "", fmt.Errorf("failed to execute code review: %w", err)
	}

	if len(response.Choices) == 0 {
		return "", fmt.Errorf("no response choices returned")
	}

	result := response.Choices[0].Message.Content

	// Add metadata to the result
	result = fmt.Sprintf(`# Code Review Report

**Agent:** %s
**Language:** %s
**Model:** %s
**Focus Areas:** %s
**Review Type:** %s

---

%s

---

*Generated by CodeReviewAgent v1.0*
*Tokens used: %d*`,
		a.Name(),
		a.getLanguageName(),
		a.config.Model,
		strings.Join(a.getFocusAreas(), ", "),
		reviewType,
		result,
		response.Usage.TotalTokens)

	return result, nil
}

// ValidateConfig validates the agent configuration.
func (a *CustomAgent) ValidateConfig(config interface{}) error {
	codeReviewConfig, ok := config.(*CodeReviewConfig)
	if !ok {
		return fmt.Errorf("invalid config type, expected CodeReviewConfig")
	}

	// Validate base config
	if err := codeReviewConfig.AgentConfig.Validate(); err != nil {
		return fmt.Errorf("base config validation failed: %w", err)
	}

	// Validate custom fields
	if len(codeReviewConfig.FocusAreas) == 0 {
		return fmt.Errorf("focus_areas cannot be empty")
	}

	if codeReviewConfig.Language == "" {
		return fmt.Errorf("language cannot be empty")
	}

	if codeReviewConfig.MaxIssues <= 0 {
		return fmt.Errorf("max_issues must be positive")
	}

	return nil
}

// Capabilities returns the capabilities of the code review agent.
func (a *CustomAgent) Capabilities() []string {
	return []string{
		"code_review",
		"security_analysis",
		"performance_analysis",
		"code_quality_assessment",
		"best_practices_check",
		"language_specific_analysis",
		"static_analysis",
		"code_metrics",
		"refactoring_suggestions",
		"documentation_review",
	}
}

// Helper methods

func (a *CustomAgent) getLanguageName() string {
	switch strings.ToLower(a.getLanguage()) {
	case "go", "golang":
		return "Go"
	case "python", "py":
		return "Python"
	case "javascript", "js":
		return "JavaScript"
	case "typescript", "ts":
		return "TypeScript"
	case "java":
		return "Java"
	case "cpp", "c++":
		return "C++"
	case "rust":
		return "Rust"
	default:
		return strings.Title(a.getLanguage())
	}
}

func (a *CustomAgent) getFocusAreas() []string {
	// In a real implementation, this would come from the config
	return []string{"security", "performance", "maintainability"}
}

func (a *CustomAgent) getLanguage() string {
	// In a real implementation, this would come from the config
	return "go"
}

func (a *CustomAgent) getMaxIssues() int {
	// In a real implementation, this would come from the config
	return 10
}

func (a *CustomAgent) getMetricsInstruction() string {
	// In a real implementation, this would check the config
	return "Include code complexity metrics and maintainability index."
}

func (a *CustomAgent) getReviewContext(reviewType string) string {
	switch reviewType {
	case "security":
		return "Focus on security vulnerabilities, input validation, and secure coding practices."
	case "performance":
		return "Analyze performance bottlenecks, algorithmic complexity, and optimization opportunities."
	case "style":
		return "Review code style, naming conventions, and formatting consistency."
	default:
		return "Perform a comprehensive code review covering multiple aspects."
	}
}

// Helper functions for config parsing
func getString(config map[string]interface{}, key, defaultValue string) string {
	if val, ok := config[key]; ok {
		if str, ok := val.(string); ok {
			return str
		}
	}
	return defaultValue
}

func getStringSlice(config map[string]interface{}, key string, defaultValue []string) []string {
	if val, ok := config[key]; ok {
		if slice, ok := val.([]interface{}); ok {
			result := make([]string, len(slice))
			for i, v := range slice {
				if str, ok := v.(string); ok {
					result[i] = str
				}
			}
			return result
		}
		if strSlice, ok := val.([]string); ok {
			return strSlice
		}
	}
	return defaultValue
}

func getInt(config map[string]interface{}, key string, defaultValue int) int {
	if val, ok := config[key]; ok {
		switch v := val.(type) {
		case int:
			return v
		case float64:
			return int(v)
		}
	}
	return defaultValue
}

func getBool(config map[string]interface{}, key string, defaultValue bool) bool {
	if val, ok := config[key]; ok {
		if b, ok := val.(bool); ok {
			return b
		}
	}
	return defaultValue
}

func main() {
	fmt.Println("=== Custom Agent Example ===")

	// Initialize the toolkit
	tk := toolkit.NewToolkit()
	tk.SetLogger(log.Default())

	// Create custom agent configuration
	config := map[string]interface{}{
		"name":        "advanced-code-reviewer",
		"description": "Specialized agent for comprehensive code review and analysis",
		"provider":    "siliconflow", // This would need to be a real provider
		"model":       "deepseek-coder",
		"max_tokens":  4096,
		"temperature": 0.3,
		"timeout":     60000,
		"retries":     3,
		// Custom fields
		"focus_areas":     []string{"security", "performance", "maintainability"},
		"language":        "go",
		"max_issues":      15,
		"include_metrics": true,
	}

	// Create the custom agent
	customAgent, err := NewCustomAgent(config)
	if err != nil {
		log.Fatalf("Failed to create custom agent: %v", err)
	}

	// Register the custom agent with the toolkit
	if err := tk.RegisterAgent("code-review-agent", customAgent); err != nil {
		log.Fatalf("Failed to register custom agent: %v", err)
	}

	fmt.Println("✓ Custom agent registered successfully")

	// Display agent information
	fmt.Printf("\nAgent Name: %s\n", customAgent.Name())
	fmt.Printf("Capabilities: %v\n", customAgent.Capabilities())

	// Example code to review
	sampleCode := `func processUserData(data map[string]interface{}) error {
	userID := data["user_id"]
	if userID == nil {
		return errors.New("user_id is required")
	}

	// Process user data without validation
	processData(userID.(string), data)

	return nil
}

func processData(id string, data map[string]interface{}) {
	// Direct database insertion without prepared statements
	db.Exec(fmt.Sprintf("INSERT INTO users (id, data) VALUES ('%s', '%s')", id, data["payload"]))
}`

	// Create a review task
	task := fmt.Sprintf("Please review this Go code for security vulnerabilities and performance issues:\n\n```go\n%s\n```", sampleCode)

	// Execute the review task
	fmt.Println("\n--- Executing Code Review Task ---")
	ctx := context.Background()

	result, err := customAgent.Execute(ctx, task, config)
	if err != nil {
		log.Printf("Code review failed: %v", err)
		fmt.Println("Note: This may fail if the provider is not properly configured")
	} else {
		fmt.Println("Code Review Result:")
		fmt.Println(result)
	}

	// Test configuration validation
	fmt.Println("\n--- Testing Configuration Validation ---")

	// Valid config
	validConfig := &CodeReviewConfig{
		AgentConfig: toolkit.AgentConfig{
			Name:     "test-agent",
			Provider: "test-provider",
			Model:    "test-model",
		},
		FocusAreas:     []string{"security"},
		Language:       "go",
		MaxIssues:      5,
		IncludeMetrics: true,
	}

	if err := customAgent.ValidateConfig(validConfig); err != nil {
		log.Printf("Valid config failed validation: %v", err)
	} else {
		fmt.Println("✓ Valid configuration accepted")
	}

	// Invalid config
	invalidConfig := &CodeReviewConfig{
		AgentConfig: toolkit.AgentConfig{
			Name:     "test-agent",
			Provider: "test-provider",
			Model:    "test-model",
		},
		FocusAreas: []string{}, // Empty focus areas
		Language:   "go",
		MaxIssues:  5,
	}

	if err := customAgent.ValidateConfig(invalidConfig); err == nil {
		log.Println("Invalid config should have failed validation")
	} else {
		fmt.Printf("✓ Invalid configuration rejected: %v\n", err)
	}

	fmt.Println("\n=== Custom Agent Example Complete ===")
	fmt.Println("This example demonstrates how to:")
	fmt.Println("1. Create a custom agent with specialized functionality")
	fmt.Println("2. Extend the base agent configuration")
	fmt.Println("3. Implement domain-specific task execution")
	fmt.Println("4. Register the agent with the toolkit")
	fmt.Println("5. Handle configuration validation")
	fmt.Println("6. Provide detailed capabilities information")
}
